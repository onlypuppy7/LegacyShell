//     _                                      __                      
//     /                                    /    )   /           /   /
//    /       __    __    __    __          \       /__    __   /   / 
//   /      /___) /   ) /   ) /   ' /   /    \     /   ) /___) /   /  
// _/____/_(___ _(___/_(___(_(___ _(___/_(____/___/___/_(___ _/___/___
//                  /                 /                               
//              (_ /              (_ /                                
// LegacyShell Team 2024, Blue Wizard Digital 2019


//  _    ___ ___   _   _____   _____ _  _ ___ _    _    
// | |  | __/ __| /_\ / __\ \ / / __| || | __| |  | |   
// | |__| _| (_ |/ _ \ (__ \ V /\__ \ __ | _|| |__| |__ 
// |____|___\___/_/ \_\___| |_| |___/_||_|___|____|____|
// [LS] ######## LegacyShell Specific ---------------------------------
const devlog = function (...args) {
    let condition;
    try {
        condition = true;
    } catch (e) {
        console.error("HOW?!?!?!?", e);
    };
    if (condition) {
        console.log("LS_DEVLOG", ...args);
    };
};

//  ___   _   _____   ___    ___  _  _ 
// | _ ) /_\ | _ ) \ / / |  / _ \| \| |
// | _ \/ _ \| _ \\ V /| |_| (_) | .` |
// |___/_/ \_\___/ |_| |____\___/|_|\_|
// [LS] ######## BABYLONSTART ---------------------------------
LEGACYSHELLBABYLON


//  ___ _____ ___ __  __ ___ 
// |_ _|_   _| __|  \/  / __|
//  | |  | | | _|| |\/| \__ \
// |___| |_| |___|_|  |_|___/
// [LS] ######## Items ---------------------------------
var Items = [
    ...LEGACYSHELLITEMS
];


//  __  __   _   ___  ___ 
// |  \/  | /_\ | _ \/ __|
// | |\/| |/ _ \|  _/\__ \
// |_|  |_/_/ \_\_|  |___/
// [LS] ######## Maps ---------------------------------
minMaps = LEGACYSHELLMINMAPS;


//  ___ _   _ _    _    ___ _  _ ___ _____ 
// | _ ) | | | |  | |  / __| || |_ _|_   _|
// | _ \ |_| | |__| |__\__ \ __ || |  | |  
// |___/\___/|____|____|___/_||_|___| |_|  
// [LS] ######## Bullshit ---------------------------------

//Q: What is "bullshit"?
//A: Defining of these small, weird, misc dicts/lists/funcs.

var item_classes = { //to make the items json-able
    "Cluck9mm": Cluck9mm,
    "CSG1": CSG1,
    "DozenGauge": DozenGauge,
    "RPEGG": RPEGG,
    "Eggk47": Eggk47,
};

var Slot = {
    Primary: 0,
    Secondary: 1
};

var ItemType = {
    Hat: 1,
    Stamp: 2,
    Primary: 3,
    Secondary: 4
};

var CharClass = {
    Soldier: 0,
    Scrambler: 1,
    Ranger: 2,
    Eggsploder: 3
};

CharClass.length = Object.keys(CharClass).length;

Team = {
    blue: 1,
    red: 2
};

var teamColors = {
    text: ["rgba(255, 255, 255, 1)", "rgba(64, 224, 255, 1)", "rgba(255, 192, 160, 1)"],
    meBackground: ["rgba(255, 192, 64, 0.75)", "rgba(0, 192, 255, 0.8)", "rgba(192, 64, 32, 0.8)"],
    themBackground: ["rgba(0, 0, 0, 0.25)", "rgba(0, 64, 192, 0.3)", "rgba(192, 64, 32, 0.3)"],
    summaryBackground: ["rgba(64, 64, 64, 0.75)", "rgba(0, 64, 192, 0.75)", "rgba(192, 64, 32, 0.75)"],
    outline: [new BABYLON.Color4(1, 1, 1, 1), new BABYLON.Color4(0, .75, 1, 1), new BABYLON.Color4(1, .25, .25, 1)]
};

GameType = {
    ffa: 0,
    teams: 1
};

GameTypes = [
    {
        shortName: "FFA",
        longName: "Free For All"
    }, {
        shortName: "Teams",
        longName: "Teams"
    }
];
FramesBetweenSyncs = Math.ceil(6);

NextRoundTimeout = 20;

var mapMeshes;
var stateBufferSize = 256;

var CONTROL = {
    up: 1,
    down: 2,
    left: 4,
    right: 8,
    jump: 16,
    fire: 32
};

var classes = [
    {
        name: "Soldier",
        weapon: Eggk47
    }, {
        name: "Scrambler",
        weapon: DozenGauge
    }, {
        name: "Free Ranger",
        weapon: CSG1
    }, {
        name: "Eggsploder",
        weapon: RPEGG
    }
];

var weaponStats = {
    totalDamage: {
        name: "damage",
        max: -1e3,
        min: 1e3,
        flip: false
    },
    accuracy: {
        name: "accuracy",
        max: -1e3,
        min: 1e3,
        flip: true
    },
    rof: {
        name: "fireRate",
        max: -1e3,
        min: 1e3,
        flip: true
    },
    range: {
        name: "range",
        max: -1e3,
        min: 1e3,
        flip: false
    }
};

var shellColors = ["#ffffff", "#c4e3e8", "#e2bc8b", "#d48e52", "#cb6d4b", "#8d3213", "#5e260f", "#e70a0a", "#aa24ce", "#f17ff9", "#FFD700", "#33a4ea", "#3e7753", "#66dd33"];

var engine, camera, customizer, itemRenderer, stampTexture, canvas, shadowGen, engineCaps, ws, selectedServer, meId, isGameOwner, viewingPlayerId, myTeam, nickname, gameStartTime, pingTotal, pingSamples, fpsTotal, fpsSamples, gameId, gameKey, mapIdx, gameType, privateGame, /*firebaseUi,*/ user, timesPlayed, chatInEl, chatOutEl, killEl, statsEl, purchasingEnabled, lastVer, globalXsollaToken, joinType, inputToControlMap, optimizer;
inGame = false;
var playOffline = false,
    mapTest = {},
    settings = {},
    nameTestCanvas = document.createElement("canvas"),
    freezeFrame = false,
    highestPing = 0,
    playerAccount = {},
    testing = false,
    teamSummaryEls = [],
    loggingIn = false,
    noSkybox = false,
    linkItemShown = false,
    showTaggedItems = null,
    showNugget = null,
    authAttemptComplete = false,
    checkedForReward = false,
    isRunning = false,
    autoInvite = false,
    servicesToken = null,
    isGettingNugget = false,
    adBlock = true,
    playerLimit = 18;


var shake;
var controlEl, feedbackValidateTimeout, settingsKeyNames = ["up", "down", "left", "right", "jump", "fire", "scope", "reload", "weapon", "grenade"], settingsKeyCells = {};
var lastMouseMovement = {};

var reward = null,
    debugArray = [],
    debugObject = {},
    consent = void 0;

var bigAdIdx, smallAdIdx, aipPrerollPlayer, houseAds, adTest = false, houseAdsLoaded = false, applixirAdWatched = false;

var Ease = {
    linear: function (t) {
        return t
    },
    inQuad: function (t) {
        return t * t
    },
    outQuad: function (t) {
        return t * (2 - t)
    },
    inOutQuad: function (t) {
        return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
    },
    inCubic: function (t) {
        return t * t * t
    },
    outCubic: function (t) {
        return --t * t * t + 1
    },
    inOutCubic: function (t) {
        return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
    },
    inQuart: function (t) {
        return t * t * t * t
    },
    outQuart: function (t) {
        return 1 - --t * t * t * t
    },
    inOutQuart: function (t) {
        return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
    },
    inQuint: function (t) {
        return t * t * t * t * t
    },
    outQuint: function (t) {
        return 1 + --t * t * t * t * t
    },
    inOutQuint: function (t) {
        return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
    }
};

if ("undefined" == typeof window) var fs = require("fs");
var bigAdTimeout, duplicateWarningIssued = false;

var tv1 = new BABYLON.Vector3;
var tv2 = new BABYLON.Vector3;

var flashColors = [new BABYLON.Color3(1, 1, 0), new BABYLON.Color3(0, .5, 1), new BABYLON.Color3(1, 0, 0)];

var bulletHoleManager, explosionSmokeManager, explosionFireManager, shellFragManager, respawnTime, uiCamera, grenadePowerUp, chatting, mapOverview, scope, reticle, hitIndicator, lastTimeStamp, fpsAverage, escPressed, kills, deaths, bestOverallStreak, timedGame, roundLength, roundEndTime, roundRestartTime, betweenRounds, respawnInterval, oldClockSeconds, gameScene, map, minMap, shadowLight, me, viewingPlayer, grenadeThrowPower, players, nameTexture, nameSprites, mapMesh, gameCode, munitionsManager, itemManager;
var Sounds = {},
    Music = {},
    mapOverviewAxis = 0;

var SPS, chatParser = document.createElement("DIV"),
prevCmd = [];
var pingStartTime, rotInc = Math.PI / 2;
var debugWindow, lastKey = null;

var lastLeadingTeam = 1;

var fireColors = [
    {
        pos: 0,
        color: new BABYLON.Color4(1, .9, .8, 1)
    }, {
        pos: .2,
        color: new BABYLON.Color4(1, .5, .1, 1)
    }, {
        pos: .4,
        color: new BABYLON.Color4(.6, .2, 0, 1)
    }, {
        pos: .7,
        color: new BABYLON.Color4(0, 0, 0, 0)
    }, {
        pos: 1,
        color: new BABYLON.Color4(0, 0, 0, 0)
    }
];

var smokeColors = [
    {
        pos: 0,
        color: new BABYLON.Color4(.3, .3, .3, 1)
    }, {
        pos: 1,
        color: new BABYLON.Color4(.7, .7, .7, 0)
    }
];

var bulletHitColors = [
    {
        pos: 0,
        color: new BABYLON.Color4(1, 1, 1, 1)
    }, {
        pos: .2,
        color: new BABYLON.Color4(.7, .7, .7, .7)
    }, {
        pos: 1,
        color: new BABYLON.Color4(.7, .7, .7, 0)
    }
];

var color4White = new BABYLON.Color4(1, 1, 1, 1);

//   ___ ___  __  __ __  __ ___ 
//  / __/ _ \|  \/  |  \/  / __|
// | (_| (_) | |\/| | |\/| \__ \
//  \___\___/|_|  |_|_|  |_|___/
// [LS] ######## Comms ---------------------------------

var Comm = {
    output: function (size) {
        this.buffer = new Uint8Array(size);
        this.idx = 0;
        this.packInt8 = function (val) {
            this.buffer[this.idx] = 255 & val, this.idx++
        };
        this.packInt16 = function (val) {
            this.buffer[this.idx] = 255 & val, this.buffer[this.idx + 1] = val >> 8 & 255, this.idx += 2
        };
        this.packInt32 = function (val) {
            this.buffer[this.idx] = 255 & val, this.buffer[this.idx + 1] = val >> 8 & 255, this.buffer[this.idx + 2] = val >> 16 & 255, this.buffer[this.idx + 3] = val >> 24 & 255, this.idx += 4
        };
        this.packRadU = function (val) {
            this.packInt16(1e4 * val)
        };
        this.packRad = function (val) {
            this.packInt16(1e4 * (val + Math.PI))
        };
        this.packFloat = function (val) {
            this.packInt16(300 * val)
        };
        this.packDouble = function (val) {
            this.packInt32(1e6 * val)
        };
        this.packString = function (str) {
            this.packInt8(str.length);
            for (var i = 0; i < str.length; i++) this.packInt16(str.charCodeAt(i))
        };
    },
    input: function (buf) {
        this.buffer = new Uint8Array(buf);
        this.idx = 0;
        this.isMoreDataAvailable = function () {
            return Math.max(0, this.buffer.length - this.idx)
        };
        this.unPackInt8U = function () {
            var i = this.idx;
            return this.idx++, this.buffer[i]
        };
        this.unPackInt8 = function () {
            return (this.unPackInt8U() + 128) % 256 - 128
        };
        this.unPackInt16U = function () {
            var i = this.idx;
            return this.idx += 2, this.buffer[i] + (this.buffer[i + 1] << 8)
        };
        this.unPackInt32U = function () {
            var i = this.idx;
            return this.idx += 4, this.buffer[i] + 256 * this.buffer[i + 1] + 65536 * this.buffer[i + 2] + 16777216 * this.buffer[i + 3]
        };
        this.unPackInt16 = function () {
            return (this.unPackInt16U() + 32768) % 65536 - 32768
        };
        this.unPackInt32 = function () {
            return (this.unPackInt32U() + 2147483648) % 4294967296 - 2147483648
        };
        this.unPackRadU = function () {
            return this.unPackInt16U() / 1e4
        };
        this.unPackRad = function () {
            return this.unPackRadU() - Math.PI
        };
        this.unPackFloat = function () {
            return this.unPackInt16() / 300
        };
        this.unPackDouble = function () {
            return this.unPackInt32() / 1e6
        };
        this.unPackString = function (maxLen) {
            maxLen = maxLen || 1e3;
            for (var len = Math.min(this.unPackInt8U(), maxLen), str = new String, i = 0; i < len; i++) {
                var c = this.unPackInt16U();
                0 < c && (str += String.fromCharCode(c))
            };
            return str
        };
    }
};

// [LS] Enums
CloseCode = {
    gameNotFound: 4e3,
    gameFull: 4001,
    badName: 4002,
    mainMenu: 4003,
    masterServerBusy: 4004,
    masterServerOffline: 4005
};

CommCode = {
    gameJoined: 0,
    addPlayer: 1,
    removePlayer: 2,
    chat: 3,
    controlKeys: 4,
    keyUp: 5,
    sync: 6,
    jump: 7,
    die: 8,
    hitThem: 9,
    hitMe: 10,
    collectItem: 11,
    spawnItem: 12,
    respawn: 13,
    swapWeapon: 14,
    joinGame: 15,
    ping: 16,
    pong: 17,
    clientReady: 18,
    requestRespawn: 19,
    throwGrenade: 20,
    joinPublicGame: 21,
    joinPrivateGame: 22,
    createPrivateGame: 23,
    roundStart: 24,
    switchTeam: 25,
    notification: 26,
    changeCharacter: 27,
    playerCount: 28,
    roundEnd: 29,
    pause: 30,
    announcement: 31,
    updateBalance: 32,
    reload: 33,
    refreshGameState: 34,
    switchTeamFail: 35,
    expireUpgrade: 36,
    bootPlayer: 37,
    loginRequired: 38,
    banned: 39,
    gameLocked: 40,
    expireUpgrade: 41,
    bootPlayer: 42,
    banned: 43,
    startReload: 48,
    fire: 49,
    info: 255
};

//receiving msgs
const LegacyShellOnMessage = function (msg) {
    var input = new Comm.input(msg.data); 
    while (input.isMoreDataAvailable()) {
        var cmd = input.unPackInt8U();
        switch (cmd) {
            case CommCode.pause:
                var playerId = input.unPackInt8U(),
                    player = players[playerId];
                player && player.removeFromPlay();
                break;
            case CommCode.clientReady:
                console.log("CommCode.clientReady received"), roundLength = input.unPackInt16U(), roundEndTime = input.unPackInt32U(), roundRestartTime = input.unPackInt32U(), 0 < roundLength ? (timedGame = true, 0 < roundEndTime ? (document.getElementById("gameClock").style.display = "block", roundEndTime += Date.now()) : 0 < roundRestartTime ? (document.getElementById("gameClock").style.display = "none", document.getElementById("goButton").className = "ssbutton grey", document.getElementById("goButtonLabel").innerText = "Wait...", document.getElementById("playerList").style.display = "none", setRespawnTime(Math.floor(roundRestartTime / 1e3))) : respawnTime = -1) : (timedGame = false, respawnTime = -1), openGameMenu(), startRendering(), autoInvite && inviteFriends();
                break;
            case CommCode.addPlayer:
                var id = input.unPackInt8U(),
                    uniqueId = input.unPackInt16U(),
                    name = input.unPackString(),
                    charClass = input.unPackInt8U();
                17 < id && debugArray.push("playerId out of bounds: " + id + ", " + name);
                var playerData = {
                    id: id,
                    uniqueId: uniqueId,
                    name: name,
                    charClass: charClass,
                    team: input.unPackInt8U(),
                    primaryWeaponItem: catalog.findItemBy8BitItemId(ItemType.Primary, charClass, input.unPackInt8U()),
                    secondaryWeaponItem: catalog.findItemBy8BitItemId(ItemType.Secondary, charClass, input.unPackInt8U()),
                    shellColor: input.unPackInt8U(),
                    hatItem: catalog.findItemBy8BitItemId(ItemType.Hat, charClass, input.unPackInt8U()),
                    stampItem: catalog.findItemBy8BitItemId(ItemType.Stamp, charClass, input.unPackInt8U()),
                    x: input.unPackFloat(),
                    y: input.unPackFloat(),
                    z: input.unPackFloat(),
                    dx: input.unPackFloat(),
                    dy: input.unPackFloat(),
                    dz: input.unPackFloat(),
                    yaw: input.unPackRadU(),
                    pitch: input.unPackRad(),
                    score: input.unPackInt32U(),
                    kills: input.unPackInt16U(),
                    deaths: input.unPackInt16U(),
                    streak: input.unPackInt16U(),
                    totalKills: input.unPackInt32U(),
                    totalDeaths: input.unPackInt32U(),
                    bestGameStreak: input.unPackInt16U(),
                    bestOverallStreak: input.unPackInt16U(),
                    shield: input.unPackInt8U(),
                    hp: input.unPackInt8U(),
                    playing: input.unPackInt8U(),
                    weaponIdx: input.unPackInt8U(),
                    controlKeys: input.unPackInt8U(),
                    randomSeed: input.unPackInt16U(),
                    upgradeProductId: input.unPackInt8U()
                };
                players[playerData.id] || (meId == playerData.id || (playerData.name = playerData.name.replace(/<|>/g, ""), 0 == playerData.name.length ? playerData.name = "Anonymous" : (playerData.name = fixStringWidth(playerData.name), isBadWord(playerData.name) && (playerData.name = randomName()))), addPlayer(playerData));
                break;
            case CommCode.removePlayer:
                var playerId = input.unPackInt8U();
                removePlayer(playerId);
                break;
            case CommCode.roundEnd:
                console.log("END ROUND"), prepareGameSummary(), betweenRounds = true, document.getElementById("help").style.display = "none", document.getElementById("tipContainer").style.display = "block", document.getElementById("goButton").className = "ssbutton grey", document.getElementById("goButtonLabel").innerText = "Wait...", Sounds.endRound.play(), timeout.set(showContinueDialog, 3e3), setRespawnTime(NextRoundTimeout);
                break;
            case CommCode.roundStart:
                console.log("START ROUND"), betweenRounds = false, document.getElementById("gameClock").style.display = "block", roundEndTime = Date.now() + 1e3 * roundLength;
                break;
            case CommCode.spawnItem:
                var id = input.unPackInt16U(),
                    kind = input.unPackInt8U(),
                    x = input.unPackFloat(),
                    y = input.unPackFloat(),
                    z = input.unPackFloat();
                itemManager.spawnItem(id, kind, x, y, z);
                break;
            case CommCode.collectItem:
                var playerId = input.unPackInt8U(),
                    kind = input.unPackInt8U(),
                    applyToWeaponIdx = input.unPackInt8U(),
                    id = input.unPackInt16U();
                itemManager.collectItem(kind, id), playerId == meId && me.collectItem(kind, applyToWeaponIdx);
                break;
            case CommCode.die:
                var killedPlayerName, byPlayerName, killedId = input.unPackInt8U(),
                    byId = input.unPackInt8U(),
                    rs = input.unPackInt8U(),
                    killedPlayer = players[killedId],
                    byPlayer = players[byId];
                if (killedPlayer) {
                    killedPlayerName = killedPlayer.name;
                    var pos = new BABYLON.Vector3(killedPlayer.x, killedPlayer.y + .32, killedPlayer.z);
                    killedPlayer.actor.deathSound.setPosition(pos), killedPlayer.actor.deathSound.play();
                    var soundIdx = Math.randomInt(0, Sounds.death.length);
                    Sounds.death[soundIdx].setPosition(pos), Sounds.death[soundIdx].play(), shellFragBurst(killedPlayer, 80, .2, 40), yolkBurst(killedPlayer), killedPlayer.die(), killedPlayer.actor.mesh.position.x = killedPlayer.x, killedPlayer.actor.mesh.position.y = killedPlayer.y, killedPlayer.actor.mesh.position.z = killedPlayer.z
                } else killedPlayerName = "N/A";
                if (byPlayer) {
                    if (byPlayerName = byPlayer.name, !byPlayer.isDead()) {
                        if (byPlayer.scoreKill(), byId == meId) {
                            var el = document.getElementById("bestStreak");
                            el.innerText = "BEST STREAK: " + byPlayer.bestOverallStreak
                        }
                        byId == meId && (kills++, bestOverallStreak = Math.max(bestOverallStreak, byPlayer.streak))
                    }
                } else byPlayerName = "N/A";
                if (killedId != meId) {
                    if (byId == meId) {
                        var killBox = document.getElementById("killBox");
                        killBox.style.display = "block", document.getElementById("KILLED_NAME").innerText = killedPlayerName;
                        var streakEl = document.getElementById("KILL_STREAK");
                        1 < me.streak ? streakEl.innerText = me.streak + "-KILL STREAK" : streakEl.innerText = "";
                        var scale = 1.5,
                            scaleInterval = interval.set(function () {
                                killBox.style.transform = "scale(" + scale + "," + scale + ")", (scale -= .05) <= 1 && (scale = 1, interval.clear(scaleInterval))
                            }, 33);
                        timeout.set(function () {
                            inGame && (killBox.style.display = "none")
                        }, 4e3)
                    }
                } else {
                    camera.parent = null, camera.position = new BABYLON.Vector3(viewingPlayer.actor.mesh.position.x, viewingPlayer.actor.mesh.position.y + .2, viewingPlayer.actor.mesh.position.z), byPlayer && (camera.lockedTarget = byPlayer.actor.bodyMesh), document.getElementById("KILLED_BY_NAME").innerText = byPlayerName;
                    var deathBox = document.getElementById("deathBox");
                    deathBox.style.display = "block";
                    var scale = 2,
                        scaleInterval = interval.set(function () {
                            deathBox.style.transform = "scale(" + scale + "," + scale + ")", (scale -= .05) <= 1 && inGame && (interval.clear(scaleInterval), scale = 1)
                        }, 33);
                    deaths++, setRespawnTime(rs), removeCanvasListeners(), timeout.set(function () {
                        inGame && (deathBox.style.display = "none", viewingPlayerId == meId && openGameMenu())
                    }, 3e3)
                }
                byPlayer && killedPlayer && addKillText(byPlayer, killedPlayer), rebuildPlayerList();
                break;
            case CommCode.chat:
                var playerId = input.unPackInt8U(),
                    text = input.unPackString(),
                    player = players[playerId];
                player.muted || (chatParser.innerHTML = text, text = chatParser.textContent.trim(), player && 0 < text.length && !isBadWord(text) && text.indexOf("<") < 0 && addChat(text, player));
                break;
            case CommCode.jump:
                var id = input.unPackInt8U(),
                    player = players[id];
                if (!player) break;
                player.jump();
                break;
            case CommCode.sync:
                var id = input.unPackInt8U(),
                    stateIdx = input.unPackInt8U(),
                    x = input.unPackFloat(),
                    y = input.unPackFloat(),
                    z = input.unPackFloat(),
                    climbing = input.unPackInt8U(),
                    player = players[id];
                if (!player) {
                    for (var i = 0; i < FramesBetweenSyncs; i++) input.unPackInt8U(), input.unPackRadU(), input.unPackRad();
                    break
                }
                var oldx = player.x,
                    oldy = player.y,
                    oldz = player.z,
                    olddx = player.dx,
                    olddy = player.dy,
                    olddz = player.dz,
                    oldYaw = player.yaw,
                    oldPitch = player.pitch,
                    wasJumping = player.jumping,
                    wasClimbing = player.climbing;
                if (id == meId) {
                    for (var i = 0; i < FramesBetweenSyncs; i++) input.unPackInt8U(), input.unPackRadU(), input.unPackRad();
                    var i = stateIdx,
                        state = player.stateBuffer[i];
                    player.x = x, player.y = y, player.z = z, player.dx = state.dx, player.dy = state.dy, player.dz = state.dz, player.climbing = state.climbing, player.jumping = state.jumping;
                    for (var oldKeys = me.controlKeys; i != player.stateIdx; i = Math.mod(i + 1, stateBufferSize)) state = player.stateBuffer[i], player.controlKeys = state.controlKeys, player.yaw = state.yaw, state.jump && player.jump(), player.update(state.delta, true), player.stateBuffer[i].x = player.x, player.stateBuffer[i].y = player.y, player.stateBuffer[i].z = player.z, player.stateBuffer[i].dx = player.dx, player.stateBuffer[i].dy = player.dy, player.stateBuffer[i].dz = player.dz, player.stateBuffer[i].jumping = player.jumping;
                    var dist = Math.length3(player.x - oldx, player.y - oldy, player.z - oldz);
                    dist < .2 ? (.02 < dist && (player.corrections = FramesBetweenSyncs, player.corrected.dx = player.x - oldx, player.corrected.dy = player.y - oldy, player.corrected.dz = player.z - oldz), player.x = oldx, player.y = oldy, player.z = oldz, player.dx = olddx, player.dy = olddy, player.dz = olddz) : player.corrections = 0, player.jumping = wasJumping, player.climbing = wasClimbing, wasJumping && (player.corrected.dy = 0, player.y = oldy, player.dy = olddy), player.yaw = oldYaw, player.pitch = oldPitch, player.controlKeys = oldKeys
                } else {
                    for (var i = player.stateIdx = 0; i < FramesBetweenSyncs; i++) player.stateBuffer[i].controlKeys = input.unPackInt8U(), player.stateBuffer[i].yaw = input.unPackRadU(), player.stateBuffer[i].pitch = input.unPackRad();
                    player.x = x, player.jumping || (player.y = y), player.z = z, player.climbing = climbing
                }
                break;
            case CommCode.fire:
                var id = input.unPackInt8U();
                tv1.x = input.unPackFloat(), tv1.y = input.unPackFloat(), tv1.z = input.unPackFloat(), tv2.x = input.unPackFloat(), tv2.y = input.unPackFloat(), tv2.z = input.unPackFloat();
                var seed = input.unPackInt8U(),
                    player = players[id];
                if (!player) break;
                id != meId && player.weapon.actor.fire(), mathSeed = seed, player.weapon.fireMunitions(tv1, tv2);
                break;
            case CommCode.throwGrenade:
                var id = input.unPackInt8U(),
                    x = input.unPackFloat(),
                    y = input.unPackFloat(),
                    z = input.unPackFloat(),
                    dx = input.unPackFloat(),
                    dy = input.unPackFloat(),
                    dz = input.unPackFloat(),
                    player = players[id];
                if (!player) break;
                player.grenadeCount--, id != meId ? (player.actor.head.rotation.x = player.pitch, player.actor.mesh.rotation.y = player.yaw) : updateAmmoUi(), player.actor.throwGrenade(), munitionsManager.throwGrenade(player, {
                    x: x,
                    y: y,
                    z: z
                }, {
                    x: dx,
                    y: dy,
                    z: dz
                });
                break;
            case CommCode.reload:
                var id = input.unPackInt8U();
                players[id] && players[id].reload();
                break;
            case CommCode.swapWeapon:
                var id = input.unPackInt8U(),
                    weaponIdx = input.unPackInt8U();
                players[id] && players[id].swapWeapon(weaponIdx);
                break;
            case CommCode.hitMe:
                var hp = input.unPackInt8U(),
                    dx = input.unPackFloat(),
                    dz = input.unPackFloat();
                me.hp = hp, me.actor.hit(), hitIndicator.hit(dx, dz);
                break;
            case CommCode.hitThem:
                var id = input.unPackInt8U(),
                    hp = input.unPackInt8U(),
                    player = players[id];
                if (!player) break;
                player.hp = hp, player.actor.hit(), 0 < hp && shellFragBurst(player, 30, .07, 20);
                break;
            case CommCode.respawn:
                var id = input.unPackInt8U(),
                    x = input.unPackFloat(),
                    y = input.unPackFloat(),
                    z = input.unPackFloat(),
                    player = players[id];
                player && (player.respawn(x, y, z), id == meId && console.log("CommCode.respawn received from server for this player"));
                break;
            case CommCode.changeCharacter:
                var id = input.unPackInt8U(),
                    classIdx = input.unPackInt8U(),
                    primaryWeaponIdx = input.unPackInt8U(),
                    secondaryWeaponIdx = input.unPackInt8U(),
                    shellColor = input.unPackInt8U(),
                    hatIdx = input.unPackInt8U(),
                    stampIdx = input.unPackInt8U(),
                    primaryWeaponItem = catalog.findItemBy8BitItemId(ItemType.Primary, classIdx, primaryWeaponIdx),
                    secondaryWeaponItem = catalog.findItemBy8BitItemId(ItemType.Secondary, classIdx, secondaryWeaponIdx),
                    hatItem = catalog.findItemBy8BitItemId(ItemType.Hat, classIdx, hatIdx),
                    stampItem = catalog.findItemBy8BitItemId(ItemType.Stamp, classIdx, stampIdx),
                    player = players[id];
                player && player.changeCharacter(classIdx, primaryWeaponItem, secondaryWeaponItem, shellColor, hatItem, stampItem);
                break;
            case CommCode.switchTeam:
                var id = input.unPackInt8U(),
                    toTeam = input.unPackInt8U(),
                    player = players[id];
                if (player) {
                    player.team = toTeam, player.score = 0, player.kills = 0, player.streak = 0, player.bestGameStreak = 0, id == meId && (myTeam = toTeam, setTeamButton());
                    for (var i = 0; i < playerLimit; i++)(player = players[i]) && player.actor && player.actor.updateTeam();
                    rebuildPlayerList()
                }
                break;
            case CommCode.switchTeamFail:
                openAlertDialog(getLocText("ui_game_fairteams_header"), getLocText("ui_game_fairteams_text"), {
                    label: "OK",
                    width: "8em"
                });
                break;
            case CommCode.ping:
                ping = Date.now() - pingStartTime, pingTotal += ping, pingSamples++;
                var el = document.getElementById("ping");
                ping < 100 ? el.style.color = "#0f0" : ping < 150 ? el.style.color = "#ff0" : ping < 200 ? el.style.color = "#f90" : el.style.color = "#f00", el.innerText = ping + "ms", setTimeout(function () {
                    var output = new Comm.output(1);
                    output.packInt8(CommCode.ping), pingStartTime = Date.now(), ws && ws.send(output.buffer)
                }, 1e3);
                break;
            case CommCode.notification:
                notify(input.unPackString(), 1e3 * input.unPackInt8U());
                break;
            case CommCode.gameLocked:
                notify(getLocText("ui_game_locked"), 1e4);
                break;
            case CommCode.updateBalance:
                var newBalance = input.unPackInt32U();
                console.log("updating balance from server: " + newBalance), playerAccount.currentBalance = newBalance, updateCurrentBalance();
                break;
            case CommCode.expireUpgrade:
                console.log("upgrade has expired"), checkUpgrade();
                break;
            default:
                console.log("CommCode error: " + cmd + "/" + String.fromCharCode(cmd) + " - previous cmd: " + JSON.stringify(prevCmd))
        }
        prevCmd.push(cmd), 4 < prevCmd.length && prevCmd.shift()
    }
};

//   ___   _ _____ _   _    ___   ___ 
//  / __| /_\_   _/_\ | |  / _ \ / __|
// | (__ / _ \| |/ _ \| |_| (_) | (_ |
//  \___/_/ \_\_/_/ \_\____\___/ \___|
// [LS] ######## Catalog ---------------------------------

// [LS] Catalog CONSTRUCTOR
var catalog = new function () {
    if (null == Items) throw "Items is undefined or null, cannot create Catalog";
    this.isSetup = false, this.filterItems = function (itemList, filterFunc) {
        for (var filteredItems = [], i = 0; i < itemList.length; i++) filterFunc(itemList[i]) && filteredItems.push(itemList[i]);
        return filteredItems
    }, this.findItemInListById = function (itemId, itemList) {
        for (var i = 0; i < itemList.length; i++)
            if (itemList[i] && itemList[i].id === itemId) return itemList[i];
        return null
    }, this.findItemById = function (itemId) {
        return this.findItemInListById(itemId, Items)
    }, this.findItemBy8BitItemId = function (itemType, classIdx, itemId8Bit) {
        if (false === this.isSetup && this.setupCatalog(), void 0 === classIdx || classIdx >= CharClass.length) return null;
        var realItemId = itemId8Bit;
        switch (itemType) {
            case ItemType.Hat:
                return 0 === itemId8Bit ? null : (realItemId += 999, this.findItemInListById(realItemId, this.hats));
            case ItemType.Stamp:
                return 0 === itemId8Bit ? null : (realItemId += 1999, this.findItemInListById(realItemId, this.stamps));
            case ItemType.Primary:
                switch (realItemId += 3e3, classIdx) {
                    case CharClass.Soldier:
                        realItemId += 100;
                        break;
                    case CharClass.Scrambler:
                        realItemId += 600;
                        break;
                    case CharClass.Ranger:
                        realItemId += 400;
                        break;
                    case CharClass.Eggsploder:
                        realItemId += 800
                }
                return this.findItemInListById(realItemId, this.forClass[classIdx].forWeaponSlot[Slot.Primary]);
            case ItemType.Secondary:
                return realItemId += 3e3, this.findItemInListById(realItemId, this.forClass[classIdx].forWeaponSlot[Slot.Secondary])
        }
    }, this.get8BitItemId = function (item, classIdx) {
        if (null === item) return 0;
        false === this.isSetup && this.setupCatalog();
        var itemId8Bit = item.id;
        switch (item.item_type_id) {
            case ItemType.Hat:
                itemId8Bit -= 999;
                break;
            case ItemType.Stamp:
                itemId8Bit -= 1999;
                break;
            case ItemType.Primary:
                switch (itemId8Bit -= 3e3, classIdx) {
                    case CharClass.Soldier:
                        itemId8Bit -= 100;
                        break;
                    case CharClass.Scrambler:
                        itemId8Bit -= 600;
                        break;
                    case CharClass.Ranger:
                        itemId8Bit -= 400;
                        break;
                    case CharClass.Eggsploder:
                        itemId8Bit -= 800
                }
                break;
            case ItemType.Secondary:
                itemId8Bit -= 3e3
        }
        return itemId8Bit
    }, this.addWeaponFunctions = function (weaponItem) {
        weaponItem.instantiateNew = function (avatar) {
            const ItemClass = item_classes[this.item_data.class];
            var instance = new ItemClass(avatar, this.item_data.meshName);
            return avatar.actor && avatar.actor.setWeaponSkeleton(instance.actor.skeleton), instance
        }
    }, this.getTaggedItems = function (tag) {
        return this.filterItems(Items, function (item) {
            if (void 0 !== item.item_data.tags && null !== item.item_data.tags && 0 < item.item_data.tags.length)
                for (var i = 0; i < item.item_data.tags.length; i++)
                    if (item.item_data.tags[i] === tag) return true;
            return false
        })
    }, this.setupCatalog = function () {
        this.hats = [], this.stamps = [], this.primaryWeapons = [], this.secondaryWeapons = [], this.forClass = [];
        for (var i = 0; i < Items.length; i++) switch (Items[i].item_type_id) {
            case ItemType.Hat:
                this.hats.push(Items[i]);
                break;
            case ItemType.Stamp:
                this.stamps.push(Items[i]);
                break;
            case ItemType.Primary:
                this.primaryWeapons.push(Items[i]), this.addWeaponFunctions(Items[i]);
                break;
            case ItemType.Secondary:
                this.secondaryWeapons.push(Items[i]), this.addWeaponFunctions(Items[i])
        }
        for (var cIdx = 0; cIdx < CharClass.length; cIdx++) {
            var isFreeSharedFunc = function (item) {
                return 0 === item.price && null === item.exclusive_for_class
            },
                isFreeClassExclusiveFunc = function (item) {
                    return 0 === item.price && item.exclusive_for_class === cIdx
                },
                isPaidSharedFunc = function (item) {
                    return 0 < item.price && null === item.exclusive_for_class
                },
                isPaidClassExclusiveFunc = function (item) {
                    return 0 < item.price && item.exclusive_for_class === cIdx
                },
                outer = this,
                createClassWeaponListFunc = function (itemList) {
                    return itemList = outer.filterItems(itemList, isFreeSharedFunc).concat(outer.filterItems(itemList, isFreeClassExclusiveFunc)).concat(outer.filterItems(itemList, isPaidSharedFunc)).concat(outer.filterItems(itemList, isPaidClassExclusiveFunc))
                },
                classItems = {
                    primaryWeapons: createClassWeaponListFunc(this.primaryWeapons),
                    secondaryWeapons: createClassWeaponListFunc(this.secondaryWeapons)
                };
            classItems.forWeaponSlot = [classItems.primaryWeapons, classItems.secondaryWeapons], this.forClass.push(classItems)
        }
        this.isSetup = true
    }, false === this.isSetup && this.setupCatalog()
};


// [LS] Customizer CONSTRUCTOR
function Customizer(callback) {
    this.isReady = false, this.camX = 0, this.camY = .4, this.camRadius = 3.4, this.rotY = 0, this.rotX = 0, this.jump = 0, this.turnCountdown = 60, this.selectedItem = 0, this.buyingItem = null, this.currentPickedItem = null, this.currentRenderFunc = null, this.currentHighlightFunc = null, this.currentSelectByIndexFunc = null, this.currentSelectByItemFunc = null, this.setupScene(), this.setupItems(), this.setupWeaponStats();
    var outer = this;
    loadResources(this.scene, function () {
        outer.onResourcesLoaded(), outer.isReady = true, callback && callback()
    })
}
Customizer.prototype.onResourcesLoaded = function () {
    var outer = this;
    console.log("customizer created, starting renderering"), this.startRendering();
    try {
        var meshName = playerAccount.getPrimaryWeapon().item_data.meshName;
        this.avatar = new function (c) {
            this.scene = outer.scene, this.id = -1, this.name = "", this.x = 0, this.y = 0, this.z = 0, this.hp = 100, this.hatItem = playerAccount.hatItem, this.stampItem = playerAccount.stampItem, this.shellColor = playerAccount.colorIdx, this.actor = new PlayerActor(this), this.actor.mesh.rotation.y = outer.rotY, this.weapon = new classes[c].weapon(this, meshName), this.weapon.actor.equip()
        }(playerAccount.classIdx), console.log("avatar created: " + this.avatar);
        var lastNow = Date.now();
        this.scene.registerBeforeRender(function () {
            var now = Date.now(),
                delta = now - lastNow;
            lastNow = now, delta /= 17, outer.update(delta)
        })
    } catch (e) {
        console.log(e)
    }
};
Customizer.prototype.startRendering = function () {
    var outer = this;
    engine.runRenderLoop(function () {
        outer.scene.render()
    })
};
Customizer.prototype.update = function (delta) {
    if (this.avatar.actor.handsToWeaponSkeleton(), this.camera.target.x += (this.camX - this.camera.target.x) / 5, this.camera.target.y += (this.camY - this.camera.target.y) / 5, this.camera.radius += (this.camRadius - this.camera.radius) / 5, this.avatar.actor.head.rotation.x += (this.rotX - this.avatar.actor.head.rotation.x) / 5, this.avatar.actor.mesh.rotation.y += (this.rotY - this.avatar.actor.mesh.rotation.y) / 5, this.avatar.actor.mesh.rotation.x = .5 * this.avatar.actor.head.rotation.x, this.avatar.actor.mesh.position.x = .1 * -this.avatar.actor.mesh.rotation.y, this.avatar.actor.mesh.position.y += delta * this.jump, this.jump -= .002 * delta, this.avatar.actor.mesh.position.y = Math.max(0, this.avatar.actor.mesh.position.y + this.jump * delta), this.turnCountdown -= delta, this.turnCountdown <= 0) {
        var rx = .6 * Math.random() - .4,
            ry = 2 * Math.random() - 1 + .5 * this.camX,
            d = Math.length2(rx - this.rotX, ry - this.rotY);
        this.rotX = rx, this.rotY = ry, this.jump = Math.min(.01, d / 100), this.turnCountdown = 90 * Math.random() + 30
    }
};
Customizer.prototype.open = function () {
    menuIn("customizationMenu"), document.getElementById("customizeButton").style.display = "none", document.getElementById("customizerBackButton").style.display = "inline", document.getElementById("customizerClassSelectorContainer").appendChild(document.getElementById("classSelector")), document.getElementById("redeemCodeButton").style.display = playerAccount.session ? "inline" : "none", this.camX = .39, this.camY = .3, this.camRadius = 3.4, this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.initHatButton(), this.initStampButton()
};
Customizer.prototype.openToItem = function (item) {
    switch (item.item_type_id) {
        case ItemType.Primary:
            this.openWeaponSelectorToItem(Slot.Primary, item);
            break;
        case ItemType.Secondary:
            this.openWeaponSelectorToItem(Slot.Secondary, item);
            break;
        case ItemType.Hat:
            this.openHatSelectorToItem(item);
            break;
        case ItemType.Stamp:
            this.openStampSelectorToItem(item)
    }
    this.currentSelectByItemFunc(item), item.poseEgg()
};
Customizer.prototype.openToTaggedItems = function (tag) {
    var taggedItems = catalog.getTaggedItems(tag);
    this.openItemSelector("Items: " + tag, taggedItems, null, null, false, false)
};
Customizer.prototype.close = function () {
    playerAccount.syncToServer();
    menuOut("customizationMenu"), document.getElementById("customizerBackButton").style.display = "none", document.getElementById("redeemCodeButton").style.display = "none", document.getElementById("customizeButton").style.display = "inline", document.getElementById("mainMenuClassSelectorContainer").appendChild(document.getElementById("classSelector")), inGame ? (engine.stopRenderLoop(), startRendering(), me.changeCharacter(playerAccount.classIdx, playerAccount.getPrimaryWeapon(), playerAccount.getSecondaryWeapon(), playerAccount.colorIdx, playerAccount.hatItem, playerAccount.stampItem, 0, 0), chatting && chatInEl.focus(), showBannerAdWithPlaceholder("multisizeBannerAdPlaceholder"), loadBannerAd()) : menuIn("mainMenu", function () {
        showBannerAd(), loadBannerAd()
    }), this.camX = 0, this.camY = .4, this.camRadius = 3.4
};
Customizer.prototype.updatePageArrows = function () {
    document.getElementById("itemPageLeft").style.visibility = 0 < this.page ? "visible" : "hidden", document.getElementById("itemPageRight").style.visibility = this.page < this.numItems / this.pageSize - 1 ? "visible" : "hidden";
    var str = "Page " + (this.page + 1) + "/" + Math.ceil(this.numItems / this.pageSize);
    document.getElementById("itemPageCount").innerText = str
};
Customizer.prototype.flipPage = function (dir) {
    this.page += dir, this.currentRenderFunc(), this.updatePageArrows()
};
Customizer.prototype.iteratePage = function (callbackPerItem) {
    for (var start = this.page * this.pageSize, end = Math.min(start + this.pageSize, this.numItems), i = start, b = 0; i < end; i++, b++) callbackPerItem(i, b)
};
Customizer.prototype.renderEmptyButton = function () {
    var i = document.getElementById("noItemImg");
    document.getElementById("item0").getContext("2d").drawImage(i, 0, 0)
};
Customizer.prototype.clearItemButtons = function () {
    for (var i = 0; i < this.pageSize; i++) {
        document.getElementById("item" + i).getContext("2d").clearRect(0, 0, 256, 256)
    }
    this.clearItemLocks()
};
Customizer.prototype.clearItemLocks = function () {
    for (var i = 0; i < this.pageSize; i++) this.setItemLocked(i, false, 0), this.setItemRequiresPhysicalUnlock(i, false)
};
Customizer.prototype.clearHighlight = function () {
    for (var i = 0; i < this.pageSize; i++) document.getElementById("item" + i).className = "itemButton"
};
Customizer.prototype.highlightSelectedIndex = function (listIndex) {
    var start = this.page * this.pageSize,
        end = start + this.pageSize;
    start <= listIndex && listIndex < end && (pageIndex = listIndex % this.pageSize, document.getElementById("item" + pageIndex).className = "itemButtonSelected")
};
Customizer.prototype.isItemPickable = function (item) {
    var requiresPhysicalPurchase = this.doesItemRequirePhysicalUnlock(item);
    return 0 === item.price && !requiresPhysicalPurchase || playerAccount.inventory.includes(item)
};
Customizer.prototype.doesItemRequirePhysicalUnlock = function (item) {
    return void 0 !== item.item_data.unlock && null !== item.item_data.unlock && "physical" === item.item_data.unlock
};
Customizer.prototype.setItemLocked = function (displayIdx, locked, price) {
    document.getElementById("lockedItem" + displayIdx).style.visibility = locked ? "visible" : "hidden", document.getElementById("lockedItemCost" + displayIdx).innerText = price
};
Customizer.prototype.setItemRequiresPhysicalUnlock = function (displayIdx, requiresPhysicalPurchase) {
    document.getElementById("lockedItemPhysical" + displayIdx).style.visibility = requiresPhysicalPurchase ? "visible" : "hidden"
};
Customizer.prototype.boughtItem = function () {
    this.currentPickedItem = this.buyingItem;
    this.currentPickedItem.pick();
    this.currentPickedItem.poseEgg();
    this.buyingItem = null;
    this.currentRenderFunc(this.currentPickedItem);
    menuOut("buyItem");
    menuFlexIn("itemSelectorGrid");
    menuIn("itemSelectorBackButton");
};
Customizer.prototype.buyItemBack = function () {
    null !== this.currentPickedItem ? this.currentPickedItem.poseEgg() : this.buyingItem.takeOffItem(), this.buyingItem = null, this.currentHighlightFunc(), menuOut("buyItem"), menuOut("getMoreEggsLoozer"), menuFlexIn("itemSelectorGrid"), menuIn("itemSelectorBackButton")
};
Customizer.prototype.physicalUnlockBack = function () {
    this.buyItemBack(), menuOut("physicalUnlock")
};
Customizer.prototype.pickColor = function (idx) {
    if (this.avatar && (playerAccount.isUpgraded() || !(7 < idx))) {
        playerAccount.colorIdx = idx;
        for (var ci = 0; ci < shellColors.length; ci++) {
            var colorSelector = document.getElementById("color" + ci);
            ci === playerAccount.colorIdx ? colorSelector.classList.add("selectedColor") : colorSelector.classList.remove("selectedColor")
        }
        this.avatar.actor.setShellColor(playerAccount.colorIdx)
    }
};
Customizer.prototype.pickNextClass = function (dir) {
    var classIdx = Math.mod(playerAccount.classIdx + dir, CharClass.length);
    this.pickClass(classIdx)
};
Customizer.prototype.pickClass = function (classIdx) {
    playerAccount.setClass(classIdx);
    var primaryWeaponItem = playerAccount.getPrimaryWeapon();
    this.poseWithWeapon(primaryWeaponItem), this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.updateWeaponStatsUI()
};
Customizer.prototype.updateWeaponStatsUI = function () {
    if (this.avatar)
        for (var key in document.getElementById("className").innerText = classes[playerAccount.classIdx].name, document.getElementById("classWeapon").innerText = this.avatar.weapon.subClass.weaponName, weaponStats) {
            var pct = (this.avatar.weapon.subClass[key] + weaponStats[key].min) / (weaponStats[key].max - Math.abs(weaponStats[key].min));
            pct = 5.6 - 5.5 * pct, document.getElementById(weaponStats[key].name).style.borderRight = pct + "em solid var(--egg-brown)"
        }
};
Customizer.prototype.dressUpEgg = function () {
    null != playerAccount && void 0 !== this.avatar && null !== this.avatar && (this.pickClass(playerAccount.classIdx), this.poseWithWeapon(playerAccount.getPrimaryWeapon()), this.poseWithHat(playerAccount.hatItem), this.poseWithStamp(playerAccount.stampItem), this.pickColor(playerAccount.colorIdx))
};
Customizer.prototype.initWeaponButton = function (slot) {
    var currentPickedWeaponItem = playerAccount.getPickedWeaponInSlot(slot),
        canvasId = slot === Slot.Primary ? "primarySelectorButton" : "secondarySelectorButton",
        c = document.getElementById(canvasId);
        devlog(currentPickedWeaponItem);
    itemRenderer.renderToCanvas(currentPickedWeaponItem.item_data.meshName, c, this.weaponCam[slot])
};
Customizer.prototype.openWeaponSelector = function (slot) {
    this.openWeaponSelectorToItem(slot, playerAccount.getPickedWeaponInSlot(slot))
};
Customizer.prototype.openWeaponSelectorToItem = function (slot, weaponItem) {
    var weaponList = catalog.forClass[playerAccount.classIdx].forWeaponSlot[slot],
        title = slot === Slot.Primary ? "Primary Weapons" : "Secondary Weapons";
    this.openItemSelector(title, weaponList, weaponItem, false, true)
};
Customizer.prototype.poseWithWeapon = function (weaponItem) {
    this.avatar && (this.avatar.weapon && this.avatar.weapon.actor.dispose(), this.avatar.weapon = weaponItem.instantiateNew(this.avatar), this.avatar.weapon.actor.equip(), this.initWeaponButton(0), this.initWeaponButton(1))
};
Customizer.prototype.initHatButton = function () {
    var c = document.getElementById("hatSelectorButton");
    if (null !== playerAccount.hatItem) itemRenderer.renderToCanvas(playerAccount.hatItem.item_data.meshName, c, this.hatCam);
    else {
        var i = document.getElementById("noHatImg"),
            ctx = c.getContext("2d");
        ctx.clearRect(0, 0, 256, 256), ctx.drawImage(i, 0, 0)
    }
};
Customizer.prototype.openHatSelector = function () {
    this.openHatSelectorToItem(playerAccount.hatItem)
};
Customizer.prototype.openHatSelectorToItem = function (hatItem) {
    this.openItemSelector("Hats", catalog.hats, hatItem, true, true)
};
Customizer.prototype.poseWithHat = function (hatItem) {
    null === hatItem ? this.avatar.actor.removeHat() : this.avatar.actor.wearHat(hatItem)
};
Customizer.prototype.initStampButton = function () {
    var c = document.getElementById("stampSelectorButton");
    if (null !== playerAccount.stampItem) itemRenderer.renderStampToCanvas(playerAccount.stampItem, c);
    else {
        var i = document.getElementById("noStampImg"),
            ctx = c.getContext("2d");
        ctx.clearRect(0, 0, 256, 256), ctx.drawImage(i, 0, 0)
    }
};
Customizer.prototype.openStampSelector = function () {
    this.openStampSelectorToItem(playerAccount.stampItem)
};
Customizer.prototype.openStampSelectorToItem = function (stampItem) {
    this.openItemSelector("Stamps", catalog.stamps, stampItem, true, true)
};
Customizer.prototype.poseWithStamp = function (stampItem) {
    null === stampItem ? this.avatar.actor.removeStamp() : this.avatar.actor.applyStamp(stampItem)
};
Customizer.prototype.openItemSelector = function (title, itemList, item, firstItemBlank, highlightSelected) {
    if (playerAccount.isLoggedIn) {
        this.camX = .6, this.camY = .35, this.pageSize = 9;
        var uiItems = this.filterItemsForUI(itemList),
            blankFirstItemShim = true === firstItemBlank ? 1 : 0;
        this.numItems = uiItems.length + blankFirstItemShim;
        var itemIdx = 0;
        null !== item && null === (itemIdx = this.getItemIndex(item, uiItems)) && (itemIdx = 0), highlightSelected && playerAccount.isItemEquipped(item) && (this.currentPickedItem = item), this.page = Math.floor(itemIdx / this.pageSize), this.currentRenderFunc = this.encloseRenderPageFunc(uiItems, firstItemBlank, highlightSelected), this.currentHighlightFunc = this.encloseHighlightFunc(uiItems, firstItemBlank, highlightSelected), this.currentSelectByIndexFunc = this.encloseSelectByIndexFunc(uiItems, firstItemBlank, highlightSelected), this.currentSelectByItemFunc = this.encloseSelectByItemFunc(uiItems, firstItemBlank, highlightSelected), this.currentRenderFunc(), this.currentHighlightFunc(), this.updatePageArrows(), document.getElementById("itemSelectorHeader").innerText = title, menuOut("customizationMenu"), menuIn("itemSelectorMenu")
    } else promoteLogin()
};
Customizer.prototype.encloseRenderPageFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function () {
        outer.clearItemButtons(), outer.iteratePage(function (i, b) {
            if (true === firstItemBlank && 0 === i) outer.renderEmptyButton(), outer.setItemLocked(0, false, 0), outer.setItemRequiresPhysicalUnlock(0, false);
            else {
                var renderingItem = itemList[true === firstItemBlank ? i - 1 : i],
                    canvas = document.getElementById("item" + b);
                renderingItem.renderToCanvas(canvas);
                var locked = !outer.isItemPickable(renderingItem),
                    requiresPhysicalUnlock = outer.doesItemRequirePhysicalUnlock(renderingItem);
                outer.setItemRequiresPhysicalUnlock(b, locked && requiresPhysicalUnlock), outer.setItemLocked(b, locked && !requiresPhysicalUnlock, renderingItem.price)
            }
        }), outer.currentHighlightFunc()
    }
};
Customizer.prototype.encloseHighlightFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function () {
        outer.clearHighlight(), false !== highlightSelected && outer.iteratePage(function (i, b) {
            if (true === firstItemBlank && 0 === i) null === outer.currentPickedItem && outer.highlightSelectedIndex(0);
            else {
                var item = itemList[true === firstItemBlank ? i - 1 : i];
                null !== outer.currentPickedItem && item.id === outer.currentPickedItem.id && outer.highlightSelectedIndex(i)
            }
        })
    }
};
Customizer.prototype.encloseSelectByIndexFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function (displayIndex) {
        var listIndex = displayIndex;
        true === firstItemBlank && listIndex--;
        var noItem = true === firstItemBlank && 0 === displayIndex,
            item = noItem ? null : itemList[listIndex];
        true === noItem || outer.isItemPickable(item) ? (true === highlightSelected && outer.highlightSelectedIndex(displayIndex), true === noItem ? (outer.currentPickedItem.takeOffItem(), outer.currentPickedItem = null) : (item.pick(), item.poseEgg())) : (console.log("here, item: " + item.id), item.select(), item.poseEgg(), this.buyingItem = item, outer.itemSelected(item))
    }
};
Customizer.prototype.encloseSelectByItemFunc = function (itemList, firstItemBlank) {
    return function (item) {
        var itemIdx = this.getItemIndex(item, itemList);
        true === firstItemBlank && itemIdx++, this.currentSelectByIndexFunc(itemIdx)
    }
};
Customizer.prototype.itemSelected = function (item) {
    (menuOut("itemSelectorGrid"), menuOut("itemSelectorBackButton"), this.doesItemRequirePhysicalUnlock(item)) ? (menuFlexIn("physicalUnlock"), document.getElementById("physicalUnlockText").innerText = void 0 !== item.item_data.physicalUnlockText ? item.item_data.physicalUnlockText : "Buy a REAL THING to unlock this item!", document.getElementById("physicalUnlockButton").onclick = function () {
        return customizer.openPhysicalItemStoreDialog(), false
    }) : playerAccount.currentBalance >= item.price ? (menuFlexIn("buyItem"), document.getElementById("buyItemText").innerText = item.price, document.getElementById("buyItemButton").onclick = function () {
        return extern.buyItem(item.id), false
    }) : (menuFlexIn("getMoreEggsLoozer"), document.getElementById("moreEggsPrice").innerText = item.price)
};
Customizer.prototype.getItemIndex = function (item, itemList) {
    if (null === item) return null;
    for (var i = 0; i < itemList.length; i++)
        if (item.id === itemList[i].id) return i;
    return null
};
Customizer.prototype.selectItem = function (pageIndex) {
    listIndex = pageIndex + this.page * this.pageSize, listIndex < this.numItems && (this.clearHighlight(), this.currentSelectByIndexFunc(listIndex))
};
Customizer.prototype.closeItemSelector = function () {
    menuOut("itemSelectorMenu");
    var primaryWeapon = playerAccount.getPickedWeaponInSlot(Slot.Primary);
    this.poseWithWeapon(primaryWeapon), this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.initHatButton(), this.initStampButton(), this.open()
};
Customizer.prototype.filterItemsForUI = function (itemList) {
    for (var uiItems = [], i = 0; i < itemList.length; i++) true === itemList[i].showInUI && uiItems.push(itemList[i]);
    return uiItems
};
Customizer.prototype.setupItems = function () {
    this.extendStampItems(), this.extendHatItems();
    for (var cIdx = 0; cIdx < CharClass.length; cIdx++) this.extendWeaponItems(cIdx, Slot.Primary), this.extendWeaponItems(cIdx, Slot.Secondary)
};
Customizer.prototype.extendItems = function (itemList, renderItemToCanvasFunc, poseEggWithItemFunc, selectItemFunc, takeOffItemFunc, pickItemFunc) {
    for (var i = 0; i < itemList.length; i++) {
        var showInUI = true === itemList[i].is_available || true === playerAccount.isItemOwned(itemList[i]);
        itemList[i].showInUI = showInUI, itemList[i].renderToCanvas = renderItemToCanvasFunc, itemList[i].poseEgg = poseEggWithItemFunc, itemList[i].select = selectItemFunc, itemList[i].takeOffItem = takeOffItemFunc, itemList[i].pick = pickItemFunc
    }
};
Customizer.prototype.extendWeaponItems = function (classIdx, slot) {
    var outer = this,
        weaponList = catalog.forClass[classIdx].forWeaponSlot[slot],
        poseEggWithWeaponFunc = function () {
            outer.poseWithWeapon(this)
        };
    this.extendItems(weaponList, function (canvas) {
        itemRenderer.renderToCanvas(this.item_data.meshName, canvas, outer.weaponCam[slot])
    }, poseEggWithWeaponFunc, function () {
        outer.currentPickedItem = playerAccount.getPickedWeaponInSlot(slot)
    }, function () {
        poseEggWithWeaponFunc(this.currentPickedItem)
    }, function () {
        void 0 !== this.exclusive_for_class && null !== this.exclusive_for_class && this.exclusive_for_class !== playerAccount.classIdx && outer.pickClass(this.exclusive_for_class), playerAccount.pickWeapon(slot, this), outer.initWeaponButton(slot)
    })
};
Customizer.prototype.extendHatItems = function () {
    var outer = this;
    this.extendItems(catalog.hats, function (canvas) {
        itemRenderer.renderToCanvas(this.item_data.meshName, canvas, outer.hatCam)
    }, function () {
        outer.poseWithHat(this)
    }, function () {
        outer.currentPickedItem = playerAccount.hatItem
    }, function () {
        playerAccount.hatItem = null, outer.poseWithHat(null)
    }, function () {
        outer.currentPickedItem = this, playerAccount.hatItem = this, outer.initHatButton()
    })
};
Customizer.prototype.extendStampItems = function () {
    var outer = this;
    this.extendItems(catalog.stamps, function (canvas) {
        itemRenderer.renderStampToCanvas(this, canvas)
    }, function () {
        outer.poseWithStamp(this)
    }, function () {
        outer.currentPickedItem = playerAccount.stampItem
    }, function () {
        playerAccount.stampItem = null, outer.poseWithStamp(null)
    }, function () {
        outer.currentPickedItem = this, playerAccount.stampItem = this, outer.initStampButton()
    })
};
Customizer.prototype.setupScene = function () {
    this.scene = new BABYLON.Scene(engine), this.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2, this.scene.fogDensity = .06;
    var skyColor = new BABYLON.Color3(.35, .65, .8);
    this.scene.fogColor = skyColor, this.scene.clearColor = skyColor;
    var topLight = new BABYLON.DirectionalLight("", new BABYLON.Vector3(0, -1, 0), this.scene);
    topLight.intensity = 1;
    var hemLight = new BABYLON.HemisphericLight("", new BABYLON.Vector3(.25, 1, -.5), this.scene);
    hemLight.intensity = .8, (hemLight = new BABYLON.HemisphericLight("", new BABYLON.Vector3(0, -1, 0), this.scene)).intensity = .5, hemLight.diffuse = new BABYLON.Color3(.6, .8, 1), (shadowGen = new BABYLON.ShadowGenerator(1024, topLight)).useBlurExponentialShadowMap = true, shadowGen.frustumEdgeFalloff = 1, shadowGen.blurScale = 2, shadowGen.blurBoxOffset = 1, this.camera = new BABYLON.ArcRotateCamera("", .5 * Math.PI, 1.5, this.camRadius, new BABYLON.Vector3(this.camX, this.camY, 0), this.scene), this.scene.activeCameras.push(this.camera), this.camera.maxZ = 100, this.camera.fov = .5, this.camera.minZ = .1;
    var groundMat = new BABYLON.StandardMaterial("groundMat", this.scene);
    groundMat.diffuseColor = new BABYLON.Color3(.35, .5, .6), groundMat.specularColor = BABYLON.Color3.Black();
    var ground = BABYLON.Mesh.CreatePlane("ground", 100, this.scene);
    ground.rotation.x = Math.PI / 2, ground.receiveShadows = true, ground.material = groundMat, this.scene.render();
    for (var i = 0; i < shellColors.length; i++) document.getElementById("color" + i).style.background = shellColors[i];
    stampTexture = new BABYLON.Texture("img/stamps.png?v=" + version, this.scene), this.weaponCam = [{
        alpha: 0,
        radius: 1.3,
        primaryGun: true
    }, {
        alpha: 0,
        radius: 1,
        secondaryGun: true
    }], this.hatCam = {
        alpha: 0,
        radius: 1.3
    }
};
Customizer.prototype.setExtraColorState = function (available) {
    for (var pickColorClosure = function (colorIdx) {
        return function () {
            extern.customizer.pickColor(colorIdx)
        }
    }, i = 7; i < shellColors.length; i++) {
        var colorSwatch = document.getElementById("color" + i);
        true === available ? (colorSwatch.onclick = pickColorClosure(i), colorSwatch.classList.remove("lockedColor")) : (colorSwatch.onclick = extern.openBuyPassDialog, colorSwatch.classList.add("lockedColor"))
    }
};
Customizer.prototype.setupWeaponStats = function () {
    var setupWeaponStatsInList = function (weaponList) {
        for (var i = 0; i < weaponList.length; i++) {
            var weapon = item_classes[weaponList[i].item_data.class];
            for (var key in weaponStats) weaponStats[key].flip ? (weaponStats[key].max = Math.max(weaponStats[key].max, -weapon[key]), weaponStats[key].min = Math.min(weaponStats[key].min, -weapon[key])) : (weaponStats[key].max = Math.max(weaponStats[key].max, weapon[key]), weaponStats[key].min = 0)
        }
    };
    setupWeaponStatsInList(catalog.primaryWeapons), setupWeaponStatsInList(catalog.secondaryWeapons)
};

// [LS] ######## Collider ---------------------------------

var Collider = {
    init: function (scene) {
        Collider.playerCollisionMesh = BABYLON.MeshBuilder.CreateBox("pc", {
            size: .5,
            height: .6
        }, scene), Collider.playerCollisionMesh.position.y = .3, Collider.playerCollisionMesh.bakeCurrentTransformIntoVertices(), Collider.playerCollisionMesh.setEnabled(false), Collider.wedgeCollisionMesh = BABYLON.MeshBuilder.CreateBox("", {
            size: 1.5
        }, scene), Collider.wedgeCollisionMesh.position.y = -.75, Collider.wedgeCollisionMesh.bakeCurrentTransformIntoVertices(), Collider.wedgeCollisionMesh.rotation.x = -Math.PI / 4, Collider.wedgeCollisionMesh.bakeTransformIntoVertices(Collider.wedgeCollisionMesh.getWorldMatrix()), Collider.wedgeCollisionMesh.setEnabled(false), Collider.iwedgeCollisionMesh = BABYLON.MeshBuilder.CreateBox("", {
            size: 1.5
        }, scene), Collider.iwedgeCollisionMesh.position.y = .75, Collider.iwedgeCollisionMesh.bakeCurrentTransformIntoVertices(), Collider.iwedgeCollisionMesh.rotation.x = -Math.PI / 4, Collider.iwedgeCollisionMesh.bakeTransformIntoVertices(Collider.iwedgeCollisionMesh.getWorldMatrix()), Collider.iwedgeCollisionMesh.setEnabled(false), Collider.fullCollisionMesh = BABYLON.MeshBuilder.CreateBox("", {
            size: 1
        }, scene), Collider.fullCollisionMesh.setEnabled(false), Collider.pointCollisionMesh = BABYLON.MeshBuilder.CreateBox("", {
            size: .01
        }, scene), Collider.pointCollisionMesh.setEnabled(false)
    },
    v1: new BABYLON.Vector3,
    v2: new BABYLON.Vector3,
    v3: new BABYLON.Vector3,
    v4: new BABYLON.Vector3,
    ray: new BABYLON.Ray(BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), 1),
    matrix: new BABYLON.Matrix,
    pointCollidesWithMap: function (point, ignoreSoft) {
        if (isNaN(point.x) || isNaN(point.y) || isNaN(point.z)) return false;
        var cx = Math.floor(point.x),
            cy = Math.floor(point.y),
            cz = Math.floor(point.z);
        return !(cx < 0 || cx >= map.width || cz < 0 || cz >= map.depth || cy < 0 || cy >= map.height) && Collider.meshCollidesWithCell(Collider.pointCollisionMesh, point, cx, cy, cz, ignoreSoft)
    },
    playerCollidesWithMap: function (player) {
        return Collider.meshCollidesWithMap(Collider.playerCollisionMesh, player)
    },
    meshCollidesWithMap: function (mesh, pos) {
        var cellsChecked = {};
        if (isNaN(pos.x) || isNaN(pos.y) || isNaN(pos.z)) return true;
        for (var bbox = mesh.getBoundingInfo().boundingBox, i = 0; i < bbox.vectors.length; i++) {
            var cx = Math.floor(pos.x + bbox.vectors[i].x),
                cy = Math.floor(pos.y + bbox.vectors[i].y),
                cz = Math.floor(pos.z + bbox.vectors[i].z);
            if (cx < 0 || cx >= map.width || cz < 0 || cz >= map.depth || cy < 0) return true;
            var checkId = cx + 1e3 * cy + 1e6 * cz;
            if (cy < map.height && !cellsChecked[checkId]) {
                var res = Collider.meshCollidesWithCell(mesh, pos, cx, cy, cz);
                if (res) return res;
                cellsChecked[checkId] = true
            }
        }
        return false
    },
    meshCollidesWithCell: function (mesh, pos, cx, cy, cz, ignoreSoft) {
        var cell = map.data[cx][cy][cz];
        if (cell.idx) {
            var mapMesh = mapMeshes[cell.idx];
            if (ignoreSoft && mapMesh.softness) return false;
            switch (mapMesh.colliderType) {
                case "full":
                    return {
                        x: cx, y: cy, z: cz, cell: cell, mesh: Collider.fullCollisionMesh
                    };
                case "ladder":
                    if ("pc" != mesh.name) return false;
                    break;
                case "none":
                    return false
            }
            mesh.position.x = pos.x - cx - .5, mesh.position.y = pos.y - cy - .5, mesh.position.z = pos.z - cz - .5, mesh.setPivotPoint(new BABYLON.Vector3(-mesh.position.x, -mesh.position.y, -mesh.position.z)), mesh.rotation.x = -cell.rx, mesh.rotation.y = -cell.ry, mesh.rotation.z = -cell.rz, mesh.computeWorldMatrix();
            var m = cell.colliderMesh.intersectsMesh(mesh, cell.colliderPrecise, cell.colliderChildren);
            if (m) return {
                x: cx,
                y: cy,
                z: cz,
                cell: cell,
                mesh: m
            }
        }
        return false
    },
    rayCollidesWithMap: function (origin, direction, callback) {
        if (isNaN(origin.x) || isNaN(origin.y) || isNaN(origin.z)) return false;
        if (origin.x < 0 || origin.x >= map.width || origin.z < 0 || origin.z >= map.depth || origin.y < 0 || origin.y >= map.height) return false;
        var radius = direction.length(),
            x = Math.floor(origin.x),
            y = Math.floor(origin.y),
            z = Math.floor(origin.z),
            dx = direction.x,
            dy = direction.y,
            dz = direction.z,
            stepX = Math.sign(dx),
            stepY = Math.sign(dy),
            stepZ = Math.sign(dz),
            tMaxX = Collider.intbound(origin.x, dx),
            tMaxY = Collider.intbound(origin.y, dy),
            tMaxZ = Collider.intbound(origin.z, dz),
            tDeltaX = stepX / dx,
            tDeltaY = stepY / dy,
            tDeltaZ = stepZ / dz;
        if (0 === dx && 0 === dy && 0 === dz) return false;
        for (radius /= Math.sqrt(dx * dx + dy * dy + dz * dz);
            (0 < stepX ? x < map.width : 0 <= x) && (0 < stepY ? y < map.height : 0 <= y) && (0 < stepZ ? z < map.depth : 0 <= z);) {
            if (!(x < 0 || y < 0 || z < 0 || x >= map.width || y >= map.height || z >= map.depth)) {
                var res = callback(origin, direction, {
                    x: x,
                    y: y,
                    z: z
                });
                if (res && "verysoft" != mapMeshes[res.cell.idx].softness) return res
            }
            if (tMaxX < tMaxY)
                if (tMaxX < tMaxZ) {
                    if (radius < tMaxX) break;
                    x += stepX, tMaxX += tDeltaX
                } else {
                    if (radius < tMaxZ) break;
                    z += stepZ, tMaxZ += tDeltaZ
                }
            else if (tMaxY < tMaxZ) {
                if (radius < tMaxY) break;
                y += stepY, tMaxY += tDeltaY
            } else {
                if (radius < tMaxZ) break;
                z += stepZ, tMaxZ += tDeltaZ
            }
        }
    },
    intbound: function (s, ds) {
        return ds < 0 ? Collider.intbound(-s, -ds) : (1 - (s = (s % 1 + 1) % 1)) / ds
    },
    getCellForRay: function (voxel) {
        try {
            var cell = map.data[voxel.x][voxel.y][voxel.z]
        } catch (e) {
            console.log(voxel)
        }
        if (!cell || !cell.mesh) return false;
        switch (cell.mesh.colliderType) {
            case "none":
            case "ladder":
                return false
        }
        return cell
    },
    projectileCollidesWithCell: function (origin, direction, voxel) {
        var cell = Collider.getCellForRay(voxel);
        if (!cell) return false;
        if (cell.mesh.softness) return false;
        colliderMesh = cell.colliderMesh, Collider.matrix.copyFrom(cell.colliderMatrix), Collider.v4.set(voxel.x + .5, voxel.y + .5, voxel.z + .5), Collider.v1.set(origin.x, origin.y, origin.z), Collider.v2.copyFrom(direction), Collider.v1.subtractInPlace(Collider.v4), Collider.ray.origin.copyFrom(Collider.v1), Collider.ray.direction.copyFrom(Collider.v2), Collider.ray.length = 1, BABYLON.Ray.TransformToRef(Collider.ray, Collider.matrix, Collider.ray);
        var pickInfo = Collider.intersectsColliderMesh(colliderMesh, false);
        if (colliderMesh = pickInfo.pickedMesh, pickInfo.hit) {
            if (colliderMesh != Collider.fullCollisionMesh && (.5 < Math.abs(pickInfo.pickedPoint.x) || .5 < Math.abs(pickInfo.pickedPoint.y) || .5 < Math.abs(pickInfo.pickedPoint.z))) {
                var to0 = BABYLON.Vector3.DistanceSquared(Collider.ray.origin, BABYLON.Vector3.Zero());
                BABYLON.Vector3.DistanceSquared(Collider.ray.origin, pickInfo.pickedPoint) < to0 && (pickInfo = Collider.ray.intersectsMesh(Collider.fullCollisionMesh, false))
            }
            if (pickInfo.hit) {
                var p = BABYLON.Vector3.TransformCoordinates(pickInfo.pickedPoint, Collider.matrix.invert());
                return p.addInPlace(Collider.v4), pickInfo.pickedPoint = p, {
                    cell: cell,
                    pick: pickInfo
                }
            }
        }
        return false
    },
    grenadeCollidesWithCell: function (origin, direction, voxel, ignoreSoft) {
        var cell = Collider.getCellForRay(voxel);
        if (!cell) return false;
        colliderMesh = cell.colliderMesh, Collider.matrix.copyFrom(cell.colliderMatrix), Collider.v4.set(voxel.x + .5, voxel.y + .5, voxel.z + .5), Collider.v1.set(origin.x, origin.y, origin.z), Collider.v2.copyFrom(direction);
        var velocity = direction.length();
        Collider.v2.normalize().scaleInPlace(10), Collider.v1.subtractInPlace(Collider.v4), Collider.ray.origin.copyFrom(Collider.v1), Collider.ray.direction.copyFrom(Collider.v2), Collider.ray.length = 1, BABYLON.Ray.TransformToRef(Collider.ray, Collider.matrix, Collider.ray);
        var pickInfo = Collider.intersectsColliderMesh(colliderMesh, false);
        if (colliderMesh = pickInfo.pickedMesh, pickInfo.hit) {
            if (BABYLON.Vector3.Distance(Collider.ray.origin, pickInfo.pickedPoint) <= velocity) return Collider.matrix.invert(), (p = BABYLON.Vector3.TransformCoordinates(pickInfo.pickedPoint, Collider.matrix)).addInPlace(Collider.v4), pickInfo.pickedPoint = p, {
                cell: cell,
                pick: pickInfo,
                normal: normal = BABYLON.Vector3.TransformCoordinates(pickInfo.normal, Collider.matrix),
                dot: BABYLON.Vector3.Dot(direction, normal)
            };
            if (!pickInfo.insideMesh) return false;
            var normal = pickInfo.normal;
            if ((pickInfo = Collider.ray.intersectsMesh(Collider.fullCollisionMesh, false)).hit) {
                var p;
                Collider.matrix.invert(), (p = BABYLON.Vector3.TransformCoordinates(pickInfo.pickedPoint, Collider.matrix)).addInPlace(Collider.v4), pickInfo.pickedPoint = p;
                normal = pickInfo.getNormal(true, false);
                return {
                    cell: cell,
                    pick: pickInfo,
                    normal: normal = BABYLON.Vector3.TransformCoordinates(normal, Collider.matrix),
                    dot: BABYLON.Vector3.Dot(direction, normal)
                }
            }
        }
        return false
    },
    intersectsColliderMesh: function (colliderMesh, precise) {
        var closestDistance = 1e5,
            closestPick = Collider.ray.intersectsMesh(colliderMesh, precise),
            closestNormal = null,
            insideMesh = false;
        closestPick.hit && (closestNormal = closestPick.getNormal(true, false), 0 < (dot = BABYLON.Vector3.Dot(Collider.ray.direction, closestNormal)) && (insideMesh = true), closestDistance = BABYLON.Vector3.DistanceSquared(Collider.ray.origin, closestPick.pickedPoint));
        for (var children = colliderMesh.getChildMeshes(), i = 0; i < children.length; i++) {
            var pickInfo = Collider.ray.intersectsMesh(children[i], precise);
            if (pickInfo.hit) {
                var dot, distance = BABYLON.Vector3.DistanceSquared(Collider.ray.origin, pickInfo.pickedPoint),
                    normal = pickInfo.getNormal(true, false);
                0 < (dot = BABYLON.Vector3.Dot(Collider.ray.direction, normal)) && (insideMesh = true), distance < closestDistance && (closestDistance = distance, closestPick = pickInfo, closestNormal = normal, 0 < dot && (insideMesh = true))
            }
        }
        return closestPick.normal = closestNormal, closestPick.insideMesh = insideMesh, closestPick
    },
    rayCollidesWithPlayer: function (origin, direction, proj) { //same as modern code!
        for (var fromTeam = proj ? proj.player.team : null, fromId = proj ? proj.player.id : null, i = 0; i < playerLimit; i++) {
            var player = players[i];
            if (player && player.playing && player.id != fromId && (0 == player.team || player.team != fromTeam)) {
                Collider.ray.origin.copyFrom(origin), Collider.ray.direction.copyFrom(direction), Collider.ray.length = 1;
                var point = Collider.rayCollidesWithPlayerHelper(Collider.ray, player);
                if (point) return proj && proj.collidesWithPlayer(player, point), point
            }
        }
        return false
    },
    rayCollidesWithPlayerHelper: function (ray, player) {
        var p = Collider.v2,
            d = Collider.v3,
            c = Collider.v4,
            m = Collider.v1;
        p.copyFrom(ray.origin), d.copyFrom(ray.direction), c.set(player.x, player.y + .32, player.z), p.subtractToRef(c, m);
        var b = BABYLON.Vector3.Dot(m, d);
        if (0 < (c = BABYLON.Vector3.Dot(m, m) - .140625) && 0 < b) return false;
        var discr = b * b - c;
        if (discr < 0) return false;
        var t = -b - Math.sqrt(discr);
        return t < 0 && (t = 0), d.scaleInPlace(t), p.addInPlace(d), p
    }
};

//    _   ___ _____ ___  ___  ___ 
//   /_\ / __|_   _/ _ \| _ \/ __|
//  / _ \ (__  | || (_) |   /\__ \
// /_/ \_\___| |_| \___/|_|_\|___/
// [LS] ######## Actor Constructors ---------------------------------


// [LS] PlayerActor CONSTRUCTOR
function PlayerActor(player) {
    this.player = player, this.scene = player.scene, this.mesh = new BABYLON.TransformNode, this.hat = null;
    player.hatItem, player.stampItem;
    this.bodyMesh = this.scene.cloneMesh("egg", this.mesh), this.bodyMesh.position.y = .32, this.bodyMesh.player = this.player, this.bodyMesh.material = this.scene.getMaterialByName("eggShell"), this.bodyMesh.material.setTexture("textureSampler", stampTexture), this.head = new BABYLON.TransformNode, this.head.parent = this.mesh, this.head.position.y = .3, this.head.position.z = 0, this.gunContainer = new BABYLON.TransformNode, this.gunContainer.parent = this.head, this.gunContainer.rotation.y = -.14, this.gunContainer.rotation.x = -.035, this.setupStowAnims(), this.eye = new BABYLON.TransformNode, this.eye.position.y = .1, this.eye.position.x = 0, this.eye.parent = this.head, this.hands = this.scene.cloneMesh("hands", this.gunContainer), console.log(this.hands), this.hands.skeleton = this.scene.cloneSkeleton("hands_skeleton"), this.hands.material = this.scene.getMaterialByName("standard"), this.gripBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("gripHand")], this.foreBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("foreHand")], this.bodyMesh.overlayColor = BABYLON.Color3.Green(), this.hands.overlayColor = BABYLON.Color3.Green(), 0 < this.player.shield && (this.bodyMesh.renderOverlay = true, this.hands.renderOverlay = true), this.setShellColor(this.player.shellColor), shake = 0, shadowGen && shadowGen.getShadowMap().renderList.push(this.bodyMesh), inGame ? (this.player.id == meId ? this.hands.setRenderingGroupId(1) : (this.setupNameSprite(), this.showNameSprite()), inGame && this.updateTeam()) : (this.bodyMesh.outlineColor = teamColors.outline[0].clone(), this.bodyMesh.outlineColor.a = 0), this.mesh.position.x = this.player.x, this.mesh.position.y = this.player.y, this.mesh.position.z = this.player.z, this.deathSound = Sounds.shellBurst.clone(), this.player.id == meId ? this.hitSound = Sounds.hit.clone() : (this.wearHat(this.player.hatItem), this.applyStamp(this.player.stampItem), this.hitSound = this.bodyMesh.attachSound(Sounds.hit)), /* playOffline && this.hands.setEnabled(false), */ this.bobbleIntensity = 0, this.scope = false, this.zoomed = false, this.hitSoundDelay = 0
};
PlayerActor.prototype.wearHat = function (hatItem) {
    this.removeHat(), null !== hatItem && (this.hat = this.scene.cloneMesh(hatItem.item_data.meshName, this.bodyMesh), this.hat.position.y = -.02)
};
PlayerActor.prototype.removeHat = function () {
    void 0 !== this.hat && null !== this.hat && this.hat.dispose()
};
PlayerActor.prototype.applyStamp = function (stampItem) {
    this.removeStamp(), null !== stampItem && (this.bodyMesh.stampU = stampItem.item_data.x / 16, this.bodyMesh.stampV = 1 - stampItem.item_data.y / 16)
};
PlayerActor.prototype.removeStamp = function () {
    this.bodyMesh.stampU = 0, this.bodyMesh.stampV = 1
};
PlayerActor.prototype.drawTextOnNameTexture = function (text, x, y, size, color, center) {
    var shadowCoords = [{
        x: 0,
        y: -4
    }, {
        x: -4,
        y: 0
    }, {
        x: 4,
        y: 0
    }, {
        x: 0,
        y: 4
    }],
        coords = [{
            x: 0,
            y: -1
        }, {
            x: -1,
            y: 0
        }, {
            x: 1,
            y: 0
        }, {
            x: 0,
            y: 1
        }];
    x += this.player.id % 4 * 512, y = -y + (2048 - 256 * Math.floor(this.player.id / 4)), center && (x += 256 - function (name, size) {
        var context = nameTestCanvas.getContext("2d");
        return context.font = "bold " + size + "px Nunito, sans-serif", context.measureText(name).width
    }(text, size) / 2);
    for (var i = 0; i < 4; i++) nameTexture.drawText(text, x + shadowCoords[i].x, y + shadowCoords[i].y, "bold " + size + "px Nunito, sans-serif", "rgba(0, 0, 0, 0.5)", "transparent");
    for (i = 0; i < 4; i++) nameTexture.drawText(text, x + coords[i].x, y + coords[i].y, "bold " + size + "px Nunito, sans-serif", color, "transparent")
};
PlayerActor.prototype.setupNameSprite = function () {
    var tx = this.player.id % 4 * 512,
        ty = 2048 - 256 * Math.floor(this.player.id / 4);
    nameTexture.clearRect(tx, ty - 256, 512, 256), this.drawTextOnNameTexture(this.player.name, 0, 32, 60, "white", true)
};
PlayerActor.prototype.updateTeam = function () {
    this.player.id == meId || (0 < this.player.team ? (this.player.team == myTeam ? this.bodyMesh.outlineColor = teamColors.outline[this.player.team].clone() : this.bodyMesh.outlineColor.a = 0, this.nameSprite && (this.nameSprite.width = .6, this.nameSprite.height = .3, this.nameSprite.color = teamColors.outline[this.player.team])) : this.bodyMesh.outlineColor.a = 0)
};
PlayerActor.prototype.update = function (delta) {
    var bcos = Math.cos(this.player.bobble) * this.bobbleIntensity,
        bsina = Math.abs(Math.sin(this.player.bobble) * this.bobbleIntensity),
        bsin = Math.sin(2 * this.player.bobble) * this.bobbleIntensity;
    if (0 < this.player.shield) {
        var alpha = .7 * Math.random() + .2;
        this.bodyMesh.overlayAlpha = alpha, this.hands.overlayAlpha = alpha
    }
    if (this.player.id == meId) this.scope && this.player.isAtReady(true) ? (camera.fov = camera.fov + (this.player.weapon.actor.scopeFov - camera.fov) / 3, this.gunContainer.rotation.y *= .667, this.gunContainer.rotation.x *= .667, this.gunContainer.position.x += (-.25 - this.gunContainer.position.x) / 3, this.gunContainer.position.y += (this.player.weapon.actor.scopeY - this.gunContainer.position.y) / 4, this.gunContainer.position.z += (-.05 - this.gunContainer.position.z) / 3, this.player.weapon.hasScope && !this.zoomed && camera.fov < this.player.weapon.actor.scopeFov + .05 && (scope.show(), this.gunContainer.setEnabled(false), this.zoomed = true)) : (camera.fov = camera.fov + (1.25 - camera.fov) / 3, this.gunContainer.rotation.y += (2 * bcos - .14 - this.gunContainer.rotation.y) / 3, this.gunContainer.rotation.x += (.75 * bsin - .035 - this.gunContainer.rotation.x) / 3, this.gunContainer.position.x *= .667, this.gunContainer.position.y *= .667, this.gunContainer.position.z *= .667, this.zoomed && camera.fov > this.player.weapon.actor.scopeFov + .05 && (scope.hide(), this.gunContainer.setEnabled(true), this.zoomed = false));
    else if (this.gunContainer.rotation.y += (2 * bcos - .14 - this.gunContainer.rotation.y) / 3, this.gunContainer.rotation.x += (.75 * bsin - .035 - this.gunContainer.rotation.x) / 3, 0 < this.player.team && this.player.team == myTeam && this.nameSprite) {
        var dist = Math.length3(this.player.x - me.x, this.player.y - me.y, this.player.z - me.z),
            fac = Math.pow(dist, 1.25);
        this.nameSprite.width = fac / 10 + .6, this.nameSprite.height = fac / 20 + .3
    }
    var dx = this.player.x - this.mesh.position.x,
        dy = this.player.y - this.mesh.position.y,
        dz = this.player.z - this.mesh.position.z;
    dist = Math.length3(dx, dy, dz);
    this.player.id == meId ? (this.mesh.position.x += dx / 2, this.mesh.position.y += dy / 2, this.mesh.position.z += dz / 2) : (this.mesh.position.x += dx / 6, this.mesh.position.y += dy / 2, this.mesh.position.z += dz / 6);
    var bobbleTarget;
    Math.radDifference(this.player.yaw, this.mesh.rotation.y), Math.radDifference(this.player.pitch, this.head.rotation.x);
    if (this.mesh.rotation.y = this.player.yaw, this.head.rotation.x = this.player.pitch, this.bodyMesh.rotation.x = this.head.rotation.x / 4, bobbleTarget = this.player.jumping ? 0 : Math.length3(this.player.dx, this.player.dy, this.player.dz), this.bobbleIntensity += (bobbleTarget - this.bobbleIntensity) / 10, this.bodyMesh.rotation.z = 5 * bcos, this.bodyMesh.position.y = 1.5 * bsina + .32, 0 < shake)
        if ((shake *= .9) < .001) shake = 0;
        else {
            var x = Math.random() * shake - .5 * shake,
                y = Math.random() * shake - .5 * shake,
                z = Math.random() * shake - .5 * shake;
            this.eye.rotation.x += (x - this.eye.rotation.x) / 10, this.eye.rotation.y += (y - this.eye.rotation.y) / 10, this.eye.rotation.z += (z - this.eye.rotation.z) / 10
        }
    else this.eye.rotation.x *= .9, this.eye.rotation.y *= .9, this.eye.rotation.z *= .9;
    if (this.player.id != meId) {
        var visible = isMeshVisible(this.mesh, .31);
        this.mesh.setVisible(visible), visible ? this.showNameSprite() : this.hideNameSprite(), this.nameSprite && this.positionNameSprite()
    }
    this.hitSoundDelay = Math.max(this.hitSoundDelay - delta, 0)
};
PlayerActor.prototype.positionNameSprite = function () {
  if (this.nameSprite) {
    var mp = this.mesh.position.clone();
    mp.y += 0.5 * this.nameSprite.height + 0.65;
    var v = new BABYLON.Vector3(
      camera.globalPosition.x - mp.x,
      camera.globalPosition.y - mp.y,
      camera.globalPosition.z - mp.z
    ).normalize();
    v.scaleInPlace(0.4), v.addInPlace(mp), (this.nameSprite.position = v);
  }
};
PlayerActor.prototype.showNameSprite = function () {
    this.player.playing && !this.nameSprite && (this.nameSprite = new BABYLON.Sprite("", nameSprites), this.nameSprite.invertV = true, this.nameSprite.width = .6, this.nameSprite.height = .3, this.nameSprite.cellIndex = this.player.id, this.nameSprite.color = teamColors.outline[this.player.team])
};
PlayerActor.prototype.hideNameSprite = function () {
    this.nameSprite && (this.nameSprite.dispose(), this.nameSprite = null)
};
PlayerActor.prototype.scopeIn = function () {
    this.scope = true
};
PlayerActor.prototype.scopeOut = function () {
    this.scope = false
};
PlayerActor.prototype.hit = function () {
    this.hitSoundDelay <= 0 && (this.hitSound.play(), this.hitSoundDelay = 10)
};
PlayerActor.prototype.removeFromPlay = function () {
    devlog("removeFromPlay");
    this.scope = false, this.zoomed = false, this.throwingGrenade = false, this.gripBone._frozen = false, this.mesh.setEnabled(false), this.hideNameSprite()
    // if (playOffline) this.mesh.setEnabled(true);
};
PlayerActor.prototype.restoreToPlay = function () {
    devlog("restoreToPlay");
    this.mesh.setEnabled(true), this.gunContainer.setEnabled(true), this.player.id != meId && this.showNameSprite()
    // if (playOffline) this.mesh.setEnabled(true);
};
PlayerActor.prototype.remove = function () {
    this.mesh.disposeOfSounds(), this.mesh.dispose(), this.hideNameSprite()
};
PlayerActor.prototype.fire = function () {
    this.zoomed && this.player.weapon.hasScope && (shake = .25, this.eye.rotation.x = -.1)
};
PlayerActor.prototype.reachForGrenade = function () {
    var that = this;
    this.throwingGrenade = true, this.gripBone._frozen = true, this.hands.skeleton.enableBlending(.2), this.hands.skeleton.beginAnimation("grenade_grab", false, 1, function () {
        that.hands.skeleton && that.hands.skeleton.disableBlending()
    })
};
PlayerActor.prototype.throwGrenade = function () {
    var that = this;
    this.player.id == meId && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden"), this.hands.skeleton.beginAnimation("grenade_throw", false, 1, function () {
        that.hands.skeleton && (that.throwingGrenade = false, that.gripBone._frozen = false)
    })
};
PlayerActor.prototype.setShellColor = function (colorIdx) {
    (colorIdx < 0 || colorIdx >= shellColors.length) && (console.log("Shell color out of bounds: " + colorIdx), colorIdx = 0);
    var color = BABYLON.Color3.FromHexString(shellColors[colorIdx]);
    this.bodyMesh.colorMult = color, this.hands.colorMult = color
};
PlayerActor.prototype.setWeaponSkeleton = function (skeleton) {
    this.skeleton = skeleton, this.weaponGripBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("gripHand")], this.weaponForeBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("foreHand")]
};
PlayerActor.prototype.handsToWeaponSkeleton = function () {
    this.gripBone.position = this.weaponGripBone.position, this.gripBone.setRotationQuaternion(this.weaponGripBone.rotationQuaternion), 1 != this.throwingGrenade && (this.foreBone.position = this.weaponForeBone.position, this.foreBone.setRotationQuaternion(this.weaponForeBone.rotationQuaternion))
};
PlayerActor.prototype.setupStowAnims = function () {
    var gunRotationAnimation = new BABYLON.Animation("", "rotation", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunScaleAnimation = new BABYLON.Animation("", "scaling", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunPositionAnimation = new BABYLON.Animation("", "position", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunRotationEase = new BABYLON.CubicEase;
    gunRotationEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunRotationAnimation.setEasingFunction(gunRotationEase);
    var gunScaleEase = new BABYLON.CubicEase;
    gunScaleEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunScaleAnimation.setEasingFunction(gunScaleEase);
    var gunPositionEase = new BABYLON.CubicEase;
    gunPositionEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunPositionAnimation.setEasingFunction(gunPositionEase);
    var gunRotationKeys = [{
        frame: 0,
        value: new BABYLON.Vector3(-.035, -.14, 0)
    }, {
        frame: 25,
        value: new BABYLON.Vector3(1, -1.5, 0)
    }, {
        frame: 30,
        value: new BABYLON.Vector3(-1, -1.5, 0)
    }, {
        frame: 55,
        value: new BABYLON.Vector3(-.035, -.14, 0)
    }],
        gunScaleKeys = [{
            frame: 0,
            value: new BABYLON.Vector3(1, 1, 1)
        }, {
            frame: 25,
            value: new BABYLON.Vector3(.25, .25, .25)
        }, {
            frame: 30,
            value: new BABYLON.Vector3(.25, .25, .25)
        }, {
            frame: 55,
            value: new BABYLON.Vector3(1, 1, 1)
        }],
        gunPositionKeys = [{
            frame: 0,
            value: new BABYLON.Vector3(0, 0, 0)
        }, {
            frame: 25,
            value: new BABYLON.Vector3(.1, .1, -.2)
        }, {
            frame: 30,
            value: new BABYLON.Vector3(.1, 0, -.2)
        }, {
            frame: 55,
            value: new BABYLON.Vector3(0, 0, 0)
        }];
    gunRotationAnimation.setKeys(gunRotationKeys), gunScaleAnimation.setKeys(gunScaleKeys), gunPositionAnimation.setKeys(gunPositionKeys), this.gunContainer.animations.push(gunRotationAnimation), this.gunContainer.animations.push(gunScaleAnimation), this.gunContainer.animations.push(gunPositionAnimation)
};

// [LS] GrenadeActor CONSTRUCTOR
function GrenadeActor(grenade, scene) {
    this.grenade = grenade, this.scene = grenade.scene, this.mesh = this.scene.cloneMesh("grenade"), this.mesh.setEnabled(false), this.explodeSound = Sounds.grenade.explode.clone(), this.pinSound = this.mesh.attachSound(Sounds.grenade.pin), this.beepSound = this.mesh.attachSound(Sounds.grenade.beep), this.beep = false, this.flashColor = null
}
GrenadeActor.prototype.throw = function () {
    this.mesh.setEnabled(true), this.mesh.position.x = this.grenade.x, this.mesh.position.y = this.grenade.y, this.mesh.position.z = this.grenade.z, this.grenade.player.id == meId ? this.flashColor = flashColors[0] : this.flashColor = flashColors[this.grenade.player.team], this.pinSound.play(), this.bounce()
};
GrenadeActor.prototype.update = function () {
    this.mesh.position.x = this.grenade.x, this.mesh.position.y = this.grenade.y, this.mesh.position.z = this.grenade.z, this.mesh.rotation.x += this.rx, this.mesh.rotation.y += this.ry, this.mesh.rotation.z += this.rz, 1 < Math.sqrt(this.grenade.ttl) % 2 ? (0 == this.beep && (this.beepSound.play(), this.beep = true), this.mesh.emissiveColor = this.flashColor) : (this.mesh.emissiveColor = BABYLON.Color3.Black(), this.beep = false)
};
GrenadeActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};
GrenadeActor.prototype.bounce = function () {
    var s = Math.length3(this.grenade.dx, this.grenade.dy, this.grenade.dz);
    this.rx = (2 * Math.random() - 1) * s, this.ry = (2 * Math.random() - 1) * s, this.rz = (2 * Math.random() - 1) * s
};
GrenadeActor.prototype.stop = function () {
    this.rx = 0, this.ry = 0, this.rz = 0
};

// [LS] BulletActor CONSTRUCTOR
function BulletActor(bullet) {
    this.scene = bullet.scene, this.bullet = bullet, this.delayFrames = 0, this.mesh = this.scene.getMeshByName("bullet").createInstance(""), this.mesh.setEnabled(false)
}
BulletActor.prototype.fire = function () {
    this.bullet.player.id == meId ? this.delayFrames = Math.ceil(ping / 17) + 5 : this.delayFrames = 5, this.mesh.position.x = this.bullet.x, this.mesh.position.y = this.bullet.y, this.mesh.position.z = this.bullet.z, this.mesh.lookAt(new BABYLON.Vector3(this.bullet.x + this.bullet.dx, this.bullet.y + this.bullet.dy, this.bullet.z + this.bullet.dz)), this.mesh.rotation.x += .015, this.mesh.rotation.y -= .015, this.mesh.scaling.z = .5
};
BulletActor.prototype.update = function () {
    --this.delayFrames <= 0 && this.mesh.setEnabled(true), this.mesh.position.x = this.bullet.x, this.mesh.position.y = this.bullet.y, this.mesh.position.z = this.bullet.z, this.bullet.player.id != meId && (this.mesh.scaling.z = Math.min(this.mesh.scaling.z + .03, 3))
};
BulletActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] RocketActor CONSTRUCTOR
function RocketActor(rocket) {
    this.rocket = rocket, this.scene = rocket.scene, this.armed = false, this.delayFrames = 0, this.mesh = this.scene.getMeshByName("rocket").createInstance(""), this.mesh.setEnabled(false), this.explodeSound = Sounds.rpegg.explode.clone(), this.poofSound = Sounds.rpegg.poof.clone(), this.flySound = this.mesh.attachSound(Sounds.rpegg.fly)
}
RocketActor.prototype.fire = function () {
    this.armed = false, this.rocket.player.id == meId ? this.delayFrames = Math.ceil(ping / 17) + 3 : this.delayFrames = 3, this.mesh.position.x = this.rocket.x, this.mesh.position.y = this.rocket.y, this.mesh.position.z = this.rocket.z, this.mesh.lookAt(new BABYLON.Vector3(this.rocket.x + this.rocket.dx, this.rocket.y + this.rocket.dy, this.rocket.z + this.rocket.dz)), this.mesh.rotation.x += .015, this.mesh.rotation.y -= .015
};
RocketActor.prototype.update = function () {
    if (--this.delayFrames <= 0 && this.mesh.setEnabled(true), !this.armed && this.rocket.ttArmed <= 0 && (this.armed = true, this.flySound.play()), this.delayFrames % 4 == 0) {
        var dx = .04 * Math.random() - .02,
            dy = .04 * Math.random() - .02,
            dz = .04 * Math.random() - .02;
        this.rocket.ttArmed <= 0 && (addExplosionSprite(explosionSmokeManager, 10, this.rocket.x, this.rocket.y, this.rocket.z, dx, dy, dz, .4), addExplosionSprite(explosionFireManager, 10, this.rocket.x, this.rocket.y, this.rocket.z, dx, dy, dz, .4))
    }
    this.mesh.position.x = this.rocket.x, this.mesh.position.y = this.rocket.y, this.mesh.position.z = this.rocket.z
};
RocketActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] GunActor CONSTRUCTOR
function GunActor(gun, meshName) {
    this.gun = gun, this.meshName = meshName, this.scene = gun.scene, this.standardMeshName = gun.subClass.standardMeshName, this.playerActor = gun.player.actor, this.skeleton = this.scene.cloneSkeleton("gun_" + this.standardMeshName + "_skeleton")
};
GunActor.prototype.setup = function (muzFlashZ) {
    this.gunMesh = this.scene.cloneMesh(this.meshName, this.playerActor.gunContainer), this.gunMesh.skeleton = this.skeleton, this.gunMesh.setEnabled(false), muzFlashZ && (this.muzzleFlash = this.scene.cloneMesh("muzzleFlash", this.playerActor.gunContainer), this.muzzleFlash.setEnabled(false), this.muzzleFlash.parent = this.playerActor.gunContainer, this.muzzleFlash.position.x = .25, this.muzzleFlash.position.z = muzFlashZ), this.gun.player.id == meId && (this.gunMesh.setRenderingGroupId(1), this.muzzleFlash && this.muzzleFlash.setRenderingGroupId(1))
};
GunActor.prototype.addSoundEvent = function (animation, frame, sound) {
    frame += this.skeleton.getAnimationRange(animation).from;
    var event = new BABYLON.AnimationEvent(frame, function () {
        sound.play()
    });
    this.skeleton.bones[0].animations[0].addEvent(event)
};
GunActor.prototype.dispose = function () {
    this.gunMesh.dispose()
};
GunActor.prototype.stow = function () {
    var that = this;
    this.scene.beginAnimation(this.playerActor.gunContainer, 0, 25, false, 1, function () {
        that.gunMesh.setEnabled(false), that.gun.equip()
    })
};
GunActor.prototype.equip = function () {
    this.gunMesh.setEnabled(true), this.playerActor.setWeaponSkeleton(this.skeleton), this.scene.beginAnimation(this.playerActor.gunContainer, 30, 55, false, 1)
};
GunActor.prototype.dryFire = function () {
    this.dryFireSound.play()
};
GunActor.prototype.denyFire = function () {
    reticle.fireDenied(), this.dryFireSound.play(), this.denyFireSound.play()
};
GunActor.prototype.fire = function () {
    if (this.fireSound && this.fireSound.play(), this.muzzleFlash) {
        this.muzzleFlash.rotation.z = 3.141 * Math.random(), this.muzzleFlash.setEnabled(true);
        var that = this;
        setTimeout(function () {
            that.muzzleFlash.setEnabled(false)
        }, 40)
    }
    this.skeleton.beginAnimation("fire")
};
GunActor.prototype.reload = function () {
    this.gun.longReloadTime == this.gun.shortReloadTime ? this.skeleton.beginAnimation("reload") : 0 < this.gun.ammo.rounds ? this.skeleton.beginAnimation("shortReload") : this.skeleton.beginAnimation("longReload")
};
GunActor.prototype.update = function () { };

// [LS] Eggk47Actor CONSTRUCTOR
function Eggk47Actor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = .9, this.scopeY = .0438, this.setup(.6), this.fireSound = this.gunMesh.attachSound(Sounds.eggk47.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var removeMag = this.gunMesh.attachSound(Sounds.eggk47.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.eggk47.insertMag),
        cycle = this.gunMesh.attachSound(Sounds.eggk47.cycle);
    this.addSoundEvent("shortReload", 40, removeMag), this.addSoundEvent("shortReload", 130, insertMag), this.addSoundEvent("longReload", 40, removeMag), this.addSoundEvent("longReload", 130, insertMag), this.addSoundEvent("longReload", 155, cycle)
};
(Eggk47Actor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] DozenGaugeActor CONSTRUCTOR
function DozenGaugeActor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = 1, this.scopeY = .072, this.setup(.6), this.fireSound = this.gunMesh.attachSound(Sounds.dozenGauge.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var open = this.gunMesh.attachSound(Sounds.dozenGauge.open),
        load = this.gunMesh.attachSound(Sounds.dozenGauge.load),
        close = this.gunMesh.attachSound(Sounds.dozenGauge.close);
    this.addSoundEvent("reload", 0, open), this.addSoundEvent("reload", 80, load), this.addSoundEvent("reload", 115, close)
};
(DozenGaugeActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] CSG1Actor CONSTRUCTOR
function CSG1Actor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = .5, this.scopeY = .0345, this.setup(.6), this.fireSound = this.gunMesh.attachSound(Sounds.csg1.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var removeMag = this.gunMesh.attachSound(Sounds.eggk47.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.eggk47.insertMag),
        pullAction = this.gunMesh.attachSound(Sounds.csg1.pullAction),
        releaseAction = this.gunMesh.attachSound(Sounds.csg1.releaseAction);
    this.addSoundEvent("shortReload", 30, removeMag), this.addSoundEvent("shortReload", 120, insertMag), this.addSoundEvent("longReload", 30, pullAction), this.addSoundEvent("longReload", 75, removeMag), this.addSoundEvent("longReload", 165, insertMag), this.addSoundEvent("longReload", 200, releaseAction)
};
(CSG1Actor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] Cluck9mmActor CONSTRUCTOR
function Cluck9mmActor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = 1.1, this.scopeY = .069, this.setup(.48), this.fireSound = this.gunMesh.attachSound(Sounds.cluck9mm.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var removeMag = this.gunMesh.attachSound(Sounds.cluck9mm.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.cluck9mm.insertMag),
        cycle = this.gunMesh.attachSound(Sounds.eggk47.cycle);
    this.addSoundEvent("shortReload", 15, removeMag), this.addSoundEvent("shortReload", 100, insertMag), this.addSoundEvent("longReload", 15, removeMag), this.addSoundEvent("longReload", 100, insertMag), this.addSoundEvent("longReload", 155, cycle)
};
(Cluck9mmActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] RPEGGActor CONSTRUCTOR
function RPEGGActor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = .9, this.scopeY = .1 - .0862, this.setup(.51), this.fireSound = this.gunMesh.attachSound(Sounds.rpegg.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire), this.denyFireSound = this.gunMesh.attachSound(Sounds.rpegg.denyFire);
    var loadRocket = this.gunMesh.attachSound(Sounds.rpegg.load);
    this.addSoundEvent("reload", 115, loadRocket)
};
(RPEGGActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;
ItemActor.prototype.update = function (delta) {
    this.mesh.rotation.y += .03 * delta
};

// [LS] ItemActor CONSTRUCTOR
function ItemActor(kind) {
    this.kind = kind, this.scene = gameScene
}
ItemActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] AmmoActor CONSTRUCTOR
function AmmoActor() {
    ItemActor.call(this, ItemManager.AMMO), this.mesh = this.scene.getMeshByName("ammo").createInstance(""), this.mesh.setEnabled(false), shadowGen && shadowGen.getShadowMap().renderList.push(this.mesh)
};
(AmmoActor.prototype = Object.create(ItemActor.prototype)).constructor = ItemActor;

// [LS] GrenadeItemActor CONSTRUCTOR
function GrenadeItemActor() {
    ItemActor.call(this, ItemManager.GRENADE), this.mesh = this.scene.getMeshByName("grenadeItem").createInstance(""), this.mesh.setEnabled(false), shadowGen && shadowGen.getShadowMap().renderList.push(this.mesh)
};
(GrenadeItemActor.prototype = Object.create(ItemActor.prototype)).constructor = ItemActor;

//   ___  ___    _ ___ ___ _____ ___ 
//  / _ \| _ )_ | | __/ __|_   _/ __|
// | (_) | _ \ || | _| (__  | | \__ \
//  \___/|___/\__/|___\___| |_| |___/                                 
// [LS] ######## Object Constructors ---------------------------------

// [LS] Player CONSTRUCTOR
function Player(data, scene) {
    this.id = data.id, this.uniqueId = data.uniqueId, this.name = data.name, this.charClass = data.charClass, this.team = data.team, this.primaryWeaponItem = data.primaryWeaponItem, this.secondaryWeaponItem = data.secondaryWeaponItem, this.shellColor = data.shellColor, this.hatItem = data.hatItem, this.stampItem = data.stampItem, this.x = data.x, this.y = data.y, this.z = data.z, this.dx = data.dx, this.dy = data.dy, this.dz = data.dz, this.controlKeys = data.controlKeys, this.yaw = data.yaw, this.pitch = data.pitch, this.score = data.score, this.kills = data.kills, this.deaths = data.deaths, this.streak = data.streak, this.score = data.score, this.totalKills = data.totalKills, this.totalDeaths = data.totalDeaths, this.bestGameStreak = data.bestGameStreak, this.bestOverallStreak = data.bestOverallStreak, this.shield = data.shield, this.hp = data.hp, this.playing = data.playing, this.weaponIdx = data.weaponIdx, this.upgradeProductId = data.upgradeProductId, this.isGameOwner = data.isGameOwner, this.scene = scene, this.corrected = {
        dx: 0,
        dy: 0,
        dz: 0,
        pitch: 0,
        yaw: 0
    }, this.corrections = 0, this.hackDetected = data.hackDetected, this.rofCountdown = 0, this.triggerPulled = false, this.shotsQueued = 0, this.reloadsQueued = 0, this.roundsToReload = 0, this.recoilCountdown = 0, this.reloadCountdown = 0, this.swapWeaponCountdown = 0, this.weaponSwapsQueued = 0, this.equipWeaponIdx = this.weaponIdx, this.shotSpread = 0, this.randomSeed = data.randomSeed, this.grenadeCount = 1, this.grenadeCapacity = 3, this.grenadeCountdown = 0, this.grenadesQueued = 0, this.jumping = false, this.lastTouchedGround = 1, this.climbing = false, this.climbingCell = {
        x: 0,
        z: 0,
        ry: 0
    }, this.bobble = 0, this.stateIdx = 0, this.syncStateIdx = 0, this.respawnTargetTime = 0, this.pauseTargetTime = 0, this.ready = false, this.chatLineCap = 3, this.respawnQueued = false, this.actor = new PlayerActor(this), this.stateBuffer = [];
    for (var i = 0; i < stateBufferSize; i++) this.stateBuffer.push({
        delta: 0,
        yaw: data.yaw,
        pitch: data.pitch,
        fire: false,
        jumping: false,
        climbing: false,
        x: data.x,
        y: data.y,
        z: data.z,
        dx: data.dx,
        dy: data.dy,
        dz: data.dz,
        controlKeys: data.controlKeys
    });
    this.changeWeaponLoadout(this.primaryWeaponItem, this.secondaryWeaponItem)
};
Player.prototype.changeWeaponLoadout = function (primaryWeaponItem, secondaryWeaponItem) {
    this.actor && this.weapons && (this.weapons[0].actor.dispose(), this.weapons[1].actor.dispose()), this.primaryWeaponItem = primaryWeaponItem, this.secondaryWeaponItem = secondaryWeaponItem, this.weapons = [primaryWeaponItem.instantiateNew(this), secondaryWeaponItem.instantiateNew(this)], this.weapon = this.weapons[this.weaponIdx], this.actor && this.weapon.actor.equip()
};
Player.prototype.update = function (delta, resim) {
    var dx = 0,
        dy = 0,
        dz = 0;
    if (!resim && this.actor && this.id == meId && (this.stateBuffer[this.stateIdx].controlKeys = this.controlKeys, this.stateBuffer[this.stateIdx].yaw = this.yaw, this.stateBuffer[this.stateIdx].pitch = this.pitch), !this.actor || this.id != meId) {
        var idx = this.stateIdx;
        this.actor && this.id != meId && (idx = Math.min(idx, FramesBetweenSyncs - 1)), this.controlKeys = this.stateBuffer[idx].controlKeys, this.yaw = this.stateBuffer[idx].yaw, this.pitch = this.stateBuffer[idx].pitch
    }
    if (this.controlKeys & CONTROL.left && (dx -= Math.cos(this.yaw), dz += Math.sin(this.yaw)), this.controlKeys & CONTROL.right && (dx += Math.cos(this.yaw), dz -= Math.sin(this.yaw)), this.controlKeys & CONTROL.up && (this.climbing ? dy += 1 : (dx += Math.sin(this.yaw), dz += Math.cos(this.yaw))), this.controlKeys & CONTROL.down && (this.climbing ? dy -= 1 : (dx -= Math.sin(this.yaw), dz -= Math.cos(this.yaw))), this.climbing) {
        this.setJumping(false);
        var pdy = this.dy;
        this.corrections && (pdy += this.corrected.dy / 6, this.corrections--), this.dy += .014 * dy * delta;
        var ndy = .5 * (this.dy + pdy) * delta;
        this.y += ndy, this.dy *= Math.pow(.5, delta);
        var cx = Math.floor(this.climbingCell.x),
            cy = Math.floor(this.y + 1e-4),
            cz = Math.floor(this.climbingCell.z);
        if (0 == this.climbingCell.ry || this.climbingCell.ry, cy >= map.height) this.climbing = false;
        else {
            var cell = map.data[cx][cy][cz];
            cell.idx && "ladder" == mapMeshes[cell.idx].colliderType && cell.ry == this.climbingCell.ry || (this.y = Math.round(this.y), this.climbing = false)
        }
        this.collidesWithMap() && (0 < ndy && .3 < this.y % 1 ? (this.y -= ndy, this.dy *= .5) : ndy < 0 && (this.y -= ndy, this.dy *= .5, this.climbing = false))
    } else {
        var deltaVector = new BABYLON.Vector3(dx, dy, dz).normalize(),
            pdx = this.dx,
            pdz = (pdy = this.dy, this.dz);
        this.corrections && (pdx += this.corrected.dx / 6, this.jumping || (pdy += this.corrected.dy / 6), pdz += this.corrected.dz / 6, this.corrections--), this.dx += .007 * deltaVector.x * delta, this.dz += .007 * deltaVector.z * delta, this.dy -= .003 * delta, this.dy = Math.max(-.2, this.dy);
        var ndx = .5 * (this.dx + pdx) * delta,
            ndz = (ndy = .5 * (this.dy + pdy) * delta, .5 * (this.dz + pdz) * delta);
        this.moveX(ndx, delta), this.moveZ(ndz, delta), this.moveY(ndy, delta)
    }
    if (!resim) {
        0 < this.shield && this.playing && (this.shield -= delta, (0 != dx || 0 != dy || this.shield <= 0) && this.disableShield());
        var speed = Math.length3(this.dx, this.dy, this.dz);
        this.actor && this.id == meId && (speed *= .75), (this.climbing || this.jumping) && (speed *= 2), this.bobble = (this.bobble + 7 * speed) % Math.PI2, this.shotSpread += Math.floor(150 * speed * delta);
        var settleFactor = Math.pow(this.weapon.subClass.accuracySettleFactor, delta);
        this.shotSpread = Math.max(this.shotSpread * settleFactor - 4 * (1 - settleFactor), 0), this.weapon && this.weapon.update(delta), 0 < this.hp && (this.hp = Math.min(100, this.hp + .05 * delta)), 0 < this.swapWeaponCountdown && (this.shotSpread = this.weapon.subClass.shotSpreadIncrement, this.swapWeaponCountdown -= delta, this.swapWeaponCountdown <= 0 && (this.actor ? this.id == meId && reticle.show() : (this.swapWeaponCountdown = 0, this.weaponIdx = this.equipWeaponIdx, this.weapon = this.weapons[this.weaponIdx]))), 0 < this.reloadCountdown && (this.shotSpread = this.weapon.subClass.shotSpreadIncrement, this.reloadCountdown -= delta, this.reloadCountdown <= 0 && (this.reloadCountdown = 0, this.reloaded())), 0 < this.rofCountdown && (this.rofCountdown = Math.max(this.rofCountdown - delta, 0)), 0 < this.recoilCountdown && (this.recoilCountdown = Math.max(this.recoilCountdown - delta, 0)), 0 < this.grenadeCountdown && (this.grenadeCountdown -= delta, this.grenadeCountdown <= 0 && 0 < this.grenadesQueued && !this.actor && this.throwGrenade()), this.actor ? this.id == meId && this.triggerPulled && this.fire() : 0 < this.shotsQueued && (this.lastActivity = now, this.fire()), this.stateBuffer[this.stateIdx].x = this.x, this.stateBuffer[this.stateIdx].y = this.y, this.stateBuffer[this.stateIdx].z = this.z, this.stateBuffer[this.stateIdx].dx = this.dx, this.stateBuffer[this.stateIdx].dy = this.dy, this.stateBuffer[this.stateIdx].dz = this.dz, this.stateIdx = Math.mod(this.stateIdx + 1, stateBufferSize)
    }
    this.dx *= Math.pow(.8, delta), this.dz *= Math.pow(.8, delta), this.actor && this.id == meId || (0 < this.reloadsQueued && this.reload(), 0 < this.weaponSwapsQueued && this.swapWeapon(this.equipWeaponIdx))
};
Player.prototype.disableShield = function () {
    this.shield = 0, this.actor && (this.actor.bodyMesh.renderOverlay = false, this.actor.hands.renderOverlay = false)
};
Player.prototype.enableShield = function () {
    this.shield = 120, this.actor && (this.actor.bodyMesh.renderOverlay = true, this.actor.hands.renderOverlay = true)
};
Player.prototype.resetStateBuffer = function () {
    for (var i = 0; i < stateBufferSize; i++) this.stateBuffer[i] = {
        delta: 0,
        yaw: this.yaw,
        pitch: this.pitch,
        fire: false,
        jump: false,
        jumping: false,
        climbing: false,
        x: this.x,
        y: this.y,
        z: this.z,
        dx: 0,
        dy: 0,
        dz: 0,
        controlKeys: 0
    }
};
Player.prototype.moveX = function (ndx, delta) {
    var old_x = this.x;
    this.x += ndx;
    var collide = this.collidesWithMap();
    if (collide) {
        var old_y = this.y;
        this.y += Math.abs(ndx) + .01 * delta, this.collidesWithMap() ? (this.x = old_x, this.dx *= .5, this.y = old_y) : this.dx *= .92, this.lookForLadder(collide)
    }
};
Player.prototype.moveZ = function (ndz, delta) {
    var old_z = this.z;
    this.z += ndz;
    var collide = this.collidesWithMap();
    if (collide) {
        var old_y = this.y;
        this.y += Math.abs(ndz) + .01 * delta, this.collidesWithMap() ? (this.z = old_z, this.dz *= .5, this.y = old_y) : this.dz *= .92, this.lookForLadder(collide)
    }
};
Player.prototype.moveY = function (ndy, delta) {
    var old_y = this.y;
    this.y += ndy, this.collidesWithMap() ? (ndy < 0 && (this.actor && this.id == meId && 0 == this.lastTouchedGround && (this.lastTouchedGround = Date.now()), this.setJumping(false)), this.y = old_y, this.dy *= .5) : 0 == this.jumping && this.setJumping(true)
};
Player.prototype.canJump = function () {
    if (this.actor && this.id != meId) return true;
    var canJump = !this.jumping | this.climbing;
    return canJump || (this.y -= .2, this.collidesWithMap() && (canJump = true), this.y += .2), canJump
};
Player.prototype.jump = function () {
    return this.climbing ? (this.dy = .03, this.climbing = false, this.setJumping(true), true) : !!this.canJump() && (this.dy = .06, this.setJumping(true), !(this.lastTouchedGround = 0))
};
Player.prototype.setJumping = function (jumping) {
    this.jumping = jumping, this.stateBuffer[this.stateIdx].jumping = jumping
};
Player.prototype.changeCharacter = function (classIdx, primaryWeaponItem, secondaryWeaponItem, shellColor, hatItem, stampItem) {
    var itemChanged = function (oldItem, newItem) {
        return oldItem && !newItem || !oldItem && newItem || null !== oldItem && null !== newItem && oldItem.id !== newItem.id
    };
    if (classIdx !== this.charClass || primaryWeaponItem.id !== this.primaryWeaponItem.id || secondaryWeaponItem.id !== this.secondaryWeaponItem.id || shellColor !== this.shellColor || itemChanged(hatItem) || itemChanged(stampItem)) {
        var output;
        if (this.charClass = classIdx, this.primaryWeaponItem = primaryWeaponItem, this.secondaryWeaponItem = secondaryWeaponItem, this.shellColor = shellColor, this.hatItem = hatItem, this.stampItem = stampItem, this.actor)
            if (this.actor.setShellColor(shellColor), this.id == meId) (output = new Comm.output(7)).packInt8(CommCode.changeCharacter), output.packInt8(classIdx), output.packInt8(catalog.get8BitItemId(primaryWeaponItem, classIdx)), output.packInt8(catalog.get8BitItemId(secondaryWeaponItem, classIdx)), output.packInt8(shellColor), output.packInt8(catalog.get8BitItemId(hatItem, classIdx)), output.packInt8(catalog.get8BitItemId(stampItem, classIdx)), ws.send(output.buffer);
            else this.actor.wearHat(this.hatItem), this.actor.applyStamp(this.stampItem);
        else (output = new Comm.output(8, true)).packInt8(CommCode.changeCharacter), output.packInt8(this.id), output.packInt8(classIdx), output.packInt8(catalog.get8BitItemId(primaryWeaponItem, classIdx)), output.packInt8(catalog.get8BitItemId(secondaryWeaponItem, classIdx)), output.packInt8(shellColor), output.packInt8(catalog.get8BitItemId(hatItem, classIdx)), output.packInt8(catalog.get8BitItemId(stampItem, classIdx)), sendToOthers(output.buffer, this.id);
        this.changeWeaponLoadout(primaryWeaponItem, secondaryWeaponItem)
    }
};
Player.prototype.swapWeapon = function (idx) {
    var output;
    (this.actor && this.id != meId || this.canSwapOrReload() && idx < 2) && (this.equipWeaponIdx = idx, this.releaseTrigger(), this.swapWeaponCountdown = this.weapon.stowWeaponTime + this.weapons[idx].equipTime, this.actor ? (this.id == meId && reticle.hide(), this.weapon.actor.stow(), this.id == meId && ((output = new Comm.output(2)).packInt8(CommCode.swapWeapon), output.packInt8(idx), ws.send(output.buffer))) : (this.swapWeaponCountdown *= .9, this.weaponSwapsQueued--, (output = new Comm.output(3, true)).packInt8(CommCode.swapWeapon), output.packInt8(this.id), output.packInt8(idx), sendToOthers(output.buffer, this.id)))
};
Player.prototype.collectItem = function (kind, applyToWeaponIdx) {
    switch (kind) {
        case ItemManager.AMMO:
            return !!this.weapons[applyToWeaponIdx].collectAmmo() && (this.actor && (Sounds.ammo.play(), updateAmmoUi()), true);
        case ItemManager.GRENADE:
            return this.grenadeCount < this.grenadeCapacity && (this.grenadeCount++, this.actor && (Sounds.ammo.play(), updateAmmoUi()), true)
    }
};
Player.prototype.isSteady = function () {
    return !this.weapon.subClass.readySpread || 5 * this.weapon.subClass.readySpread >= this.shotSpread + this.weapon.subClass.accuracy
};
Player.prototype.isAtReady = function (scoped) {
    return !(!(this.playing && this.weapon && this.reloadCountdown <= 0 && this.swapWeaponCountdown <= 0 && this.grenadeCountdown <= 0) || this.actor && 0 != grenadePowerUp)
};
Player.prototype.canSwapOrReload = function () {
    return !(!(this.playing && this.weapon && this.recoilCountdown <= 0 && this.reloadCountdown <= 0 && this.swapWeaponCountdown <= 0 && this.grenadeCountdown <= 0 && this.shotsQueued <= 0) || this.actor && 0 != grenadePowerUp)
};
Player.prototype.fire = function () {
    0 < this.shield ? this.releaseTrigger() : this.isAtReady() && this.rofCountdown <= 0 && (0 < this.weapon.ammo.rounds && this.isSteady() ? (this.actor ? this.actor.fire() : (this.recoilCountdown *= .9, this.rofCountdown *= .9, this.shotsQueued--), this.weapon.fire(), this.weapon.ammo.rounds--, this.recoilCountdown = this.weapon.subClass.recoil, this.rofCountdown = this.weapon.subClass.rof, this.shotSpread += this.weapon.subClass.shotSpreadIncrement, this.actor && this.id == meId && this.shotsQueued++, 0 == this.weapon.subClass.automatic && this.releaseTrigger(), this.actor && this.id == meId && updateAmmoUi()) : this.weapon.actor && (this.weapon.actor.dryFire(), this.releaseTrigger()))
};
Player.prototype.pullTrigger = function () {
    1 == grenadePowerUp && me.grenadeCountdown <= 0 ? this.cancelGrenade() : this.isAtReady() && this.rofCountdown <= 0 && (0 < this.weapon.ammo.rounds ? this.isSteady() ? (this.triggerPulled = true, this.fire()) : this.weapon.actor.denyFire() : 0 < this.weapon.ammo.store ? this.reload() : this.weapon.actor.dryFire())
};
Player.prototype.releaseTrigger = function () {
    this.triggerPulled = false
};
Player.prototype.reload = function () {
    if (this.actor && this.id != meId) this.weapon.actor.reload();
    else if (this.weapon.ammo.rounds != this.weapon.ammo.capacity && 0 != this.weapon.ammo.store && this.canSwapOrReload()) {
        var output, rounds = Math.min(Math.min(this.weapon.ammo.capacity, this.weapon.ammo.reload) - this.weapon.ammo.rounds, this.weapon.ammo.store);
        if (this.roundsToReload = rounds, this.actor) this.weapon.actor.reload(), this.releaseTrigger(), (output = new Comm.output(1)).packInt8(CommCode.reload), ws.send(output.buffer), this.weapon.ammo.store -= rounds;
        else (output = new Comm.output(2, true)).packInt8(CommCode.reload), output.packInt8(this.id), sendToOthers(output.buffer, this.id), this.reloadsQueued--;
        0 == this.weapon.ammo.rounds ? this.reloadCountdown = this.weapon.longReloadTime : this.reloadCountdown = this.weapon.shortReloadTime
    }
};
Player.prototype.reloaded = function () {
    this.weapon.ammo.rounds += this.roundsToReload, this.actor ? this.id == meId && updateAmmoUi() : this.weapon.ammo.store -= this.roundsToReload
};
Player.prototype.queueGrenade = function (throwPower) {
    this.grenadesQueued++, this.grenadeThrowPower = Math.clamp(throwPower, 0, 1), this.grenadeCountdown = 20, this.actor || (this.grenadeCountdown *= .9)
};
Player.prototype.cancelGrenade = function () {
    grenadePowerUp = false, me.grenadeCountdown = 30, this.id == meId && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden"), this.actor && (this.actor.gripBone._frozen = false)
};
Player.prototype.throwGrenade = function () {
    0 < this.shield && this.disableShield();
    if (this.actor) (output = new Comm.output(3)).packInt8(CommCode.throwGrenade), output.packFloat(Math.clamp(grenadeThrowPower, 0, 1)), ws.send(output.buffer), me.grenadeCountdown = 80, this.actor.reachForGrenade();
    else if (this.isAtReady() && 0 < this.grenadeCount) {
        this.grenadeCount--, this.grenadesQueued--, this.grenadeCountdown = 72, this.grenadeCountdown = 1;
        var output, rotMat = BABYLON.Matrix.RotationYawPitchRoll(this.yaw, this.pitch, 0),
            vec = BABYLON.Matrix.Translation(0, .1, 1).multiply(rotMat).getTranslation(),
            posMat = BABYLON.Matrix.Translation(0, -.05, .2),
            pos = (posMat = (posMat = posMat.multiply(rotMat)).add(BABYLON.Matrix.Translation(this.x, this.y + .3, this.z))).getTranslation(),
            speed = .13 * this.grenadeThrowPower + .08;
        vec.x *= speed;
        vec.y *= speed;
        vec.z *= speed;
        pos.x = Math.floor(300 * pos.x) / 300;
        pos.y = Math.floor(300 * pos.y) / 300;
        pos.z = Math.floor(300 * pos.z) / 300;
        vec.x = Math.floor(300 * vec.x) / 300;
        vec.y = Math.floor(300 * vec.y) / 300;
        vec.z = Math.floor(300 * vec.z) / 300;
        (output = new Comm.output(14, true)).packInt8(CommCode.throwGrenade);
        output.packInt8(this.id);
        output.packFloat(pos.x);
        output.packFloat(pos.y);
        output.packFloat(pos.z);
        output.packFloat(vec.x);
        output.packFloat(vec.y);
        output.packFloat(vec.z);
        sendToAll(output.buffer);
        munitionsManager.throwGrenade(this, pos, vec);
    }
};
Player.prototype.removeFromPlay = function () {
    this.playing = false, this.controlKeys = 0, this.shotSpread = 0, this.jumping = false, this.climbing = false, this.actor && (this.actor.removeFromPlay(), this.id == meId && (reticle.hide(), scope.hide(), camera.fov = 1.25, grenadePowerUp = false, document.getElementById("grenadeThrowContainer").style.visibility = "hidden"))
};
Player.prototype.scoreKill = function () {
    this.kills++, this.totalKills++, this.streak++, this.bestGameStreak = Math.max(this.bestGameStreak, this.streak), this.bestOverallStreak = Math.max(this.bestOverallStreak, this.streak), this.score = this.streak
};
Player.prototype.die = function () {
    this.score = 0, this.streak = 0, this.deaths++, this.totalDeaths++, this.hp = 0, this.playing = false, this.removeFromPlay()
};
Player.prototype.respawn = function (x, y, z) {
    this.x = x, this.y = y, this.z = z, this.respawnQueued = false, this.playing = true, this.hp <= 0 ? (this.hp = 100, this.resetWeaponState()) : this.resetWeaponState(true), this.resetStateBuffer(), this.actor && (this.id == meId && (viewingPlayerId = meId), this.actor.mesh.position.x = x, this.actor.mesh.position.y = y, this.actor.mesh.position.z = z, this.actor.restoreToPlay(), this.weapon.equip(), this.id == viewingPlayerId && (shake = 0, reticle.show(), updateAmmoUi())), this.enableShield()
};
Player.prototype.resetWeaponState = function (dontReload) {
    if (this.rofCountdown = 0, this.shotsQueued = 0, this.reloadsQueued = 0, this.recoilCountdown = 0, this.reloadCountdown = 0, this.swapWeaponCountdown = 0, this.weaponSwapsQueued = 0, this.shotSpread = 0, this.equipWeaponIdx = this.weaponIdx, this.weapon = this.weapons[this.weaponIdx], this.grenadeCountdown = 0, this.grenadesQueued = 0, this.releaseTrigger(), this.actor && (this.weapons[0].actor.gunMesh.setEnabled(false), this.weapons[1].actor.gunMesh.setEnabled(false)), !dontReload) {
        for (var i = 0; i < this.weapons.length; i++) this.weapons[i] && (this.weapons[i].ammo.rounds = this.weapons[i].ammo.capacity, this.weapons[i].ammo.store = this.weapons[i].ammo.storeMax);
        this.grenadeCount = Math.max(this.grenadeCount, 1)
    };
};
Player.prototype.isDead = function () {
    return this.hp <= 0;
};
Player.prototype.lookForLadder = function (collide) {
    if (collide && collide.cell && this.controlKeys & CONTROL.up && "ladder" == mapMeshes[collide.cell.idx].colliderType) {
        var diff = Math.abs(Math.radDifference(this.yaw, collide.cell.ry));
        if (!(.75 < diff && diff < 2.391)) {
            if (1 == collide.cell.ry || 3 == collide.cell.ry) {
                if (.2 < Math.abs(this.z - collide.z - .5)) return
            } else if (.2 < Math.abs(this.x - collide.x - .5)) return;
            this.climbingCell.x = collide.x, this.climbingCell.z = collide.z, this.climbingCell.ry = collide.cell.ry, this.climbing = true, this.lastTouchedGround = Date.now() + 100, this.setJumping(false)
        }
    }
};
Player.prototype.getOccupiedCell = function () {
    if (this.x < 0 || this.y < 0 || this.z < 0 || this.x >= map.width || this.y >= map.height || this.z > map.depth) return {};
    var cx = Math.floor(this.x),
        cy = Math.floor(this.y + 1e-4),
        cz = Math.floor(this.z);
    return map.data[cx][cy][cz]
};
Player.prototype.collidesWithMap = function () {
    return Collider.playerCollidesWithMap(this)
};

// [LS] Grenade CONSTRUCTOR
function Grenade(scene) {
    this.scene = scene, this.x = 0, this.y = 0, this.z = 0, this.dx = 0, this.dy = 0, this.dz = 0, this.ttl = 0, this.active = false, this.player = null, this.actor = new GrenadeActor(this)
};
Grenade.v1 = new BABYLON.Vector3, Grenade.v2 = new BABYLON.Vector3, Grenade.v3 = new BABYLON.Vector3, Grenade.v4 = new BABYLON.Vector3, Grenade.matrix = new BABYLON.Matrix;
Grenade.prototype.update = function (delta) {
    if (this.ttl <= 0)
        if (munitionsManager.grenadePool.recycle(this), this.actor) {
            addExplosion(this.x, this.y, this.z, this.damage, this.radius);
            var pos = new BABYLON.Vector3(this.x, this.y, this.z);
            this.actor.explodeSound.setPosition(pos), this.actor.explodeSound.play(), this.actor.remove()
        } else checkExplosionCollisions(this);
    else {
        var pdx = this.dx,
            pdy = this.dy,
            pdz = this.dz,
            ndx = .5 * (this.dx + pdx) * delta,
            ndy = .5 * (this.dy + pdy) * delta,
            ndz = .5 * (this.dz + pdz) * delta;
        this.collidesWithMap() || (this.x += ndx, this.y += ndy, this.z += ndz, this.dy -= .003 * delta), this.dx *= Math.pow(.98, delta), this.dz *= Math.pow(.98, delta), this.ttl -= delta, this.actor && this.actor.update()
    }
};
Grenade.prototype.collidesWithMap = function () {
    Grenade.v1.set(this.x, this.y - .07, this.z), Grenade.v2.set(this.dx, this.dy, this.dz), Grenade.v3.set(this.dx, this.dy, this.dz);
    var res = Collider.rayCollidesWithMap(Grenade.v1, Grenade.v2, Collider.grenadeCollidesWithCell);
    return !!res && (Grenade.v3.subtractInPlace(res.normal.scale(1.6 * res.dot)), this.dx = .98 * Grenade.v3.x, this.dy = Grenade.v3.y, this.dz = .98 * Grenade.v3.z, this.actor && this.actor.bounce(), res)
};
Grenade.prototype.throw = function (player, pos, vec) {
    this.player = player, this.x = pos.x, this.y = pos.y, this.z = pos.z, this.dx = vec.x, this.dy = vec.y, this.dz = vec.z, this.ttl = 150, this.damage = 130, this.radius = 3, this.active = true, this.actor && this.actor.throw()
};

// [LS] Bullet CONSTRUCTOR
function Bullet(scene) {
    this.scene = scene;
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.dx = 0;
    this.dy = 0;
    this.dz = 0;
    this.active = false;
    this.player = null;
    this.damage = 20;
    this.range = 0;
    this.velocity = 0;
    this.actor = new BulletActor(this);
    this.end = new BABYLON.Vector3;
};
Bullet.origin = new BABYLON.Vector3;
Bullet.direction = new BABYLON.Vector3;
Bullet.fire = function (player, pos, dir, weaponClass) {
    munitionsManager.bulletPool.retrieve().fireThis(player, pos, dir, weaponClass)
};
Bullet.prototype.fireThis = function (player, pos, dir, weaponClass) {
    this.player = player;
    this.x = pos.x;
    this.y = pos.y;
    this.z = pos.z;
    Bullet.direction.copyFrom(dir).normalize();
    this.dx = Bullet.direction.x * weaponClass.velocity;
    this.dy = Bullet.direction.y * weaponClass.velocity;
    this.dz = Bullet.direction.z * weaponClass.velocity;
    this.weaponClass = weaponClass;
    this.damage = weaponClass.damage;
    this.active = true;
    this.range = weaponClass.range;
    this.velocity = weaponClass.velocity;
    var res = Collider.rayCollidesWithMap(pos, dir, Collider.projectileCollidesWithCell);
    res && (this.actor && this.end.copyFrom(res.pick.pickedPoint), this.range = BABYLON.Vector3.Distance(pos, res.pick.pickedPoint)), this.actor && this.actor.fire()
};
Bullet.prototype.remove = function () {
    munitionsManager.bulletPool.recycle(this);
    this.actor && this.actor.remove();
};
Bullet.prototype.update = function (delta) {
    if (Bullet.origin.set(this.x, this.y, this.z), Bullet.direction.set(this.dx, this.dy, this.dz), !Collider.rayCollidesWithPlayer(Bullet.origin, Bullet.direction, this))
        if (this.range <= 0) {
            if (this.actor && this.range < this.weaponClass.range) {
                var pos = this.end,
                    dx = .1 * -this.dx,
                    dy = .1 * -this.dy,
                    dz = .1 * -this.dz;
                ! function (x, y, z, dx, dy, dz) {
                    var s = explosionSmokeManager.getSprite();
                    s.animLength = 20 * Math.random() + 30, s.easing = Ease.outQuint, s.position.x = x, s.position.y = y, s.position.z = z, s.dx = .1 * dx, s.dy = .1 * dy, s.dz = .1 * dz, s.startSize = .1, s.endSize = .2 * Math.random() + .4, s.angle = Math.random() * Math.PI2, s.rotate = .08 * Math.random() - .04, s.animColors = bulletHitColors
                }(pos.x, pos.y, pos.z, dx, dy, dz)
            }
            this.remove()
        } else this.x += this.dx * delta, this.y += this.dy * delta, this.z += this.dz * delta, this.range -= this.velocity * delta, this.actor && this.actor.update()
};
Bullet.prototype.collidesWithPlayer = function (player, point) {
    if (!this.actor) {
        tv1.x = this.dx, tv1.y = this.dy, tv1.z = this.dz, tv2.x = player.x - point.x, tv2.y = player.y + .32 - point.y, tv2.z = player.z - point.z;
        var dist = BABYLON.Vector3.Cross(tv1, tv2);
        this.damage; //this line does nothing
        dist.length();
        this.player; //this line does nothing
        tv1.x, tv1.z
    };
    this.remove();
};

// [LS] Rocket CONSTRUCTOR
function Rocket(scene) {
    this.scene = scene, this.x = 0, this.y = 0, this.z = 0, this.dx = 0, this.dy = 0, this.dz = 0, this.ttArmed = 10, this.active = false, this.player = null, this.damage = 130, this.actor = new RocketActor(this), this.end = new BABYLON.Vector3
};
Rocket.origin = new BABYLON.Vector3, Rocket.direction = new BABYLON.Vector3, Rocket.prototype.remove = function () {
    munitionsManager.rocketPool.recycle(this), this.actor && this.actor.remove()
};
Rocket.prototype.update = function (delta) {
    if (Rocket.origin.set(this.x, this.y, this.z), Rocket.direction.set(this.dx, this.dy, this.dz), !Collider.rayCollidesWithPlayer(Rocket.origin, Rocket.direction, this)) {
        if (this.range <= 0) return this.x -= this.dx, this.y -= this.dy, this.z -= this.dz, this.explode(), void this.remove();
        this.x += this.dx * delta, this.y += this.dy * delta, this.z += this.dz * delta, this.ttArmed -= delta, this.range -= this.velocity * delta, this.actor && this.actor.update()
    }
};
Rocket.fire = function (player, pos, dir, weaponClass) {
    munitionsManager.rocketPool.retrieve().fireThis(player, pos, dir, weaponClass)
};
Rocket.prototype.fireThis = function (player, pos, dir, weaponClass) {
    this.ttArmed = 0, this.radius = weaponClass.radius, this.player = player, this.x = pos.x, this.y = pos.y, this.z = pos.z, this.weaponClass = weaponClass;
    var v = dir.clone().normalize();
    this.dx = v.x * weaponClass.velocity, this.dy = v.y * weaponClass.velocity, this.dz = v.z * weaponClass.velocity, this.damage = weaponClass.damage, this.active = true, this.range = weaponClass.range, this.velocity = weaponClass.velocity;
    var res = Collider.rayCollidesWithMap(pos, dir, Collider.projectileCollidesWithCell);
    res && (this.actor && this.end.copyFrom(res.pick.pickedPoint), this.range = BABYLON.Vector3.Distance(pos, res.pick.pickedPoint)), this.actor && this.actor.fire()
};
Rocket.prototype.explode = function () {
    if (this.actor) {
        addExplosion(this.x, this.y, this.z, this.damage, this.radius);
        var pos = new BABYLON.Vector3(this.x, this.y, this.z);
        this.actor.explodeSound.setPosition(pos), this.actor.explodeSound.play()
    } else checkExplosionCollisions(this);
    this.remove()
};
Rocket.prototype.poof = function () {
    if (this.actor) {
        var pos = new BABYLON.Vector3(this.x, this.y, this.z);
        this.actor.poofSound.setPosition(pos), this.actor.poofSound.play();
        for (var i = 0; i < 10; i++) {
            var dx = .2 * Math.random() - .1,
                dy = .2 * Math.random() - .1,
                dz = .2 * Math.random() - .1;
            addExplosionSprite(explosionSmokeManager, 10, pos.x, pos.y, pos.z, dx, dy, dz, .4, false)
        }
    }
    this.remove()
};
Rocket.prototype.collidesWithMap = function (res) {
    this.x -= this.dx, this.y -= this.dy, this.z -= this.dz, this.ttArmed <= 0 ? this.explode() : this.poof()
};
Rocket.prototype.collidesWithPlayer = function (player) {
    this.ttArmed <= 0 ? (this.actor || (this.player, tv1.x, tv1.z), this.explode()) : (this.actor || (this.player, tv1.x, tv1.z), this.poof())
};

// [LS] Gun CONSTRUCTOR
function Gun(player, subClass) {
    this.player = player, this.scene = this.player.scene, this.subClass = subClass, this.highPrecision = false, this.equipTime = 25, this.stowWeaponTime = 25
};
Gun.prototype.update = function (delta) {
    this.actor && this.actor.update(delta)
};
Gun.prototype.collectAmmo = function () {
    return this.actor ? (this.ammo.store = Math.min(this.ammo.storeMax, this.ammo.store + this.ammo.pickup), true) : this.ammo.store < this.ammo.storeMax && (this.ammo.store = Math.min(this.ammo.storeMax, this.ammo.store + this.ammo.pickup), true)
};
Gun.prototype.fire = function () {
    if (this.actor) this.actor.fire();
    else {
        var rotMat = BABYLON.Matrix.RotationYawPitchRoll(this.player.yaw, this.player.pitch, 0),
            forwardMat = BABYLON.Matrix.Translation(0, 0, this.subClass.range),
            dirMat = forwardMat.multiply(rotMat, forwardMat),
            dir = dirMat.getTranslation(),
            spread = .004 * (this.player.shotSpread + this.subClass.accuracy);
        isNaN(spread) && (spread = this.player.shotSpread = 0);
        var spreadMat = BABYLON.Matrix.RotationYawPitchRoll((Math.random() - .5) * spread, (Math.random() - .5) * spread, (Math.random() - .5) * spread),
            posMat = (dir = (dirMat = dirMat.multiply(spreadMat)).getTranslation(), BABYLON.Matrix.Translation(0, .1, 0)),
            pos = (posMat = (posMat = posMat.multiply(rotMat)).add(BABYLON.Matrix.Translation(this.player.x, this.player.y + .3, this.player.z))).getTranslation();
        mathSeed = Math.randomInt(0, 256), pos.x = Math.floor(300 * pos.x) / 300, pos.y = Math.floor(300 * pos.y) / 300, pos.z = Math.floor(300 * pos.z) / 300, dir.x = Math.floor(300 * dir.x) / 300, dir.y = Math.floor(300 * dir.y) / 300, dir.z = Math.floor(300 * dir.z) / 300;
        var output = new Comm.output(15, true);
        output.packInt8(CommCode.fire), output.packInt8(this.player.id), output.packFloat(pos.x), output.packFloat(pos.y), output.packFloat(pos.z), output.packFloat(dir.x), output.packFloat(dir.y), output.packFloat(dir.z), output.packInt8(mathSeed), sendToAll(output.buffer), this.fireMunitions(pos, dir)
    }
};
Gun.prototype.equip = function () {
    this.player.weaponIdx = this.player.equipWeaponIdx, this.player.weapon = this.player.weapons[this.player.weaponIdx], this.player.weapon.actor.equip(), this.player.id == meId && updateAmmoUi()
};

// [LS] Eggk47 CONSTRUCTOR
function Eggk47(player, meshName) {
    Gun.call(this, player, Eggk47);
    this.ammo = {
        rounds: 30,
        capacity: 30,
        reload: 30,
        store: 240,
        storeMax: 240,
        pickup: 30
    };
    this.longReloadTime = 210, this.shortReloadTime = 180, this.actor = new Eggk47Actor(this, meshName)
};
(Eggk47.prototype = Object.create(Gun.prototype)).constructor = Gun;
Eggk47.weaponName = "EggK-47";
Eggk47.standardMeshName = "eggk47";
Eggk47.rof = 3600 / 550;
Eggk47.recoil = 7;
Eggk47.automatic = true;
Eggk47.accuracy = 12;
Eggk47.shotSpreadIncrement = 40;
Eggk47.accuracySettleFactor = .9;
Eggk47.damage = 48;
Eggk47.totalDamage = 48;
Eggk47.range = 20;
Eggk47.velocity = .5;
Eggk47.prototype.fireMunitions = function (pos, dir) {
    Bullet.fire(this.player, pos, dir, Eggk47)
};

// [LS] DozenGauge CONSTRUCTOR
function DozenGauge(player, meshName) {
    Gun.call(this, player, DozenGauge), this.ammo = {
        rounds: 2,
        capacity: 2,
        reload: 2,
        store: 24,
        storeMax: 24,
        pickup: 8
    }, this.longReloadTime = 155, this.shortReloadTime = 155, this.v1 = new BABYLON.Vector3, this.actor = new DozenGaugeActor(this, meshName)
};
(DozenGauge.prototype = Object.create(Gun.prototype)).constructor = Gun;
DozenGauge.weaponName = "Dozen Gauge";
DozenGauge.standardMeshName = "dozenGauge";
DozenGauge.rof = 15;
DozenGauge.recoil = 10;
DozenGauge.automatic = false;
DozenGauge.accuracy = 30;
DozenGauge.shotSpreadIncrement = 120;
DozenGauge.accuracySettleFactor = .88;
DozenGauge.damage = 12;
DozenGauge.totalDamage = 240;
DozenGauge.range = 7;
DozenGauge.velocity = .45;
DozenGauge.prototype.fireMunitions = function (pos, dir) {
    for (var i = 0; i < 20; i++) this.v1.set(dir.x + Math.seededRandom(-.14, .14) * DozenGauge.range, dir.y + Math.seededRandom(-.09, .09) * DozenGauge.range, dir.z + Math.seededRandom(-.14, .14) * DozenGauge.range), Bullet.fire(this.player, pos, this.v1, DozenGauge)
};

// [LS] CSG1 CONSTRUCTOR
function CSG1(player, meshName) {
    Gun.call(this, player, CSG1), this.ammo = {
        rounds: 5,
        capacity: 5,
        reload: 5,
        store: 15,
        storeMax: 15,
        pickup: 5
    }, this.hasScope = true, this.longReloadTime = 240, this.shortReloadTime = 150, this.highPrecision = true, this.actor = new CSG1Actor(this, meshName)
};
(CSG1.prototype = Object.create(Gun.prototype)).constructor = Gun;
CSG1.weaponName = "CSG-1";
CSG1.standardMeshName = "csg1";
CSG1.rof = 60;
CSG1.recoil = 10;
CSG1.automatic = false;
CSG1.accuracy = 0;
CSG1.shotSpreadIncrement = 180;
CSG1.accuracySettleFactor = .94;
CSG1.damage = 230;
CSG1.totalDamage = 230;
CSG1.range = 50;
CSG1.velocity = .6;
CSG1.prototype.fireMunitions = function (pos, dir) {
    Bullet.fire(this.player, pos, dir, CSG1)
};

// [LS] Cluck9mm CONSTRUCTOR
function Cluck9mm(player, meshName) {
    Gun.call(this, player, Cluck9mm), this.ammo = {
        rounds: 15,
        capacity: 15,
        reload: 15,
        store: 60,
        storeMax: 60,
        pickup: 15
    }, this.longReloadTime = 195, this.shortReloadTime = 160, this.actor = new Cluck9mmActor(this, meshName)
};
(Cluck9mm.prototype = Object.create(Gun.prototype)).constructor = Gun;
Cluck9mm.weaponName = "Cluck 9mm";
Cluck9mm.standardMeshName = "cluck9mm";
Cluck9mm.rof = 6;
Cluck9mm.recoil = 6;
Cluck9mm.automatic = false;
Cluck9mm.accuracy = 26;
Cluck9mm.shotSpreadIncrement = 100;
Cluck9mm.accuracySettleFactor = .84;
Cluck9mm.damage = 38;
Cluck9mm.totalDamage = 38;
Cluck9mm.range = 15;
Cluck9mm.velocity = .45;
Cluck9mm.prototype.fireMunitions = function (pos, dir) {
    Bullet.fire(this.player, pos, dir, Cluck9mm)
};

// [LS] RPEGG CONSTRUCTOR
function RPEGG(player, meshName) {
    Gun.call(this, player, RPEGG), this.ammo = {
        rounds: 1,
        capacity: 1,
        reload: 1,
        store: 3,
        storeMax: 3,
        pickup: 1
    }, this.hasScope = true, this.longReloadTime = 170, this.shortReloadTime = 170, this.actor = new RPEGGActor(this, meshName)
};
(RPEGG.prototype = Object.create(Gun.prototype)).constructor = Gun;
RPEGG.weaponName = "RPEGG";
RPEGG.standardMeshName = "rpegg";
RPEGG.rof = 80;
RPEGG.recoil = 60;
RPEGG.automatic = false;
RPEGG.accuracy = 5;
RPEGG.shotSpreadIncrement = 200;
RPEGG.accuracySettleFactor = .97;
RPEGG.damage = 120;
RPEGG.radius = 3;
RPEGG.totalDamage = 330;
RPEGG.range = 45;
RPEGG.velocity = .2;
RPEGG.readySpread = 5;
RPEGG.prototype.fireMunitions = function (pos, dir) {
    Rocket.fire(this.player, pos, dir, RPEGG);
    if (this.actor) {
        for (var i = 0; i < 10; i++) {
            var dx = .04 * Math.random() - .02,
                dy = .04 * Math.random() - .02,
                dz = .04 * Math.random() - .02;
            addExplosionSprite(explosionSmokeManager, 10, pos.x, pos.y, pos.z, dx, dy, dz, .4, false)
        };
    };
};

// [LS] Scope CONSTRUCTOR
function Scope() {
    this.crosshairs = new BABYLON.AbstractMesh("", gameScene), this.crosshairs.setEnabled(false), this.crosshairs.position.z = 2;
    var p = [new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(1, 0, 0)],
        l = BABYLON.MeshBuilder.CreateLines("", {
            points: p
        }, gameScene);
    l.layerMask = 536870912, l.color = BABYLON.Color3.Black(), l.parent = this.crosshairs, p = [new BABYLON.Vector3(0, -1, 0), new BABYLON.Vector3(0, 1, 0)], (l = BABYLON.MeshBuilder.CreateLines("", {
        points: p
    }, gameScene)).layerMask = 536870912, l.color = BABYLON.Color3.Black(), l.parent = this.crosshairs
}
Scope.prototype.show = function () {
    var h = engine.getRenderHeight();
    this.crosshairs.scaling.x = h / 2, this.crosshairs.scaling.y = h / 2, this.crosshairs.setEnabled(true), document.getElementById("scopeBorder").style.display = "block", camera.viewport.width = h / engine.getRenderWidth(), camera.viewport.x = .5 - .5 * camera.viewport.width
};
Scope.prototype.hide = function () {
    this.crosshairs.setEnabled(false), document.getElementById("scopeBorder").style.display = "none", camera.viewport.width = 1, camera.viewport.x = 0
};

// [LS] HitIndicator CONSTRUCTOR
function HitIndicator() {
    this.mesh = new BABYLON.Mesh("hitIndicator", gameScene), this.mesh.updatable = true, this.mesh.hasVertexAlpha = true, this.positions = [0, 0, 0, 0, .5, 0, .5, .5, 0, .5, 0, 0, .5, -.5, 0, 0, -.5, 0, -.5, -.5, 0, -.5, 0, 0, -.5, .5, 0];
    this.colors = new Array(48).fill(0);
    for (var i = 0; i < 48; i += 4) this.colors[i] = 1, this.colors[i + 1] = .9, this.colors[i + 2] = 0, this.colors[i + 3] = -.5;
    var vertexData = new BABYLON.VertexData;
    vertexData.positions = this.positions, vertexData.indices = [0, 1, 8, 0, 2, 1, 0, 2, 1, 0, 3, 2, 0, 3, 2, 0, 4, 3, 0, 4, 3, 0, 5, 4, 0, 5, 4, 0, 6, 5, 0, 6, 5, 0, 7, 6, 0, 7, 6, 0, 8, 7, 0, 8, 7, 0, 1, 8], vertexData.colors = this.colors, vertexData.applyToMesh(this.mesh, true), this.mesh.layerMask = 536870912, this.mesh.material = gameScene.getMaterialByName("ui"), this.resize()
};
HitIndicator.prototype.resize = function () {
    this.mesh.scaling.x = engine.getRenderWidth(), this.mesh.scaling.y = engine.getRenderHeight()
};
HitIndicator.prototype.update = function (delta) {
    for (var i = 7; i < 48; i += 4) this.colors[i] -= (this.colors[i] + .5) / 10 * delta;
    var mult = Math.pow(.9, delta);
    me && me.playing && (camera.position.x *= mult, camera.position.z *= mult), this.mesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, this.colors, true)
};
HitIndicator.prototype.hit = function (dx, dz) {
    var a = Math.radRange(-Math.atan2(dx, -dz) - me.yaw + .393);
    a = Math.floor(a / Math.PI2 * 8);
    var vec = new BABYLON.Vector2(-this.positions[3 * a + 3], -this.positions[3 * a + 4]).normalize();
    camera.position.x = .03 * vec.x, camera.position.z = .03 * vec.y, this.colors[4 * a + 7] = 2
};

// [LS] Reticle CONSTRUCTOR
function Reticle() {
    this.crosshairs = [];
    for (var i = 0; i < 4; i++) this.crosshairs.push(document.getElementById("crosshair" + i));
    this.readyBrackets = document.getElementById("readyBrackets")
};
Reticle.prototype.show = function () {
    if (document.getElementById("reticleContainer").className = "", me.weapon.subClass.readySpread) {
        this.readyBrackets.className = "notReady";
        var size = .069 * me.weapon.subClass.readySpread * 10 + "em";
        this.readyBrackets.style.width = size, this.readyBrackets.style.height = size
    } else this.readyBrackets.className = "hideme"
};
Reticle.prototype.hide = function () {
    document.getElementById("reticleContainer").className = "hideme"
};
Reticle.prototype.fireDenied = function () {
    this.readyBrackets.className = "";
    var that = this;
    setTimeout(function () {
        that.readyBrackets.className = "notReady"
    }, 10)
};
Reticle.prototype.update = function (delta) {
    if (me.weapon) {
        for (var i = 0; i < 4; i++) {
            var spread = me.shotSpread + me.weapon.subClass.accuracy;
            this.crosshairs[i].style.transform = "rotate(" + 90 * i + "deg) translateY(" + (.069 * spread + .12) + "em)"
        }
        me.weapon.subClass.readySpread && (spread <= 5 * me.weapon.subClass.accuracy ? this.readyBrackets.className = "ready" : this.readyBrackets.className = "notReady")
    }
};
Reticle.prototype.resize = function () { };


//  __  __   _   _  _   _   ___ ___ ___  ___ 
// |  \/  | /_\ | \| | /_\ / __| __| _ \/ __|
// | |\/| |/ _ \| .` |/ _ \ (_ | _||   /\__ \
// |_|  |_/_/ \_\_|\_/_/ \_\___|___|_|_\|___/
// [LS] ######## MANAGERS ---------------------------------

// [LS] Pool CONSTRUCTOR
function Pool(constructorFn, size) {
    this.size = 0, this.originalSize = size, this.constructorFn = constructorFn, this.objects = [], this.idx = 0, this.numActive = 0, this.expand(size)
};
Pool.prototype.expand = function (num) {
    for (var i = 0; i < num; i++) {
        var obj = this.constructorFn();
        obj.id = i + this.size, obj.active = false, this.objects.push(obj)
    }
    this.size += num
};
Pool.prototype.retrieve = function (id) {
    if (null != id) {
        for (; id >= this.size;) this.expand(this.originalSize);
        return this.numActive++, this.objects[id].active = true, this.objects[id]
    }
    var i = this.idx;
    do {
        i = (i + 1) % this.size;
        var obj = this.objects[i];
        if (!obj.active) return this.idx = i, this.numActive++, obj.active = true, obj
    } while (i != this.idx);
    return this.expand(this.originalSize), this.retrieve()
};
Pool.prototype.recycle = function (obj) {
    obj.active = false, this.numActive--
};
Pool.prototype.forEachActive = function (fn) {
    for (var i = 0; i < this.size; i++) {
        var obj = this.objects[i];
        true === obj.active && fn(obj, i)
    }
};

// [LS] MunitionsManager CONSTRUCTOR
function MunitionsManager(scene) {
    this.bulletPool = new Pool(function () { return new Bullet(scene) }, 200);
    this.rocketPool = new Pool(function () { return new Rocket(scene) }, 20);
    this.grenadePool = new Pool(function () { return new Grenade(scene) }, 10);
};
MunitionsManager.prototype.update = function (delta) {
    this.bulletPool.forEachActive(function (bullet) { bullet.update(delta) });
    this.rocketPool.forEachActive(function (rocket) { rocket.update(delta) });
    this.grenadePool.forEachActive(function (grenade) { grenade.update(delta) })
};
MunitionsManager.prototype.throwGrenade = function (player, pos, vec) {
    this.grenadePool.retrieve().throw(player, pos, vec);
};
MunitionsManager.prototype.getMapIntersectionPoint = function (proj, res) {
    if (res && !mapMeshes[res.cell.idx].softness && res.cell && res.cell.idx) {
        var mapMesh = mapMeshes[res.cell.idx],
            ray = new BABYLON.Ray(new BABYLON.Vector3(proj.x - proj.dx - res.x - .5, proj.y - proj.dy - res.y - .5, proj.z - proj.dz - res.z - .5), new BABYLON.Vector3(2 * proj.dx, 2 * proj.dy, 2 * proj.dz), 1);
        mapMesh.rotation.x = res.cell.rx, mapMesh.rotation.y = res.cell.ry, mapMesh.rotation.z = res.cell.rz;
        var pickInfo = ray.intersectsMesh(mapMesh, false);
        if (pickInfo.hit) {
            var ofs = new BABYLON.Vector3(-proj.dx, -proj.dy, -proj.dz).normalize().scale(.005);
            return {
                x: pickInfo.pickedPoint.x + res.x + .5 + ofs.x,
                y: pickInfo.pickedPoint.y + res.y + .5 + ofs.y,
                z: pickInfo.pickedPoint.z + res.z + .5 + ofs.z
            };
        };
    };
    return false
};

// [LS] ItemManager CONSTRUCTOR
function ItemManager() {
    this.pools = [new Pool(function () {
        return new ItemManager.Constructors[ItemManager.AMMO]
    }, 100), new Pool(function () {
        return new ItemManager.Constructors[ItemManager.GRENADE]
    }, 20)]
};
ItemManager.AMMO = 0;
ItemManager.GRENADE = 1;
ItemManager.Constructors = [AmmoActor, GrenadeItemActor];
ItemManager.prototype.update = function (delta) {
    for (var k = 0; k < this.pools.length; k++) this.pools[k].forEachActive(function (item) {
        item.update(delta), item.mesh.isVisible = isMeshVisible(item.mesh)
    })
};
ItemManager.prototype.spawnItem = function (id, kind, x, y, z) {
    var item = this.pools[kind].retrieve(id);
    item.mesh.setEnabled(true), item.mesh.position.x = x, item.mesh.position.y = y, item.mesh.position.z = z, testing && item.mesh.freezeWorldMatrix()
};
ItemManager.prototype.collectItem = function (kind, id) {
    this.pools[kind].recycle(this.pools[kind].objects[id]), this.pools[kind].objects[id].remove()
};
ItemManager.prototype.recycleAllItems = function () {
    for (var that = this, k = 0; k < this.pools.length; k++) this.pools[k].forEachActive(function (item) {
        that.pools[k].recycle(item), item.remove()
    })
};

//  __  __   _ _____ _  _ 
// |  \/  | /_\_   _| || |
// | |\/| |/ _ \| | | __ |
// |_|  |_/_/ \_\_| |_||_|
// [LS] ######## Math Extensions ---------------------------------

Math.PI2 = 2 * Math.PI, Math.PI90 = Math.PI / 2;
mathSeed = 100;
Math.mod = function (n, m) {
    var remain = n % m;
    return 0 <= remain ? remain : remain + m
};
Math.length2 = function (x, y) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
};
Math.length3 = function (x, y, z) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2))
};
Math.capVector2 = function (vec, len) {
    var l = Math.length2(vec.x, vec.y);
    return len < l && (vec.x *= len / l, vec.y *= len / l), vec
};
Math.capVector3 = function (vec, len) {
    var l = Math.length3(vec.x, vec.y, vec.z);
    return len < l && (vec.x *= len / l, vec.y *= len / l, vec.z *= len / l), vec
};
Math.normalize2 = function (vec, len) {
    len = len || 1;
    var l = Math.length2(vec.x, vec.y);
    return vec.x *= len / l, vec.y *= len / l, vec
};
Math.normalize3 = function (vec, len) {
    len = len || 1;
    var l = Math.length3(vec.x, vec.y, vec.z);
    return vec.x *= len / l, vec.y *= len / l, vec.z *= len / l, vec
};
Math.clamp = function (v, min, max) {
    return Math.max(Math.min(v, max), min)
};
Math.radAdd = function (a, b) {
    return Math.mod(a + b, Math.PI2)
};
Math.radSub = function (a, b) {
    return Math.mod(a - b, Math.PI2)
};
Math.radRange = function (n) {
    return Math.mod(n, Math.PI2)
};
Math.radDifference = function (fromAngle, toAngle) {
    var diff = (fromAngle - toAngle + Math.PI) % Math.PI2 - Math.PI;
    return diff = diff < -Math.PI ? diff + Math.PI2 : diff
};
Math.cardVals = [0, Math.PI90, Math.PI, 3 * Math.PI90], Math.cardToRad = function (card) {
    return Math.cardVals[card]
};
Math.randomInt = function (low, high) {
    return Math.floor(Math.random() * (high - low) + low)
};
Math.seededRandom = function (min, max) {
    return min = min || 0, max = max || 1, mathSeed = (9301 * mathSeed + 49297) % 233280, min + mathSeed / 233280 * (max - min)
};
Math.seededRandomInt = function (min, max) {
    return Math.floor(Math.seededRandom(min, max))
};
Math.diff = function (a, b, threshold) {
    return b < a ? threshold - a + b : b - a
};

//  _  _  ___  ___  ___ ___ ___ _  _ ___ _____ 
// | || |/ _ \| _ \/ __| __/ __| || |_ _|_   _|
// | __ | (_) |   /\__ \ _|\__ \ __ || |  | |  
// |_||_|\___/|_|_\|___/___|___/_||_|___| |_|  
// [LS] ######## Horseshit ---------------------------------

//Q: What is "horseshit"?
//A: Stuff to do with ads and trackers.

function ga() {
    //yeah screw the tracker
};

function fetchHouseAds() {
    getRequest(parsedUrl.root + "housePromo.json?" + Date.now(), function (err, res) {
        err ? (houseAds = {
            big: [],
            small: [],
            houseAdPercentChance: 100
        }, houseAdsLoaded = true) : (houseAds = JSON.parse(res), houseAdsLoaded = true, function () {
            for (var adIdxs = [], i = 0; i < houseAds.small.length; i++) houseAds.small[i].active && adIdxs.push(i);
            0 < adIdxs.length && (smallAdIdx = adIdxs[Date.now() % adIdxs.length], document.getElementById("houseAd_300x250").src = "img/promo/" + houseAds.small[smallAdIdx].id + houseAds.small[smallAdIdx].imageExt)
        }())
    })
};

function hideBigAd() {
    clearTimeout(bigAdTimeout), document.getElementById("bigAd").style.display = "none", loadBannerAd()
};

//this could go into bs but eh.
parsedUrl.query.adTest && (adTest = true);
var lastBannerLoaded, aipBannerDisplayed = false,
    aipMultisizeBannerDisplayed = false;

function loadBannerAd() {
    if ("none" == document.getElementById("overlay").style.display)
        if (document.getElementById("placeholder_300x250").style.display = "none", document.getElementById("multisizeBannerAdPlaceholder").style.display = "none", inGame && betweenRounds) displayBannerAd("bannerAdContainer", "houseAd_300x250"), ga("send", "event", {
            eventCategory: "House banner ad",
            eventAction: "show",
            eventLabel: houseAds.small[smallAdIdx].label
        });
        else if (inGame) {
            if (true !== playerAccount.hideAds) displayBannerAd("gameAdContainer", tag = "shellshock-io_multisize"), loadMultisizeAd(tag)
        } else {
            // if (true === playerAccount.hideAds && (0 === houseAds.houseAdPercentChance || 0 === houseAds.small.length)) return void (document.getElementById("menuAdContainer").style.display = "none");
            // if (100 * Math.random() <= houseAds.houseAdPercentChance || true === playerAccount.hideAds) return void displayBannerAd("bannerAdContainer", "houseAd_300x250");
            // var tag;
            // displayBannerAd("bannerAdContainer", tag = "shellshock-io_300x250"), aipBannerDisplayed ? aiptag.cmd.display.push(function () {
            //     aipRefreshBannerForTag(tag)
            // }) : (aiptag.cmd.display.push(function () {
            //     aipDisplayBannerForTag(tag)
            // }), aipBannerDisplayed = true)
        }
};

function loadMultisizeAd(tag) { //no
    // console.log("loading multisize ad"), aipMultisizeBannerDisplayed ? aiptag.cmd.display.push(function () {
    //     aipRefreshBannerForTag(tag)
    // }) : (aiptag.cmd.display.push(function () {
    //     aipDisplayBannerForTag(tag)
    // }), aipMultisizeBannerDisplayed = true)
};

function displayBannerAd(parentContainerId, id) { //sod off
    // var el = document.getElementById(parentContainerId);
    // el.style.display = "block";
    // for (var i = 0; i < el.children.length; i++) el.children[i].id == id ? (document.getElementById(id).style.display = "block", lastBannerLoaded = id) : document.getElementById(el.children[i].id).style.display = "none"
};

function hideBannerAd() {
    // hideBannerAdInContainer("bannerAdContainer", "placeholder_300x250")
};

function hideMultisizeBannerAd() {
    // hideBannerAdInContainer("gameAdContainer", "multisizeBannerAdPlaceholder"), aiptag.cmd.display.push(function () {
    //     aipDisplayTag.destroy("shellshock-io_multisize")
    // })
};

function hideBannerAdInContainer(parentContainerId, placeholderId) {
    // for (var el = document.getElementById(parentContainerId), i = 0; i < el.children.length; i++) document.getElementById(el.children[i].id).style.display = "none";
    // document.getElementById(placeholderId).style.display = "block"
};

function showBannerAd() {
    // showBannerAdWithPlaceholder("placeholder_300x250")
};

function showBannerAdWithPlaceholder(placeholderId) {
    // document.getElementById(placeholderId).style.display = lastBannerLoaded ? (document.getElementById(lastBannerLoaded).style.display = "block", "none") : "block"
};

function aipDisplayBannerForTag(tag) {
    try {
        aipDisplayTag.display(tag)
    } catch (e) {
        console.log(e)
    }
};

function aipRefreshBannerForTag(tag) {
    // try {
    //     aipDisplayTag.refresh(tag)
    // } catch (e) {
    //     console.log(e)
    // }
};

function playVideoAd() { //no thanks
    // if (true !== playerAccount.hideAds) {
    //     0,
    //         false,
    //         console.log("AIP preroll"),
    //         showDarkOverlay(),
    //         aiptag.cmd.player.push(function () {
    //             try {
    //                 aipPrerollPlayer.startPreRoll()
    //             } catch (e) {
    //                 console.log(e)
    //             }
    //         }),
    //         localStorage.setItem("lastPreRoll", Date.now())
    // }
    // else afterVideoAdComplete()
};

function isTimeToPlayVideoAd() {
    if (true === playerAccount.hideAds) return false;
    var lastPreRoll = getStoredNumber("lastPreRoll", Date.now()),
        timeout = 42e4;
    return adTest && (timeout = 2e3), 1 < timesPlayed && 1 < deaths && Date.now() > lastPreRoll + timeout
}

function setApplixirPopup(show) {
    var applixirPopup = document.getElementById("applixirPopup"),
        applixirParentFrame = document.getElementById("applixir_parentFrame");
    if (true === show) {
        applixirPopup.classList.remove("hideme");
        var frameSrc = "app_nugget/applixir.html?firebaseId=" + playerAccount.firebaseId;
        frameSrc += "&reward=nugget", applixirParentFrame.src = frameSrc
    } else applixirPopup.classList.add("hideme"), applixirParentFrame.src = "about:blank"
};

function showSmallAd() { //no
    // loadBannerAd(), swiftShaderCheck()
};


//  _    ___   _   ___ ___ _  _  ___ 
// | |  / _ \ /_\ |   \_ _| \| |/ __|
// | |_| (_) / _ \| |) | || .` | (_ |
// |____\___/_/ \_\___/___|_|\_|\___|
// [LS] ######## Loading ---------------------------------

function loadResources(scene, onComplete) {
    devlog("loadResources");
    Sounds = {}, loadMaterials(scene),
        function (scene, onComplete) {
            var options = {
                spatialSound: true,
                distanceModel: "exponential",
                rolloffFactor: 1
            },
                loadsComplete = 0;

            function catComplete() {
                33 == ++loadsComplete && onComplete()
            }
            Sounds.eggk47 = {
                fire: new BABYLON.Sound("", "sound/eggk47/fire.mp3", scene, catComplete, options),
                dryFire: new BABYLON.Sound("", "sound/eggk47/dry fire.mp3", scene, catComplete, options),
                cycle: new BABYLON.Sound("", "sound/eggk47/full cycle.mp3", scene, catComplete, options),
                insertMag: new BABYLON.Sound("", "sound/eggk47/insert mag.mp3", scene, catComplete, options),
                removeMag: new BABYLON.Sound("", "sound/eggk47/remove mag.mp3", scene, catComplete, options)
            }, Sounds.dozenGauge = {
                fire: new BABYLON.Sound("", "sound/dozenGauge/fire.mp3", scene, catComplete, options),
                open: new BABYLON.Sound("", "sound/dozenGauge/open.mp3", scene, catComplete, options),
                load: new BABYLON.Sound("", "sound/dozenGauge/load.mp3", scene, catComplete, options),
                close: new BABYLON.Sound("", "sound/dozenGauge/close.mp3", scene, catComplete, options)
            }, Sounds.csg1 = {
                fire: new BABYLON.Sound("", "sound/csg1/fire.mp3", scene, catComplete, options),
                pullAction: new BABYLON.Sound("", "sound/csg1/pull action.mp3", scene, catComplete, options),
                releaseAction: new BABYLON.Sound("", "sound/csg1/release action.mp3", scene, catComplete, options)
            }, Sounds.cluck9mm = {
                fire: new BABYLON.Sound("", "sound/cluck9mm/fire.mp3", scene, catComplete, options),
                removeMag: new BABYLON.Sound("", "sound/cluck9mm/remove mag.mp3", scene, catComplete, options),
                insertMag: new BABYLON.Sound("", "sound/cluck9mm/insert mag.mp3", scene, catComplete, options)
            }, Sounds.rpegg = {
                fire: new BABYLON.Sound("", "sound/rpegg/rocketfire.mp3", scene, catComplete, options),
                fly: new BABYLON.Sound("", "sound/rpegg/rocketfly.mp3", scene, catComplete, options),
                explode: new BABYLON.Sound("", "sound/rpegg/rockethit.mp3", scene, catComplete, options),
                load: new BABYLON.Sound("", "sound/rpegg/rocketload.mp3", scene, catComplete, options),
                poof: new BABYLON.Sound("", "sound/rpegg/rocketpoof.mp3", scene, catComplete, options),
                denyFire: new BABYLON.Sound("", "sound/rpegg/rocketdeny.mp3", scene, catComplete, options)
            }, Sounds.hammerClick = new BABYLON.Sound("", "sound/hammerClick.mp3", scene, catComplete), Sounds.ammo = new BABYLON.Sound("", "sound/ammo.mp3", scene, catComplete), Sounds.shellBurst = new BABYLON.Sound("", "sound/shellBurst.mp3", scene, catComplete, options), Sounds.hit = new BABYLON.Sound("", "sound/hit.mp3", scene, catComplete, options), Sounds.endRound = new BABYLON.Sound("", "sound/rooster.mp3", scene, catComplete), Sounds.grenade = {
                explode: new BABYLON.Sound("", "sound/grenade.mp3", scene, catComplete, options),
                beep: new BABYLON.Sound("", "sound/grenadeBeep.mp3", scene, catComplete, options),
                pin: new BABYLON.Sound("", "sound/grenadePin.mp3", scene, catComplete, options)
            }, Sounds.death = [];
            for (var i = 1; i < 11; i++) Sounds.death.push(new BABYLON.Sound("", "sound/death/scream" + i + ".mp3", scene, catComplete, options))
        }(scene, function () {
            ! function (scene, onComplete) {
                loadMeshes(scene, ["egg", "gun_eggk47", "gun_csg1", "gun_cluck9mm", "gun_dozenGauge", "gun_rpegg", "munitions", "muzzleFlash", "items", "reticle"], null, onComplete)
            }(scene, function () {
                ! function (scene, onComplete) {
                    mapMeshes = [null];
                    var barrier = BABYLON.MeshBuilder.CreateBox("SPECIAL.barrier.full.verysoft", {
                        size: 1
                    }, scene);
                    (mat = new BABYLON.StandardMaterial).diffuseColor = BABYLON.Color3.Red(), mat.emissiveColor = BABYLON.Color3.Red(), mat.specularColor = BABYLON.Color3.Black(), mat.wireframe = true, barrier.material = mat, barrier.setEnabled(false), mapMeshes.push(barrier);
                    for (var shape = [], i = 0; i <= 1; i += .125) {
                        var a = -Math.PI / 2 + Math.PI * i,
                            x = Math.cos(a),
                            y = .5 * Math.sin(a + .05) + .5;
                        x = .25 * Math.pow(x, 1.3), y = .6 * Math.pow(y, 1.3) - .48, shape.push(new BABYLON.Vector3(x, y, 0))
                    }
                    var mat, egg = BABYLON.MeshBuilder.CreateLathe("SPECIAL.spawn-blue.none", {
                        shape: shape,
                        tessellation: 12
                    }, scene);
                    (mat = new BABYLON.StandardMaterial).diffuseColor = new BABYLON.Color3(0, .5, 1), mat.specularColor = new BABYLON.Color3(.1, .2, .4), mat.specularPower = 8, egg.material = mat, egg.setEnabled(false), mapMeshes.push(egg), egg = BABYLON.MeshBuilder.CreateLathe("SPECIAL.spawn-red.none", {
                        shape: shape,
                        tessellation: 12
                    }, scene), (mat = new BABYLON.StandardMaterial).diffuseColor = new BABYLON.Color3(1, .25, .25), mat.specularColor = new BABYLON.Color3(.4, .3, .3), mat.specularPower = 8, egg.material = mat, egg.setEnabled(false), mapMeshes.push(egg), loadMeshes(scene, ["map"], function (mesh) {
                        mesh.parent ? mesh.freezeWorldMatrix() : mapMeshes.push(mesh)
                    }, function () {
                        for (var i = 1; i < mapMeshes.length; i++) {
                            var mesh = mapMeshes[i].getChildMeshes()[0];
                            mesh && (mapMeshes[i].colliderMesh = mesh)
                        }
                        onComplete()
                    })
                }(scene, function () {
                    onComplete()
                })
            })
        })
};

function loadMaterials(scene) {
    var mat;
    if ((mat = new BABYLON.StandardMaterial("bullet", scene)).emissiveColor = new BABYLON.Color3(1, 1, 1), shadowGen) {
        var definesList = ["#define RECEIVESHADOWS"];
        engineCaps.textureFloat && definesList.push("#define SHADOWFULLFLOAT")
    } else definesList = [];
    definesList.push("#define DIRT"), mat = new BABYLON.ShaderMaterial("map", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor"],
        defines: definesList
    }), shadowGen && (mat.setTexture("shadowSampler", shadowGen.getShadowMapForRendering()), mat.setMatrix("shadowLightMat", shadowGen.getTransformMatrix()), mat.setVector3("shadowParams", shadowGen.getDarkness(), shadowGen.getShadowMap().getSize().width, shadowGen.bias)), mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor)
    }, (mat = new BABYLON.ShaderMaterial("mapNoShadow", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor"],
        defines: ["#define DIRT"]
    })).onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor)
    }, (mat = new BABYLON.ShaderMaterial("standard", scene, "standard", {
        attributes: ["position", "normal", "color", "uv", BABYLON.VertexBuffer.MatricesIndicesKind, BABYLON.VertexBuffer.MatricesWeightsKind],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "colorMult"],
        defines: ["#define COLORMULT"]
    })).onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        if (effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor), effect.setColor3("colorMult", mesh.colorMult || BABYLON.Color3.White()), mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            var matrices = mesh.skeleton.getTransformMatrices(mesh);
            matrices && effect && effect.setMatrices("mBones", matrices)
        }
    }, (mat = new BABYLON.ShaderMaterial("standardInstanced", scene, "standard", {
        attributes: ["position", "normal", "color", "uv", "world0", "world1", "world2", "world3"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor"],
        defines: ["#define INSTANCES"]
    })).onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor)
    }, (mat = new BABYLON.ShaderMaterial("eggShell", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "hp", "cameraPosition", "outlineColor", "colorMult", "stampOffset"],
        defines: ["#define EGGSHELL"]
    })).onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor), effect.setFloat("hp", mesh.player.hp / 100), effect.setColor3("colorMult", mesh.colorMult || BABYLON.Color3.White()), effect.setFloat3("cameraPosition", scene.activeCamera.globalPosition.x, scene.activeCamera.globalPosition.y, scene.activeCamera.globalPosition.z), effect.setColor4("outlineColor", mesh.outlineColor, mesh.outlineColor.a), effect.setFloat2("stampOffset", mesh.stampU, mesh.stampV)
    }, (mat = new BABYLON.ShaderMaterial("emissive", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "emissiveColor"],
        defines: ["#define FLASH"]
    })).onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor), effect.setColor3("emissiveColor", mesh.emissiveColor || BABYLON.Color3.Black())
    }, (mat = new BABYLON.StandardMaterial("wireframe", scene)).wireframe = true, (mat = new BABYLON.StandardMaterial("normalBackface", scene)).diffuseColor = new BABYLON.Color3(.5, .5, .5), mat.ambientColor = new BABYLON.Color3(.5, .5, .5), mat.specularColor = new BABYLON.Color3(0, 0, 0), mat.backFaceCulling = false, mat.twoSidedLighting = true, (mat = new BABYLON.StandardMaterial("muzzleFlash", scene)).emissiveColor = BABYLON.Color3.White(), (mat = new BABYLON.StandardMaterial("ui", scene)).disableLighting = true, mat.emissiveColor = BABYLON.Color3.White(), mat.fogEnabled = false
};

function loadMeshes(scene, meshNames, onMeshLoaded, onComplete) {
    for (var meshCount = meshNames.length, that = this, mat = scene.getMaterialByName("standard"), numEggs = 0, numHands = 0, idx = 0; idx < meshCount; idx++) {
        var rootUrl = "models/",
            path = meshNames[idx] + ".babylon";
        if ("undefined" == typeof window) {
            var data = fs.readFileSync(path, "utf8");
            path = "data:" + (data = data.replace(/\r?\n|\r/g, "")), rootUrl = ""
        }
        BABYLON.SceneLoader.ImportMesh("", rootUrl, path, scene, function (meshes, partcileSystems, skeletons) {
            try {
                for (var m = 0; m < meshes.length; m++) {
                    var mesh = meshes[m];
                    // devlog(mesh.name);
                    "egg" == mesh.name && numEggs++, "hands" == mesh.name && numHands++, !duplicateWarningIssued && (1 < numEggs || 1 < numHands) && (duplicateWarningIssued = true, alert("Duplicate egg and/or hand models detected.\n\nOpen the weapon models in Blender and make sure egg/hands layers are turned off, then re-export.")), mesh.setMaterial && mesh.setMaterial(mat), mesh.setEnabled(false), mesh.isPickable = false, onMeshLoaded && onMeshLoaded(mesh)
                }
                0 == --meshCount && onComplete && onComplete.call(that)
            } catch (e) {
                console.log(e)
            }
        })
    }
};


//   ___   _   __  __ ___   ___   _ ___   ___ ___  _  __
//  / __| /_\ |  \/  | __| / / | | |_ _| |_ _|   \| |/ /
// | (_ |/ _ \| |\/| | _| / /| |_| || |   | || |) | ' < 
//  \___/_/ \_\_|  |_|___/_/  \___/|___| |___|___/|_|\_\
// [LS] ######## Game/UI stuff idk ---------------------------------

function make3DArray(width, height, depth, initVal) {
    for (var arr = Array(width), x = 0; x < width; x++) {
        arr[x] = Array(height);
        for (var y = 0; y < height; y++) {
            arr[x][y] = Array(depth);
            for (var z = 0; z < depth; z++) arr[x][y][z] = initVal || {}
        };
    };
    return arr;
};

function isBadWord(word) {
    var str = (word = " " + word + " ").toLowerCase().replace(/[^a-zA-Z0-9|!\|@|$|;|]/g, "").replace(/6|g/g, "9").replace(/b/g, "6").replace(/\||l|i|1|;|/g, "!").replace(/e/g, "3").replace(/a|@/g, "4").replace(/o/g, "0").replace(/s|\$/g, "5").replace(/t/g, "7").replace(/z/g, "2").replace(/7h3|my|y0ur|7h3!r|h!5|h3r/g, ""),
        i1 = str.search(/( 94y | cum| 455 )/);
    str.replace(/ /g, "");
    var reg = /(4fr!c4n|kn336r0|5ch00!5h007|73rr0r!5t|||qu33r|d!ck|w4nk|p!55|7357!c|735735|64!!5|nu75|nu72|j3w|k!k3|r374r|4u7!5|d0wn55|6006|8d|p0rn|5w4!!0w|347m3|347my|d!k|0r4!|5p0093|fuk|j!2|5u!c!d|m4573r6|5p0063|5p3rm|p3nu5|pu55y|6u7753x|fux|6u77h0!3|4n4!|4nu5|k!!!b!4ck5|murd3rb!4ck5|h!7!3r|w3764ck|49!n4|94y|455h0!3|5uck|j3w|5p!c|ch!nk|n!994|n!993|n!663|n!994|n!664|5h!7|6!7ch|fuck|cun7|kkk|wh0r3|f49|7w47|p3n!|r4p3w0m|r4p39!r|r4p!57|r4p3r|r4p!n|c0ck|7!75|900k|d!ckh34d)/,
        i2 = str.search(reg);
    str.replace(/(.)(?=\1)/g, "");
    var i3 = str.search(reg);
    return -1 < i1 || -1 < i2 || -1 < i3
};

function openGameMenu() {
    escPressed = false, document.pointerLockElement ? document.exitPointerLock() : showGameMenu()
};

function showGameMenu() {
    var helpOpen = "none" != document.getElementById("help").style.display,
        menuEl = document.getElementById("gameMenu");
    helpOpen || (document.getElementById("tipContainer").style.display = "block", document.getElementById("gameplayTip").innerHTML = getRandomGameplayTip()), hideSpinner(), hideDarkOverlay(), menuEl.style.display = "block", showCornerButtons(), removeCanvasListeners(), document.getElementById("grenadeThrowContainer").style.visibility = "hidden", document.getElementById("weaponBox").style.display = "none", document.getElementById("health").style.display = "none", document.getElementById("killTicker").style.display = "none", document.getElementById("inGameAd").style.display = "block", reticle.hide(), timeout.set(function () {
        // loadBannerAd()
    }, 1e3)
};

function hideGameMenu() {
    me && (document.getElementById("gameMenu").style.display = "none", document.getElementById("gameSummary").style.visibility = "hidden", document.getElementById("ffaFinal").style.display = "none", document.getElementById("teamFinal").style.display = "none", timedGame && betweenRounds || (document.getElementById("deathBox").style.display = "none", document.getElementById("weaponBox").style.display = "block", document.getElementById("health").style.display = "block", document.getElementById("killTicker").style.display = "block", document.getElementById("playerList").style.display = "block", chatting && chatInEl.focus(), doFirstPersonCamera(), reticle.show()), hideMultisizeBannerAd(), document.getElementById("gameAdContainer").style.display = "none", document.getElementById("cornerButtons").style.display = "none", addCanvasListeners())
};

function showContinueDialog() {
    hideGameMenu(), document.getElementById("gameClock").style.display = "none", openAlertDialog("OVER-EASY", "Continue to the next round?", {
        label: "<h3> YES!&nbsp;</h3>",
        width: "8em",
        height: "2.5em",
        onclick: continueToSummary
    }, {
        label: "<h3>No</h3>",
        width: "4em",
        height: "2.5em",
        onclick: showMainMenuConfirm
    })
};

// [LS] Summary
function continueToSummary() {
    closeAlertDialog(), isTimeToPlayVideoAd() ? (playVideoAd(), document.exitPointerLock()) : (openGameMenu(), showGameSummary(), resetGame())
};
function showGameSummary() {
    document.getElementById("gameSummary").style.visibility = "visible";
    document.getElementById("playerList").style.display = "none";
};
function prepareGameSummary() {
    for (var playerIdxs = [
        [],
        [],
        []
    ], i = 0; i < playerLimit; i++) players[i] && playerIdxs[players[i].team].push(i);
    for (var team = 0; team < 3; team++) {
        teamSummaryEls[team].style.display = "none", playerIdxs[team].sort(function (a, b) {
            var diff = players[b].score - players[a].score;
            return 0 == diff && 0 == (diff = players[a].kills - players[b].kills) && (diff = players[a].deaths - players[b].deaths), diff
        });
        var rowsEl = teamSummaryEls[team];
        for (i = 0; i < playerIdxs[team].length; i++) {
            var player = players[playerIdxs[team][i]];
            if (player) {
                var row = rowsEl.children[i];
                row.style.display = "flex", player.id == meId ? row.style.color = "#ff0" : row.style.color = teamColors.text[team], row.children[0].innerText = i + 1, row.children[1].innerText = player.name, row.children[2].innerText = player.score, row.children[3].innerText = player.kills, row.children[4].innerText = player.deaths, row.children[5].innerText = player.bestGameStreak
            }
        }
        for (; i < rowsEl.children.length;) rowsEl.children[i].style.display = "none", i++
    }
    var teamScores = getTeamScores();
    if (gameType == GameType.teams) {
        var losingTeam = 1 == (teamScores.leader || lastLeadingTeam) ? 2 : 1;
        teamSummaryEls[losingTeam].parentNode.appendChild(teamSummaryEls[losingTeam]);
        for (team = 1; team < 3; team++) teamSummaryEls[team].style.display = "flex", document.getElementById("teamScore" + team).innerText = teamScores.score[team];
        document.getElementById("teamFinal").style.display = "flex", document.getElementById("ffaFinal").style.display = "none"
    } else teamSummaryEls[0].style.display = "flex", document.getElementById("teamScore0").innerText = teamScores.score[0], document.getElementById("teamFinal").style.display = "none", document.getElementById("ffaFinal").style.display = "flex"
};

// [LS] Ingame stuff
startGame = function () {
    //no thanks!
    // var oneSignalBell = document.getElementById("onesignal-bell-container");
    // oneSignalBell && (oneSignalBell.style.display = "none");
    document.getElementById("showBuyPassDialogButton").classList.add("hideme"), document.getElementById("upgradeIndicator").classList.add("ingame"), players = [], {}, oldClockSeconds = viewingPlayer = me = respawnTime = null, grenadePowerUp = betweenRounds = !(escPressed = true), lastTimeStamp = performance.now(), 0, ping = 0, bestOverallStreak = deaths = kills = fpsAverage = fpsSamples = fpsTotal = pingSamples = pingTotal = highestPing = 0, gameStartTime = Date.now(), Date.now() + 1e3, engine.clear(BABYLON.Color3.Black()), engine.stopRenderLoop(), gameScene = new BABYLON.Scene(engine), settings.autoDetail || (gameScene.shadowsEnabled = settings.shadowsEnabled), gameScene.autoClear = false, gameScene.autoClearDepthAndStencil = false, settings.autoDetail && enableAutoDetail(), gameScene.ambientColor = new BABYLON.Color3(.2, .2, .2), gameScene.fogMode = BABYLON.Scene.FOGMODE_EXP, gameScene.fogColor = new BABYLON.Color4(.5, .55, .6, 1), gameScene.fogDensity = .025, gameScene.clearColor = BABYLON.Color3.Black(), (shadowLight = new BABYLON.DirectionalLight("", new BABYLON.Vector3(0, -1, 0), gameScene)).lightmapMode = BABYLON.Light.LIGHTMAP_SHADOWSONLY, shadowLight.intensity = 1.2, shadowLight.autoUpdateExtends = false, shadowLight.shadowMinZ = .05, shadowLight.shadowMaxZ = 40, shadowLight.shadowFrustumSize = 15, (shadowGen = new BABYLON.ShadowGenerator(1024, shadowLight)).forceBackFacesOnly = true, gameScene.sunLight = new BABYLON.HemisphericLight("sunLight", new BABYLON.Vector3(0, -1, 0), gameScene), gameScene.sunLight.intensity = .8, camera = new BABYLON.TargetCamera("camera", BABYLON.Vector3.Zero(), gameScene), gameScene.activeCameras.push(camera), camera.maxZ = 100, camera.fov = 1.25, camera.minZ = .05, (uiCamera = new BABYLON.FreeCamera("uiCamera", new BABYLON.Vector3(0, 0, -1), gameScene)).mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA, uiCamera.layerMask = 536870912, uiCamera.autoClear = false, gameScene.activeCameras.push(uiCamera), nameTexture = new BABYLON.DynamicTexture("", 2048, gameScene, true, 2), (nameSprites = new BABYLON.SpriteManager("", "", 24, {
        width: 512,
        height: 256
    }, gameScene)).fogEnabled = false, nameSprites.texture = nameTexture, window.onfocus = function () {
        lastTimeStamp = performance.now()
    }, window.onblur = function () { }, document.onpointerlockchange = function () {
        if (me)
            if (document.pointerLockElement) hideGameMenu();
            else {
                if (lastKey = null, me.controlKeys = 0, me.releaseTrigger(), escPressed) {
                    var output = new Comm.output(1);
                    output.packInt8(CommCode.pause), ws.send(output.buffer), setRespawnTime(5), timeout.set(function () {
                        me.removeFromPlay()
                    }, 3e3)
                }
                "none" == document.getElementById("overlay").style.display && showGameMenu()
            } escPressed = true
    },
        function () {
            chatOutEl.innerHTML = "", 1 == settings.enableChat && (initChatIn(), chatOutEl.style.display = "block", chatInEl.style.display = "block");
            killEl.innerHTML = "", chatOutEl.value = "", hideMultisizeBannerAd(), document.getElementById("gameAdContainer").style.display = "none", document.getElementById("killBox").style.display = "none", document.getElementById("deathBox").style.display = "none", document.getElementById("scopeBorder").style.display = "none", document.getElementById("help").style.display = "block", document.getElementById("tipContainer").style.display = "none", document.getElementById("goButton").className = "ssbutton green", document.getElementById("goButtonLabel").innerHTML = " PLAY!&nbsp;", document.getElementById("gameClock").style.display = "none", document.getElementById("gameClock").style.fontSize = "2em", document.getElementById("gameSummary").style.visibility = "hidden", document.getElementById("ffaFinal").style.display = "none", document.getElementById("teamFinal").style.display = "none", setTeamButton(), console.log("resetGameUI")
        }();
    var helpEl = document.getElementById("helpControls");
    helpEl.innerHTML = "";
    var helpSlots = {
        up: null,
        down: null,
        left: null,
        right: null,
        jump: null,
        fire: null,
        scope: null,
        reload: null,
        weapon: null,
        grenade: null
    };
    for (var k in inputToControlMap) helpSlots[inputToControlMap[k]] = k;
    var count = 0;
    for (var k in helpSlots) helpEl.innerHTML += helpSlots[k], count++, helpEl.innerHTML += 4 <= count ? "<br>" : " ";
    if (gameType != GameType.teams) {
        document.getElementById("teamButtonContainer").style.display = "none";
        document.getElementById("goButton").style.height = "6.5em";
    } else {
        document.getElementById("teamButtonContainer").style.display = "block";
        document.getElementById("goButton").style.height = "4em";
    };
    document.body.style.overflow = "hidden";
    loadResources(gameScene, onLoadingComplete);
};

function resetGame() {
    for (var i = 0; i < playerLimit; i++) {
        var player = players[i];
        player && (player.removeFromPlay(), player.score = 0, player.kills = 0, player.deaths = 0, player.streak = 0, player.bestGameStreak = 0)
    };
};

function setRespawnTime(sec) {
    respawnTime = Math.max(sec, respawnTime);
    var button = document.getElementById("goButton");
    button.className = "ssbutton grey";
    var label = document.getElementById("goButtonLabel");
    label.innerHTML = respawnTime, respawnInterval && interval.clear(respawnInterval), respawnInterval = interval.set(function () {
        respawnTime--, (label.innerHTML = respawnTime) <= 0 && inGame && (respawnTime = -1, interval.clear(respawnInterval), button.className = "ssbutton green", label.innerHTML = " PLAY!&nbsp;", doMapOverviewCamera())
    }, 1e3)
};

function requestRespawn() {
    canvas.requestPointerLock();
    var output = new Comm.output(1);
    output.packInt8(CommCode.requestRespawn);
    ws.send(output.buffer);
    console.log("respawn() requests respawn from server");
    document.getElementById("help").style.display = "none";
};

function onLoadingComplete() {
    console.log("onLoadingComplete"); Collider.init(gameScene),
        function (onComplete) {
            function complete() {
                hideSpinner(), onComplete()
            }
            showSpinner("Building Map", "Hold on!"),
                function (callback) {
                    minMap = playOffline ? JSON.parse(localStorage.getItem("mapBackup")) : (console.log("MAP IDX: " + mapIdx, playOffline), minMaps[mapIdx]);
                    devlog("minMap:", minMap);
                    minMap.sun ? gameScene.sunLight.direction = new BABYLON.Vector3(minMap.sun.direction.x, minMap.sun.direction.y, minMap.sun.direction.z) : gameScene.sunLight.direction = new BABYLON.Vector3(.2, 1, .1);
                    (SPS = new BABYLON.SolidParticleSystem("SPS", gameScene, {
                        updatable: true
                    })).computeParticleColor = false, SPS.computeParticleTexture = false, SPS.computeParticleRotation = false, SPS.recomputeNormals = false;
                    var meshIndex = function (errorFunc) {
                        (map = {
                            width: minMap.width,
                            height: minMap.height + 1,
                            depth: minMap.depth,
                            surfaceArea: minMap.surfaceArea
                        }).data = make3DArray(map.width, map.height, map.depth);
                        for (var meshIndex = {}, i = 1; i < mapMeshes.length; i++) {
                            var mesh = mapMeshes[i];
                            meshIndex[mesh.name] = i
                        }
                        var meshesNotFound = {};
                        "undefined" == typeof window && (spawnPoints = [
                            [],
                            [],
                            []
                        ]), Object.keys(minMap.data).forEach(function (meshName) {
                            var meshData = minMap.data[meshName],
                                meshIdx = meshIndex[meshName],
                                mesh = mapMeshes[meshIdx];
                            if (meshIdx) {
                                var colliderMesh, colliderPrecise, colliderChildren, fields = meshName.split(".");
                                devlog("mesh, theme", mesh, fields);
                                if (mesh.theme = fields[0], mesh.name = fields[1], mesh.colliderType = fields[2], mesh.softness = fields[3], "undefined" == typeof window && "SPECIAL" == mesh.theme && mesh.name.startsWith("spawn")) return void Object.values(meshData).forEach(function (cell) {
                                    spawnPoints[0].push({
                                        x: cell.x,
                                        y: cell.y,
                                        z: cell.z
                                    }), "spawn-blue" == mesh.name ? spawnPoints[Team.blue].push({
                                        x: cell.x,
                                        y: cell.y,
                                        z: cell.z
                                    }) : spawnPoints[Team.red].push({
                                        x: cell.x,
                                        y: cell.y,
                                        z: cell.z
                                    })
                                });
                                switch (mesh.colliderType) {
                                    case "full":
                                        colliderMesh = Collider.fullCollisionMesh, colliderChildren = colliderPrecise = false;
                                        break;
                                    case "wedge":
                                        colliderMesh = Collider.wedgeCollisionMesh, colliderChildren = !(colliderPrecise = true);
                                        break;
                                    case "iwedge":
                                        colliderMesh = Collider.iwedgeCollisionMesh, colliderChildren = !(colliderPrecise = true);
                                        break;
                                    case "ladder":
                                        colliderMesh = mesh.colliderMesh, colliderChildren = colliderPrecise = false;
                                        break;
                                    case "aabb":
                                        colliderMesh = mesh.colliderMesh, colliderChildren = !(colliderPrecise = false);
                                        break;
                                    case "obb":
                                        colliderMesh = mesh.colliderMesh, colliderChildren = colliderPrecise = true
                                }
                                Object.values(meshData).forEach(function (cell) {
                                    var rx = cell.rx * Math.PI90 || 0,
                                        ry = cell.ry * Math.PI90 || 0,
                                        rz = cell.rz * Math.PI90 || 0;
                                    map.data[cell.x][cell.y][cell.z] = {
                                        item: void 0,
                                        mesh: mesh,
                                        idx: meshIdx,
                                        colliderMesh: colliderMesh,
                                        colliderPrecise: colliderPrecise,
                                        colliderChildren: colliderChildren,
                                        colliderMatrix: BABYLON.Matrix.RotationYawPitchRoll(-ry, -rx, -rz),
                                        rx: rx,
                                        ry: ry,
                                        rz: rz
                                    }
                                })
                            } else meshesNotFound[meshName] = true
                        });
                        var str = "";
                        return Object.keys(meshesNotFound).forEach(function (name) {
                            str += name + "\n"
                        }), "" != str && errorFunc(str), meshIndex
                    }(function (str) {
                        alert("The following map meshes were not found:\n\n" + str + "\nTry clearing your cache and reload the page!")
                    }),
                        meshNames = Object.keys(minMap.data);
                    var nextFunction = function addMeshToMap(keyIdx) {
                        if (keyIdx == meshNames.length) return void callback();
                        var meshName = meshNames[keyIdx];
                        var meshData = minMap.data[meshName];
                        var meshIdx = meshIndex[meshName];
                        var mesh = mapMeshes[meshIdx];
                        var pct = Math.floor(keyIdx / meshNames.length * 100);
                        var msgs = ["Laying", "Cracking", "Making omelettes", "Random clucking", "Scratching", "Scrambling", "Roosting", "Beating", "Making bad yolks", "Thinking of egg puns", "Whipping", "Frying", "Poaching", "Doing something REALLY interesting", "Doing your homework, 'cause SOMEONE has to", "What was I doing? Oh, yeah; map!", "Making you wait, just for clucks", "Watching chicken videos"];
                        var msg = msgs[Math.randomInt(0, msgs.length)];
                        showSpinner("Building Map", msg + "... " + pct + "%");
                        var fields = meshName.split(".");
                        mesh.theme = fields[0];
                        mesh.colliderType = fields[2];
                        mesh.softness = fields[3];
                        if ("SPECIAL" != mesh.theme) {
                            var i = 0,
                                meshArr = Object.values(meshData);
                            SPS.addShape(mesh, meshArr.length, {
                                positionFunction: function (particle, idx, shapeIdx) {
                                    var rx = meshArr[i].rx || 0,
                                        ry = meshArr[i].ry || 0,
                                        rz = meshArr[i].rz || 0;
                                    particle.position.x = meshArr[i].x + .5, particle.position.y = meshArr[i].y + .5, particle.position.z = meshArr[i].z + .5, particle.rotation.x = rx * rotInc, particle.rotation.y = ry * rotInc, particle.rotation.z = rz * rotInc, particle.alive = false, i++
                                }
                            })
                        }
                        var nextFunction = addMeshToMap.bind(this, keyIdx + 1);
                        window.requestAnimationFrame(nextFunction)
                    }.bind(this, 0);
                    window.requestAnimationFrame(nextFunction)
                }(function () {
                    showSpinner("Building Map", "Turning on the lights..."), requestAnimationFrame(function (onComplete) {
                        (mapMesh = SPS.buildMesh()).receiveShadows = true, console.log("Casting rays");
                        var w = map.width + 1,
                            h = map.height + 1,
                            d = map.depth + 1,
                            lightMap = make3DArray(w, h, d, 1.5),
                            lightDir = gameScene.sunLight.direction.clone();
                        lightDir.normalize();
                        var lightRay = lightDir.clone();
                        lightRay.scaleInPlace(1e3);
                        var testStep = lightDir.clone();
                        testStep.scaleInPlace(.5),
                            function (width, height, depth, options, callback) {
                                var opt = options || {};
                                opt.step = opt.step || 1, opt.x = opt.x || 0, opt.y = opt.y || 0, opt.z = opt.z || 0;
                                for (var x = opt.x; x < width; x += opt.step)
                                    for (var y = opt.y; y < height; y += opt.step)
                                        for (var z = opt.z; z < depth; z += opt.step) callback(x, y, z)
                            }(map.width + 1, map.height + 1, map.depth + 1, null, function (lmx, lmy, lmz) {
                                var rays = [],
                                    ray = new BABYLON.Ray(new BABYLON.Vector3(lmx, lmy, lmz), lightRay);
                                rays.push(ray);
                                var testPos = new BABYLON.Vector3(lmx, lmy, lmz);
                                testPos.addInPlace(testStep), testPos.addInPlace(testStep);
                                for (var cellsChecked = {}, hits = 0; !(testPos.x < -1 || testPos.x > map.width || testPos.y < -1 || testPos.y > map.height || testPos.z < -1 || testPos.z > map.depth || hits == rays.length);) {
                                    var cx = Math.floor(Math.clamp(testPos.x + 0, 0, map.width - 1)),
                                        cy = Math.floor(Math.clamp(testPos.y + 0, 0, map.height - 1)),
                                        cz = Math.floor(Math.clamp(testPos.z + 0, 0, map.depth - 1)),
                                        checkId = cx + 1e3 * cy + 1e4 * cz;
                                    if (!cellsChecked[checkId]) {
                                        cellsChecked[checkId] = true;
                                        var cell = map.data[cx][cy][cz];
                                        if (cell && cell.idx) {
                                            var cellMesh = mapMeshes[cell.idx];
                                            if ("SPECIAL" != cellMesh.theme) {
                                                for (var ri in cellMesh.rotation.x = cell.rx, cellMesh.rotation.y = cell.ry, cellMesh.rotation.z = cell.rz, cellMesh.position.x = cx + .5, cellMesh.position.y = cy + .5, cellMesh.position.z = cz + .5, cellMesh.computeWorldMatrix(), rays) {
                                                    var ray = rays[ri];
                                                    if (!ray.hit) {
                                                        var pickInfo = ray.intersectsMesh(cellMesh, true);
                                                        pickInfo.hit && (ray.hit = true, hits++)
                                                    }
                                                }
                                                cellMesh.position = BABYLON.Vector3.Zero()
                                            }
                                        }
                                    }
                                    testPos.addInPlace(testStep)
                                }
                                0 < hits && (lightMap[lmx][lmy][lmz] = .2)
                            }), console.log("Applying lightmap");
                        var colors = mapMesh.getVerticesData(BABYLON.VertexBuffer.ColorKind),
                            positions = mapMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);

                        function worker() {
                            self.onmessage = function (e) {
                                e = e.data;
                                for (var samples, sum, i = 0; i < e.positions.length / 3; i++) {
                                    var ix3 = 3 * i,
                                        x = e.positions[ix3],
                                        y = e.positions[ix3 + 1],
                                        z = e.positions[ix3 + 2];
                                    sum = samples = 0, iterateXYZ(Math.min(e.w - 1, x + .6), Math.min(e.h - 1, y + .6), Math.min(e.d - 1, z + .6), {
                                        x: Math.max(0, x - .6),
                                        y: Math.max(0, y - .6),
                                        z: Math.max(0, z - .6)
                                    }, sumItUp);
                                    var l = Math.min(Math.max(sum / samples, .5), 1);
                                    e.colors[4 * i] *= l, e.colors[4 * i + 1] *= l, e.colors[4 * i + 2] *= l, i % 1e3 == 0 && postMessage({
                                        progress: Math.floor(i / (e.positions.length / 3) * 100)
                                    })
                                }

                                function sumItUp(x, y, z) {
                                    var cx = Math.round(x),
                                        cy = Math.round(y),
                                        cz = Math.round(z);
                                    samples++, sum += e.lightMap[cx][cy][cz]
                                }

                                function iterateXYZ(width, height, depth, options, callback) {
                                    var opt = options || {};
                                    opt.step = opt.step || 1, opt.x = opt.x || 0, opt.y = opt.y || 0, opt.z = opt.z || 0;
                                    for (var x = opt.x; x < width; x += opt.step)
                                        for (var y = opt.y; y < height; y += opt.step)
                                            for (var z = opt.z; z < depth; z += opt.step) callback(x, y, z)
                                }
                                postMessage({
                                    colors: e.colors
                                })
                            }
                        }
                        var code = worker.toString();
                        code = code.substring(code.indexOf("{") + 1, code.lastIndexOf("}"));
                        var worker, blob = new Blob([code], {
                            type: "application/javascript"
                        });
                        (worker = new Worker(URL.createObjectURL(blob))).postMessage({
                            colors: colors,
                            positions: positions,
                            lightMap: lightMap,
                            w: w,
                            h: h,
                            d: d
                        }), worker.onmessage = function (m) {
                            if (m.data.hasOwnProperty("progress")) showSpinner("Building Map", "Turning on the lights... " + m.data.progress + "%");
                            else {
                                if (mapMesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, m.data.colors), mapMesh.material = gameScene.getMaterialByName("map"), mapMesh.freezeWorldMatrix(), !noSkybox) {
                                    var skyboxName = minMap.skybox || "default",
                                        skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {
                                            size: 100
                                        }, gameScene);
                                    skybox.infiniteDistance = true;
                                    var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", gameScene);
                                    skyboxMaterial.backFaceCulling = false, skyboxMaterial.fogEnabled = false, skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("img/skyboxes/" + skyboxName + "/skybox", gameScene), skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE, skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0), skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0), skybox.material = skyboxMaterial
                                }
                                onComplete()
                            }
                        }
                    }.bind(this, complete))
                })
        }(onMapComplete)
};

function onMapComplete() {
    document.getElementById("serverAndMapInfo").innerHTML = "Map: " + minMap.name + "<br>Server: " + servers[selectedServer].name;
    try {
        var output;

        scope = new Scope;
        hitIndicator = new HitIndicator;
        reticle = new Reticle;
        gameScene.getMeshByName("muzzleFlash").material = gameScene.getMaterialByName("muzzleFlash");
        gameScene.getMeshByName("bullet").material = gameScene.getMaterialByName("bullet");
        gameScene.getMeshByName("rocket").material = gameScene.getMaterialByName("standardInstanced");
        gameScene.getMeshByName("grenade").material = gameScene.getMaterialByName("emissive");
        gameScene.getMeshByName("ammo").material = gameScene.getMaterialByName("standardInstanced");
        gameScene.getMeshByName("grenadeItem").material = gameScene.getMaterialByName("standardInstanced");
        munitionsManager = new MunitionsManager(gameScene);
        itemManager = new ItemManager;
        (bulletHoleManager = createParticleManager("particles.png", 50, 0, 0, gameScene)).fogEnabled = true;
        bulletHoleManager.addHole = function (f, x, y, z) {
            var s = this.getSprite();
            s.position.x = x, s.position.y = y, s.position.z = z, s.angle = 6.282 * Math.random(), s.cellIndex = f, s.startSize = .03
        };
        (explosionSmokeManager = createParticleManager("particles.png", 300, 1, 1, gameScene)).fogEnabled = true;
        explosionSmokeManager.noAlphaTest = true;
        (explosionFireManager = createParticleManager("particles.png", 300, 1, 1, gameScene)).fogEnabled = true;
        explosionFireManager.blendMode = BABYLON.Engine.ALPHA_ADD;
        (shellFragManager = createParticleManager("particles.png", 400, 3, 6, gameScene)).fogEnabled = true;
        yolkManager = createParticleManager("particles.png", 100, 2, 2, gameScene);
        yolkManager.fogEnabled = true;
        
        if (playOffline) {
            addPlayer({
                id: meId = 0,
                uniqueId: 0,
                name: "Test",
                charClass: 0,
                team: 0,
                primaryWeaponItem: playerAccount.getPrimaryWeapon(),
                secondaryWeaponItem: playerAccount.getSecondaryWeapon(),
                shellColor: 0,
                hatItem: null,
                stampItem: null,
                score: 0,
                kills: 0,
                deaths: 0,
                streak: 0,
                totalKills: 0,
                totalDeaths: 0,
                bestGameStreak: 0,
                bestOverallStreak: 0,
                x: mapTest.x + .5,
                y: mapTest.y - .32,
                z: mapTest.z + .5,
                dx: 0,
                dy: 0,
                dz: 0,
                frame: 0,
                pitch: mapTest.pitch,
                yaw: mapTest.yaw,
                shield: 0,
                hp: 0,
                playing: false,
                weaponIdx: 0,
                controlKeys: 0,
                randomSeed: 0,
                upgradeProductId: void 0 !== playerAccount.upgradeProductId && null !== playerAccount.upgradeProductId ? playerAccount.upgradeProductId : 0
            });

            players[meId].hp = 100;
            doFirstPersonCamera();
            startRendering();
            addCanvasListeners();
        } else {
            mapOverview = true;
            ws.onmessage = LegacyShellOnMessage;

            (output = new Comm.output(1)).packInt8(CommCode.clientReady);
            ws.send(output.buffer);
            (output = new Comm.output(1)).packInt8(CommCode.ping);
            pingStartTime = Date.now();
            ws.send(output.buffer);
            
            // setTimeout(unbloated2, 3e4);
        };
    } catch (e) {
        console.log(e)
    }
};

function doMapOverviewCamera() {
    devlog("doMapOverviewCamera");
    camera.parent = null;
    camera.position = new BABYLON.Vector3(0, map.height + 1, 0);
    camera.lockedTarget = null;
    camera.setTarget(new BABYLON.Vector3(map.width / 2, map.height / 4, map.depth / 2));
    mapOverview = true;
};

function doFirstPersonCamera(player) {
    devlog("doFirstPersonCamera", player);
    camera.position = BABYLON.Vector3.Zero();
    camera.rotation = BABYLON.Vector3.Zero();
    camera.rotationQuaternion = BABYLON.Quaternion.Zero();
    camera.parent = player ? player.actor.eye : me.actor.eye, camera.lockedTarget = null, mapOverview = false;
};

function startRendering() {
    hideDarkOverlay();
    document.getElementById("game").style.display = "block";
    document.getElementById("readouts").style.display = "block";
    document.getElementById("homeButton").style.display = "inline-block";
    document.getElementById("friendsButton").style.display = "inline-block";
    resize();
    captureKeys();
    mapOverview && doMapOverviewCamera();

    gameScene.registerBeforeRender(function () {
        (function () {
            var fps = engine.getFps();
            if (fpsTotal += fps, ++fpsSamples % 10 == 0) {
                fpsAverage = fpsTotal / fpsSamples;
                var fpsEl = document.getElementById("FPS");
                fpsEl.innerText = Math.floor(fps + .5);
                var barEl = document.getElementById("healthBar"),
                    hpEl = document.getElementById("healthHp"),
                    r = 5 - viewingPlayer.hp / 20;
                if (barEl.setAttribute("stroke-dashoffset", 6.2832 * r + "vh"), hpEl.innerText = Math.floor(viewingPlayer.hp), timedGame) {
                    var clockEl = document.getElementById("gameClock"),
                        date = new Date(roundEndTime - Date.now() + 1e3);
                    if (0 <= date) {
                        var minutes = date.getMinutes(),
                            seconds = date.getSeconds();
                        if (seconds != oldClockSeconds) {
                            var size = 2;
                            0 == minutes && seconds < 11 && (size = 2 + (11 - seconds) / 4), clockEl.style.fontSize = size + "em", clockEl.innerText = minutes + ":" + (seconds < 10 ? "0" : "") + seconds, oldClockSeconds = seconds
                        }
                    } else clockEl.innerText = "0:00"
                }
            }
            var currentTimeStamp = performance.now();
            10 < pingSamples && (highestPing = Math.max(highestPing, ping));
            for (; lastTimeStamp < currentTimeStamp; ) {
                lastTimeStamp += 1e3 / 60;
                
                if (freezeFrame) {
                    me.update(1);
                    me.actor.update(1);
                } else {
                    for (var i = 0; i < players.length; i++) {
                        var player = players[i];
                        if (player) {
                            player.chatLineCap = Math.min(player.chatLineCap + 1 / 120, 3);
                            if (player.playing) {
                                player.update(1);
                                player.actor.handsToWeaponSkeleton();
                                if (player.actor) {
                                    player.actor.update(1);
                                }
                            }
                        }
                    }
                }
                
                if (me) {
                    me.stateBuffer[me.stateIdx] = {
                        delta: 1,
                        yaw: me.yaw,
                        fire: false,
                        jumping: me.jumping,
                        climbing: me.climbing,
                        x: me.x,
                        y: me.y,
                        z: me.z,
                        dx: me.dx,
                        dy: me.dy,
                        dz: me.dz,
                        controlKeys: me.controlKeys
                    };
                    
                    if (me.stateIdx % FramesBetweenSyncs === 0 && ws.readyState === ws.OPEN && me.hp > 0 && !freezeFrame) {
                        serverSync();
                    };
                    
                    hitIndicator.update(1);
                    reticle.update(1);
                    
                    if (me.weapon && me.weapon.ammo.rounds === 0) {
                        var ammoElement = document.getElementById("ammo");
                        if (me.stateIdx % 20 === 0) {
                            ammoElement.style.color = "#f00";
                        } else if (me.stateIdx % 20 === 10) {
                            ammoElement.style.color = "#fff";
                        }
                    }
                    
                    if (grenadePowerUp === 1 && grenadeThrowPower < 1) {
                        grenadeThrowPower = Math.min(grenadeThrowPower + 0.015, 1);
                        document.getElementById("grenadeThrowContainer").style.visibility = "visible";
                        document.getElementById("grenadeThrow").style.height = 100 * grenadeThrowPower + "%";
                    }
                }
                
                if (!freezeFrame) {
                    munitionsManager.update(1);
                    itemManager.update(1);
                    updateParticles(explosionSmokeManager, 1);
                    updateParticles(explosionFireManager, 1);
                    updateParticles(shellFragManager, 1);
                    updateParticles(yolkManager, 1);
                };
                
                if (mapOverview) {
                    mapOverviewAxis += 0.002;
                    camera.position.x = Math.sin(mapOverviewAxis) * map.height + map.width / 2;
                    camera.position.z = Math.cos(mapOverviewAxis) * map.height + map.depth / 2;
                    camera.setTarget(new BABYLON.Vector3(map.width / 2, map.height / 4, map.depth / 2));
                };
            };
        }());
        if (me) {
            shadowLight.position.x = viewingPlayer.x;
            shadowLight.position.y = viewingPlayer.y + 2;
            shadowLight.position.z = viewingPlayer.z;
        };
    });
    
    engine.runRenderLoop(function () {
        gameScene.render()
    })
}

function serverSync() {
    if (me) {
        var output = new Comm.output(3 + 5 * FramesBetweenSyncs);
        output.packInt8(CommCode.sync), output.packInt8(me.stateIdx), output.packInt8(me.shotsQueued);
        for (var startIdx = Math.mod(me.stateIdx - FramesBetweenSyncs, stateBufferSize), i = 0; i < FramesBetweenSyncs; i++) {
            var idx = Math.mod(startIdx + i, stateBufferSize);
            output.packInt8(me.stateBuffer[idx].controlKeys), output.packRadU(me.stateBuffer[idx].yaw), output.packRad(me.stateBuffer[idx].pitch)
        }
        ws.send(output.buffer), me.shotsQueued = 0
    }
};

function switchTeam() {
    closeAlertDialog();
    var output = new Comm.output(1);
    output.packInt8(CommCode.switchTeam), ws.send(output.buffer)
};

function setTeamButton() {
    var teamButton = document.getElementById("teamButton");
    teamButton.className = 1 == myTeam ? (teamButton.innerText = "Join RED Team", "ssbutton red") : (teamButton.innerText = "Join BLUE Team", "ssbutton blue")
};

function addPlayer(playerData) {
    playerData.id == meId && (viewingPlayerId = playerData.id);
    var player = new Player(playerData, gameScene);
    player.id == meId && (viewingPlayer = me = player, me.ws = ws, updateAmmoUi()), player.playing || player.actor.removeFromPlay(), players[playerData.id] = player, rebuildPlayerList()
};

function removePlayer(playerId) {
    var player = players[playerId];
    playerId != meId ? player && (player.actor.remove(), delete players[playerId], rebuildPlayerList()) : console.log("Tried to remove ME")
};

function getTeamScores() {
    for (var teamScore = [0, 0, 0], i = 0; i < playerLimit; i++) {
        var player = players[i];
        player && (teamScore[player.team] += player.score)
    }
    var leadingTeam = 0;
    return teamScore[1] > teamScore[2] ? leadingTeam = 1 : teamScore[2] > teamScore[1] && (leadingTeam = 2), {
        score: teamScore,
        leader: leadingTeam
    }
};

function rebuildPlayerList() {
    for (var playerIdxs = [], i = 0; i < players.length; i++) players[i] && playerIdxs.push(i);
    if (gameType == GameType.teams) {
        var teams = getTeamScores();
        0 < teams.leader && (lastLeadingTeam = teams.leader), teams.score[lastLeadingTeam] += 1e5, playerIdxs.sort(function (a, b) {
            return players[b].score + teams.score[players[b].team] - (players[a].score + teams.score[players[a].team])
        })
    } else playerIdxs.sort(function (a, b) {
        return players[b].score - players[a].score
    });
    var list = document.getElementById("playerList").children;
    for (i = 0; i < playerIdxs.length; i++) {
        var player = players[playerIdxs[i]];
        if (list[i].style.display = "block", list[i].children[0].innerText = player.name, player.id != meId) {
            list[i].addEventListener("click", function (playerId, uniqueId) {
                return function () {
                    openAlertDialog(players[playerId].name, "", {
                        label: "Close",
                        onclick: closeAlertDialog
                    });
                    var b, container = document.createElement("div");
                    container.style.textAlign = "center", container.innerHTML = getLocText("ui_game_playeractions_header") + "<br><br>", document.getElementById("alertMessage").appendChild(container), (b = document.createElement("button")).style.display = "inline-block", players[playerId].muted ? (b.className = "ssbutton blue", b.innerHTML = getLocText("ui_game_playeractions_unmute")) : (b.className = "ssbutton orange", b.innerHTML = getLocText("ui_game_playeractions_mute")), b.style.width = "10em", b.style.height = "2.5em", b.style.margin = "0.5em", b.onclick = function (playerId, uniqueId) {
                        return function () {
                            mutePlayer(playerId, uniqueId)
                        }
                    }(playerId, uniqueId), container.appendChild(b), isGameOwner && ((b = document.createElement("button")).className = "ssbutton red", b.style.display = "inline-block", b.innerHTML = getLocText("ui_game_playeractions_boot"), b.style.width = "10em", b.style.height = "2.5em", b.style.margin = "0.5em", b.onclick = function (playerId, uniqueId) {
                        return function () {
                            bootPlayer(playerId, uniqueId)
                        }
                    }(playerId, uniqueId), container.appendChild(b))
                }
            }(player.id, player.uniqueId), false), list[i].style.pointerEvents = "all", list[i].style.cursor = "pointer"
        }
        player.upgradeProductId && player.upgradeProductId, list[i].children[1].innerText = player.score, player.id == meId ? (list[i].className = "thisPlayer", list[i].style.background = teamColors.meBackground[player.team]) : (list[i].className = "otherPlayer", list[i].style.background = teamColors.themBackground[player.team], list[i].style.color = teamColors.text[player.team]), player.upgradeProductId && 0 < player.upgradeProductId ? list[i].children[0].classList.add("upgradedPlayer") : list[i].children[0].classList.remove("upgradedPlayer")
    }
    for (; i < playerLimit;) list[i].style.display = "none", i++
};

function bootPlayer(playerId, uniqueId) {
    if (isGameOwner && players[playerId] && players[playerId].uniqueId == uniqueId) {
        var output = new Comm.output(4);
        output.packInt8(CommCode.bootPlayer), output.packInt8(playerId), output.packInt16(players[playerId].uniqueId), ws.send(output.buffer)
    }
    closeAlertDialog()
};

function mutePlayer(playerId, uniqueId) {
    var player = players[playerId];
    player && player.uniqueId == uniqueId && (player.muted ? (player.muted = false, player.name = player.oldName) : (player.muted = true, player.oldName = player.name, player.name = randomName()), player.actor.setupNameSprite(), rebuildPlayerList()), closeAlertDialog()
};

function updateAmmoUi() {
    if (me) {
        var el = document.getElementById("weaponName");
        el.innerHTML = me.weapon.subClass.weaponName, (el = document.getElementById("ammo")).style.color = "#fff", el.innerHTML = me.weapon.ammo.rounds + "/" + Math.min(me.weapon.ammo.store, me.weapon.ammo.storeMax);
        for (var i = 1; i <= 3; i++) me.grenadeCount >= i ? document.getElementById("grenade" + i).src = "img/grenadeIcon.png?v=1" : document.getElementById("grenade" + i).src = "img/grenadeIconDark.png?v=1"
    };
};

function addKillText(byPlayer, killedPlayer) {
    var msgs = [" SCRAMBLED ", " BEAT ", " POACHED ", " WHIPPED ", " FRIED ", " CRACKED "],
        str = '<span style="color: ' + teamColors.text[byPlayer.team] + '">' + byPlayer.name + "</span>" + msgs[Math.randomInt(0, msgs.length)] + '<span style="color: ' + teamColors.text[killedPlayer.team] + '">' + killedPlayer.name + "</span>";
    4 < (killEl.innerHTML.match(/<br>/g) || []).length && (killEl.innerHTML = killEl.innerHTML.substr(killEl.innerHTML.search("<br>") + 4)), killEl.innerHTML += str + "<br>"
};

function initChatIn() {
    canvas.focus(), chatInEl.style.display = "block", chatInEl.value = "Press ENTER to chat", chatInEl.style.background = "transparent", chatInEl.blur(), chatting = false
};

function addChat(str, fromPlayer) {
    fromPlayer && (str = '<span style="color: ' + teamColors.text[fromPlayer.team] + '">' + fromPlayer.name + ": </span>" + str), 5 < (chatOutEl.innerHTML.match(/<br>/g) || []).length && (chatOutEl.innerHTML = chatOutEl.innerHTML.substr(chatOutEl.innerHTML.search("<br>") + 4)), str = '<div class="shadedPane" style="margin-top: 0.2em">' + str + "</div><br>", chatOutEl.innerHTML += str
};

function inviteFriends() {
    gameCode = selectedServer.toString(36) + gameId.toString(36) + gameKey.toString(36);
    var url = parsedUrl.root + "#" + gameCode;
    openAlertDialog("Don't Go Alone!", "<p>Share this link with your friends so they can join you!</p><h3>" + (document.getElementById("friendCode").innerText = url) + "</h3><p></p>", {
        label: "Copy to clipboard",
        width: "12em",
        onclick: copyFriendCode
    }, {
        label: "Close",
        onclick: closeAlertDialog
    })
};

function copyFriendCode() {
    document.getElementById("friendCode").select();
    try {
        document.execCommand("copy")
    } catch (err) {
        console.log("Unable to copy to clipboard")
    }
    closeAlertDialog()
};

function isMeshVisible(mesh, offset) {
    if (freezeFrame) return true;
    for (var oy = offset || mesh.getBoundingInfo().boundingBox.center.z, dx = mesh.position.x - camera.globalPosition.x, dy = mesh.position.y + oy - camera.globalPosition.y, dz = mesh.position.z - camera.globalPosition.z, distance = Math.length3(dx, dy, dz), dv = Math.normalize3({
        x: dx,
        y: dy,
        z: dz
    }, .9), x = camera.globalPosition.x, y = camera.globalPosition.y, z = camera.globalPosition.z, collisions = 0, i = 0; i < distance - .9 && (x += dv.x, y += dv.y, z += dv.z, !(x < 0 || x >= map.width || z < 0 || z >= map.depth || y < 0 || y >= map.height)); i += .9) {
        var cell = map.data[Math.floor(x)][Math.floor(y)][Math.floor(z)];
        if (cell.idx) {
            var m = mapMeshes[cell.idx];
            if ("full" == m.colliderType && !m.softness && 2 == ++collisions) return false
        };
    };
    return true;
};

//  ___  _   ___ _____ ___ ___ _    ___ ___ 
// | _ \/_\ | _ \_   _|_ _/ __| |  | __/ __|
// |  _/ _ \|   / | |  | | (__| |__| _|\__ \
// |_|/_/ \_\_|_\ |_| |___\___|____|___|___/
// [LS] ######## Particles ---------------------------------

function createParticleManager(filename, number, firstFrame, lastFrame, scene) {
    for (var manager = new BABYLON.SpriteManager("", "img/" + filename + "?" + version, number, 128, scene), i = 0; i < number; i++) {
        new BABYLON.Sprite("", manager).isVisible = false
    }
    return manager.nextIdx = 0, manager.getSprite = function () {
        var s = this.sprites[this.nextIdx];
        return s.cellIndex = Math.randomInt(firstFrame, lastFrame), s.isVisible = true, s.easing = Ease.linear, s.startSize = -1, s.endSize = -1, s.gravity = 0, s.dx = 0, s.dy = 0, s.dz = 0, s.float = 0, s.anim = 0, s.slow = 0, s.angle = 0, s.rotate = 0, s.stopped = false, s.animColors = null, s.collide = false, s.color.copyFrom(color4White), this.nextIdx = ++this.nextIdx % this.sprites.length, s
    }, manager
}

function addExplosionSprite(manager, animLength, x, y, z, dx, dy, dz, size, gravity) {
    var s = manager.getSprite();
    return s.animLength = animLength, s.easing = Ease.inOutQuad, s.position.x = x, s.position.y = y, s.position.z = z, s.size = size, s.dx = dx, s.dy = dy, s.dz = dz, s.slow = .7, s.angle = Math.random() * Math.PI2, s.rotate = .04 * Math.random() - .02, s.animColors = manager == explosionFireManager ? fireColors : smokeColors, s
}

function addExplosion(x, y, z, damage, radius) {
    for (var i = 0; i < Math.floor(damage / 4); i++) {
        var animLength = 80 * Math.random() + 80,
            size = 1 * Math.random() + .5,
            se = .5 * (.9 - size),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - 1) * se + .1,
            dz = (2 * Math.random() - 1) * se,
            s = addExplosionSprite(explosionSmokeManager, animLength, x, y, z, dx, dy, dz, size);
        s.float = .015 * Math.random() + .001, s.collide = true, (s = addExplosionSprite(explosionFireManager, .075 * animLength, x, y, z, 1.5 * dx, 1.5 * dy, 1.5 * dz, size)).collide = true
    }
    if (me) {
        var d = Math.length3(me.x - x, me.y - y, me.z - z);
        if (d < (radius *= 1.5)) {
            var shakeFactor = Math.max(0, (radius - d) / radius);
            shake = Math.min(7, shake + 6 * shakeFactor)
        };
    };
};

function lerp(colors, p, ref) {
    for (var i = colors.length - 2; 0 <= i; i--)
        if (p >= colors[i].pos) return void BABYLON.Color4.LerpToRef(colors[i].color, colors[i + 1].color, (p - colors[i].pos) * (1 / (colors[i + 1].pos - colors[i].pos)), ref)
};

function shellFragBurst(player, count, theSize, theAnimLength) {
    for (var i = 0; i < count; i++) {
        var animLength = Math.random() * theAnimLength + .5 * theAnimLength,
            size = i / (.5 * count) * theSize + .5 * theSize,
            se = .08 / (size + 1),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - .5) * se,
            dz = (2 * Math.random() - 1) * se,
            s = shellFragManager.getSprite();
        s.animLength = animLength, s.easing = Ease.inQuad, s.position.x = player.actor.mesh.position.x, s.position.y = player.actor.mesh.position.y + .3, s.position.z = player.actor.mesh.position.z, s.startSize = size, s.endSize = 0, s.gravity = .003, s.dx = dx, s.dy = dy, s.dz = dz, s.angle = Math.random() * Math.PI2, s.rotate = .2 * Math.random() - .1, s.collide = true, s.color.r = player.actor.bodyMesh.colorMult.r, s.color.g = player.actor.bodyMesh.colorMult.g, s.color.b = player.actor.bodyMesh.colorMult.b
    }
};

function yolkBurst(player) {
    for (var i = 0; i < 10; i++) {
        var animLength = 80 * Math.random() + 80,
            size = i / 5 * .2 + .2,
            se = .05 / (size + 1),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - .25) * se * 1.5,
            dz = (2 * Math.random() - 1) * se,
            s = yolkManager.getSprite();
        s.animLength = animLength, s.easing = Ease.inQuad, s.position.x = player.actor.mesh.position.x, s.position.y = player.actor.mesh.position.y + .3, s.position.z = player.actor.mesh.position.z, s.startSize = size, s.endSize = 0, s.gravity = .005, s.dx = dx, s.dy = dy, s.dz = dz, s.slow = .9, s.angle = Math.random() * Math.PI2, s.rotate = .2 * Math.random() - .1, s.collide = true
    }
};

function updateParticles(manager, delta) {
    for (var i = 0; i < manager.sprites.length; i++) {
        var s = manager.sprites[i];
        if (s.isVisible) {
            var anim = s.easing(s.anim);
            if (0 <= s.endSize && (s.size = s.startSize + anim * (s.endSize - s.startSize)), s.animColors && lerp(s.animColors, anim, s.color), !s.stopped) {
                s.position.x += s.dx, s.position.y += s.dy + s.float, s.position.z += s.dz, s.rotate && (s.angle += s.rotate);
                var res = false;
                s.collide && (tv1.set(s.position.x, s.position.y, s.position.z), res = Collider.pointCollidesWithMap(tv1, true)), res ? (s.stopped = true, s.position.x -= s.dx, s.position.y -= s.dy, s.position.z -= s.dz) : s.gravity && (s.dy -= s.gravity), s.slow && (s.dx *= s.slow, s.dy *= s.slow, s.dz *= s.slow)
            }
            s.anim += delta / s.animLength, 1 <= s.anim && (s.isVisible = false)
        }
    }
};


//  ___ _  _ ___ _   _ _____ ___ 
// |_ _| \| | _ \ | | |_   _/ __|
//  | || .` |  _/ |_| | | | \__ \
// |___|_|\_|_|  \___/  |_| |___/
// [LS] ######## Inputs ---------------------------------

function onCanvasMouseDown(event) {
    inputDown("MOUSE " + event.button), 1 == event.button && event.preventDefault()
};

function onCanvasMouseUp(event) {
    inputUp("MOUSE " + event.button)
};

function onCanvasMouseMove(event) {
    if (document.pointerLockElement && me && 0 < me.hp) {
        var mult = 5e-4 * settings.mouseSensitivity + .001;
        me.actor.scope && (mult *= .3);
        var mx = event.movementX;
        lastMouseMovement.x && Math.sign(mx) != Math.sign(lastMouseMovement.x) && (mx = 0), lastMouseMovement.x = mx;
        var my = event.movementY;
        lastMouseMovement.y && Math.sign(my) != Math.sign(lastMouseMovement.y) && (my = 0), lastMouseMovement.y = my, me.yaw = Math.radAdd(me.yaw, mx * mult), me.pitch = Math.clamp(me.pitch + my * settings.mouseInvert * mult, -1.5, 1.5)
    }
};

function onCanvasMouseWheel(event) {
    0 < event.wheelDelta ? (inputDown("WHEEL UP"), inputUp("WHEEL UP")) : (inputDown("WHEEL DOWN"), inputUp("WHEEL DOWN"))
};

function captureKeys() {
    lastKey = null, document.onkeydown = onKeyDown, document.onkeyup = onKeyUp
}

function releaseKeys() {
    document.onkeydown = null, document.onkeyup = null
}

function inputDown(code) {
    me.playing && document.pointerLockElement && function (control) {
        switch (control) {
            case "up":
            case "down":
            case "left":
            case "right":
                var bit = CONTROL[control];
                me.controlKeys |= bit, me.stateBuffer[me.stateIdx].controlKeys = me.controlKeys;
                break;
            case "jump":
                if (0 < me.lastTouchedGround && Date.now() > me.lastTouchedGround + 100 && me.jump()) {
                    var output = new Comm.output(1);
                    output.packInt8(CommCode.jump), ws.send(output.buffer)
                }
                break;
            case "fire":
                document.pointerLockElement && me && me.pullTrigger();
                break;
            case "grenade":
                document.pointerLockElement && me && !grenadePowerUp && me.canSwapOrReload() && 0 < me.grenadeCount && (grenadePowerUp = true, grenadeThrowPower = -.15);
                break;
            case "scope":
                settings.holdToAim ? me.actor.scopeIn() : me.actor.scope ? me.actor.scopeOut() : me.actor.scopeIn();
                break;
            case "reload":
                me.reload();
                break;
            case "weapon":
                me.swapWeapon(0 == me.weaponIdx ? 1 : 0)
        }
    }(inputToControlMap[code])
};

function inputUp(code) {
    me.playing && document.pointerLockElement && function (control) {
        switch (control) {
            case "fire":
                me.weapon && me.releaseTrigger();
                break;
            case "scope":
                settings.holdToAim && me.actor.scopeOut();
                break;
            case "grenade":
                document.pointerLockElement && me && grenadePowerUp && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden", grenadePowerUp = false, me.throwGrenade(grenadeThrowPower));
                break;
            case "up":
            case "down":
            case "left":
            case "right":
            case "jump":
                var bit = CONTROL[control];
                me.controlKeys ^= me.controlKeys & bit
        }
    }(inputToControlMap[code])
};

function onKeyDown(e) {
    var key = (e = e || window.event).key;
    if (key != lastKey)
        if (lastKey = key, grenadePowerUp || 0 != me.controlKeys || "Enter" != key || !settings.enableChat) {
            var k = ("" + key).toLocaleUpperCase();
            if (" " == k && (k = "SPACE", e.preventDefault()), debug) {
                if ("`" == k) return void

                    function () {
                        if (debugWindow) {
                            for (var i = 0; i < playerLimit; i++) {
                                var p = players[i];
                                if (p) {
                                    var player = {
                                        name: p.name,
                                        hp: p.hp,
                                        playing: p.playing,
                                        posX: p.x,
                                        posY: p.y,
                                        posZ: p.z,
                                        actorX: p.actor.mesh.position.x,
                                        actorY: p.actor.mesh.position.y,
                                        actorZ: p.actor.mesh.position.z,
                                        transformEnabled: p.actor.mesh.isEnabled(),
                                        transformVisible: p.actor.mesh.isVisible,
                                        transformFrozen: p.actor.mesh.isWorldMatrixFrozen,
                                        shellEnabled: p.actor.bodyMesh.isEnabled(),
                                        shellVisible: p.actor.bodyMesh.isVisible,
                                        shellFrozen: p.actor.bodyMesh.isWorldMatrixFrozen,
                                        weaponEnabled: p.weapon.actor.gunMesh.isEnabled(),
                                        weaponVisible: p.weapon.actor.gunMesh.isVisible
                                    };
                                    debugWindow.document.write(JSON.stringify(player) + "\n")
                                }
                            }
                            debugWindow.document.write("<hr>")
                        } else (debugWindow = window.open("", "", "name=Debug")).document.write("<pre>")
                    }();
                if ("\\" == k) {
                    freezeFrame = true;
                    for (var i = 0; i < gameScene.particleSystems.length; i++) gameScene.particlesPaused = true;
                    for (i = 0; i < playerLimit; i++) players[i] && players[i].actor && (players[i].actor.mesh.setVisible(true), players[i].actor.showNameSprite(), players[i].actor.positionNameSprite());
                    ws.close()
                }
            }
            inputDown(k)
        } else 0 < me.chatLineCap && (releaseKeys(), chatInEl.style.background = "rgba(0, 0, 0, 0.5)", chatInEl.value = "", chatInEl.focus(), chatting = !(lastKey = null))
};

function onKeyUp(e) {
    var key = (e = e || window.event).key;
    key == lastKey && (lastKey = null);
    var k = ("" + key).toLocaleUpperCase();
    " " == k && (k = "SPACE", e.preventDefault()), inputUp(k)
};

function addCanvasListeners() {
    console.log("Event listeners added"), canvas.style.pointerEvents = "all", canvas.addEventListener("mousedown", onCanvasMouseDown, false), canvas.addEventListener("mouseup", onCanvasMouseUp, false), canvas.addEventListener("mousemove", onCanvasMouseMove), canvas.addEventListener("wheel", onCanvasMouseWheel)
};

function removeCanvasListeners() {
    console.log("Event listeners removed"), canvas.style.pointerEvents = "none", canvas.removeEventListener("mousedown", onCanvasMouseDown), canvas.removeEventListener("mouseup", onCanvasMouseUp), canvas.removeEventListener("mousemove", onCanvasMouseMove), canvas.removeEventListener("wheel", onCanvasMouseWheel)
};

// window.console = function (origConsole) {
//     window.console && origConsole || (origConsole = {});
//     var logArray = [];
//     return {
//         dir: function () {
//             origConsole.dir && origConsole.dir.apply(origConsole, arguments)
//         },
//         log: function () {
//             this.addLog(arguments), origConsole.log && origConsole.log.apply(origConsole, arguments)
//         },
//         warn: function () {
//             this.addLog(arguments), origConsole.warn && origConsole.warn.apply(origConsole, arguments)
//         },
//         error: function () {
//             this.addLog(arguments), origConsole.error && origConsole.error.apply(origConsole, arguments)
//         },
//         info: function () {
//             this.addLog(arguments), origConsole.info && origConsole.info.apply(origConsole, arguments)
//         },
//         addLog: function (args) {
//             var msg = args[0];
//             "object" == typeof msg && (msg = JSON.stringify(msg)), logArray.push(msg), 100 < logArray.length && logArray.shift()
//         },
//         logArray: function () {
//             return logArray
//         },
//         clearLog: function () {
//             logArray = []
//         }
//     }
// }(window.console);

// [LS] ItemRenderer CONSTRUCTOR
function ItemRenderer() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = 256;
    this.canvas.height = 256;
    this.canvas.style.position = "fixed";
    this.canvas.style.top = "-100em";
    this.canvas.style.left = "1em";
    document.body.appendChild(this.canvas);
    this.engine = new BABYLON.Engine(this.canvas, true, null, false);
    this.scene = new BABYLON.Scene(this.engine);
    this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
    this.meshes = {
        Skeletons: {}
    };
    loadMaterials(this.scene);
    loadMeshes(this.scene, ["egg", "gun_cluck9mm", "gun_eggk47", "gun_csg1", "gun_dozenGauge", "gun_rpegg"], null, function () { });
    this.stampSprites = new BABYLON.SpriteManager("", "img/stamps.png?v=" + version, 256, 128, this.scene);
    this.camera = new BABYLON.ArcRotateCamera("", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), this.scene);
    this.scene.activeCameras.push(this.camera);
    this.camera.fov = .5;
    this.camera.maxZ = 100;
    this.camera.minZ = .1;
};
ItemRenderer.prototype.renderToCanvas = function (meshName, destCanvas, cam) {
    this.engine.clear(), this.camera.alpha = 0, this.camera.beta = Math.PI90, this.camera.radius = cam.radius || 1;
    cam.y;
    try {
        var mesh = this.scene.getMeshByName(meshName).clone();
    } catch (error) {
        devlog(meshName);
    };
    cam.primaryGun ? (mesh.rotation.x = -.7, mesh.position.y = -.1, mesh.position.z = -.1) : cam.secondaryGun ? (mesh.position.z = -.32, mesh.position.y = .05) : (mesh.position.y = -.25, mesh.rotation.y = 2, mesh.rotation.x = .25), mesh.computeWorldMatrix();
    var verts = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    this.scene.updateTransformMatrix();
    for (var min = {
        x: 1e4,
        y: 1e4
    }, max = {
        x: -1e4,
        y: -1e4
    }, i = 0; i < verts.length; i += 3) {
        var sp = BABYLON.Vector3.Project(new BABYLON.Vector3(verts[i], verts[i + 1], verts[i + 2]), mesh.getWorldMatrix(), this.scene.getTransformMatrix(), this.camera.viewport.toGlobal(this.engine));
        min.x = Math.min(min.x, sp.x), max.x = Math.max(max.x, sp.x), min.y = Math.min(min.y, sp.y), max.y = Math.max(max.y, sp.y)
    }
    var cx = (max.x + min.x) / 2 - 128,
        cy = (max.y + min.y) / 2 - 128;
    mesh.position.z -= cx / 512, mesh.position.y += cy / 512, this.scene.render(), mesh.dispose();
    var ctx = destCanvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256), ctx.drawImage(this.canvas, 0, 0)
};
ItemRenderer.prototype.renderStampToCanvas = function (stampItem, destCanvas) {
    var s = new BABYLON.Sprite("", this.stampSprites),
        x = stampItem.item_data.x,
        y = stampItem.item_data.y;
    s.cellIndex = x + 16 * y, s.size = 1, this.camera.alpha = 0, this.camera.beta = 0, this.camera.radius = 2.5, this.scene.render(), s.dispose();
    var ctx = destCanvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256), ctx.drawImage(this.canvas, 0, 0)
};

function PlayerReward(tag, openUrl, openUrlMsg) {
    this.tag = tag, this.openUrl = openUrl, this.openUrlMsg = openUrlMsg, this.wasUrlOpened = null
}
String.prototype.format = String.prototype.f = function () {
    for (var s = this, i = arguments.length; i--;) s = s.replace(new RegExp("\\{" + i + "\\}", "gm"), arguments[i]);
    return s;
};
window.onerror = function (msg, url, lineNo, columnNo, error) {
    var str = ["Message: " + msg, "URL: " + url, "Line: " + lineNo, "Column: " + columnNo].join("\n");
    return str += JSON.stringify(error, ["message", "arguments", "type", "name"]) + "\n", console.log(str), false
};

//just weird google stuff. ignore.
// var i, s, o, r, a, m;

function closeServerList() {
    closeAlertDialog()
};

function pingServers(autoSelect, callback) {
    var serverSelected = false,
        serversPinged = 0;
    var protocol = "ws://";
    "https:" === location.protocol && (protocol = "wss://");
    console.log("Pinging servers", protocol);
    for (var i = 0; i < servers.length; i++) servers[i].ping = 0,
        function (serverIdx) {
            var startTime, server = servers[serverIdx],
                pinger = new WebSocket(protocol + server.address);
            console.log("Connecting to " + server.name), pinger.binaryType = "arraybuffer";
            var timeout = setTimeout(function () {
                console.log(server.name + " timed out"), server.ping = 1e3, pinged(), pinger.close()
            }, 1e3);
            pinger.onopen = function (e) {
                console.log("Pinging " + server.name);
                var output = new Comm.output(1);
                output.packInt8(CommCode.ping), pinger.send(output.buffer), startTime = Date.now()
            }, pinger.onmessage = function (e) {
                clearTimeout(timeout);
                var pingTime = Date.now() - startTime;
                server.ping = pingTime, pinger.close(), autoSelect && !serverSelected && (serverSelected = true, selectServer(serverIdx)), pinged(), console.log(server.name + ": " + pingTime)
            }, pinger.onerror = function (e) {
                clearTimeout(timeout), server.ping = 1e3, pinged()
            }
        }(i);

    function pinged() {
        ++serversPinged == servers.length && callback && callback()
    }
};

function selectServer(i) {
    selectedServer = i, localStorage.setItem("selectedServer", i), document.getElementById("serverName").innerText = "Server: " + servers[selectedServer].name
}

function resize() {
    canvas && (canvas.style.width = "100%", canvas.style.height = "100%", canvas.className = ""), engine && engine.resize(), inGame && (hitIndicator && hitIndicator.resize(), reticle && reticle.resize());
    var scale = Math.min(1, window.innerHeight / 725),
        scaleStr = "scale(" + scale + ")",
        widthStr = 300 * scale + "px",
        heightStr = 250 * scale + "px";
    // document.getElementById("shellshock-io_300x250").style.transform = scaleStr;
    // for (var el = document.getElementById("bannerAdContainer"), i = 0; i < el.children.length; i++) {
    //     var chEl = el.children[i];
    //     chEl.style.width = widthStr, chEl.style.height = heightStr
    // }
};

function fetchTwitchStreams() {
    var streamsEl = document.getElementById("twitchStreams");
    streamsEl.innerHTML = "", console.log(url);
    var url = parsedUrl.root;
    getRequest(url + "twitchStreams.json?" + Date.now(), function (err, res) {
        if (!err) {
            var twitchStreams = JSON.parse(res),
                keys = Object.keys(twitchStreams);
            keys.sort(function (a, b) {
                return twitchStreams[b].viewers - twitchStreams[a].viewers
            }), keys.forEach(function (k) {
                var stream = twitchStreams[k],
                    container = document.createElement("div");
                container.className = "twitchRow clickable", container.onclick = function (name) {
                    return function () {
                        window.open("https://twitch.tv/" + name, "_blank")
                    }
                }(stream.name);
                var avatar = document.createElement("img");
                avatar.className = "twitchAvatar", avatar.src = "img/twitchAvatars/" + stream.avatar;
                var name = document.createElement("div");
                name.className = "twitchName", name.innerText = stream.name;
                var viewers = document.createElement("div");
                viewers.className = "twitchViewers", viewers.innerText = stream.viewers + " viewer", 1 < stream.viewers && (viewers.innerText += "s"), container.appendChild(avatar), container.appendChild(name), container.appendChild(viewers), streamsEl.appendChild(container)
            })
        }
    })
};

function loadSettings() {
    settings.volume = getStoredNumber("volume", 1), settings.mouseSensitivity = Math.max(Math.min(11, getStoredNumber("mouseSensitivity", 5)), 0), settings.mouseInvert = getStoredNumber("mouseInvert", 1), settings.holdToAim = getStoredBool("holdToAim", true), settings.enableChat = getStoredBool("enableChat", false), settings.autoDetail = getStoredBool("autoDetail", true), settings.shadowsEnabled = getStoredBool("shadowsEnabled", true), settings.highRes = getStoredBool("highRes", true), inputToControlMap = {
        W: "up",
        S: "down",
        A: "left",
        D: "right",
        SPACE: "jump",
        "MOUSE 0": "fire",
        SHIFT: "scope",
        R: "reload",
        E: "weapon",
        Q: "grenade"
    };
    var storedControlMap = JSON.parse(localStorage.getItem("controlConfig"));
    for (var sk in storedControlMap) Object.keys(inputToControlMap).forEach(function (ik) {
        inputToControlMap[ik] == storedControlMap[sk] && delete inputToControlMap[ik]
    }), inputToControlMap[sk] = storedControlMap[sk];
    for (var p in inputToControlMap) {
        var ps = "" + p;
        inputToControlMap.hasOwnProperty(ps) && ps != ps.toLocaleUpperCase() && (delete inputToControlMap[ps], inputToControlMap[ps.toLocaleUpperCase()] = inputToControlMap[p])
    } ! function () {
        for (var k in inputToControlMap) {
            var el = settingsKeyCells[inputToControlMap[k]];
            el && (el.innerText = ("" + k).toLocaleUpperCase())
        }
        document.getElementById("volume").value = settings.volume, document.getElementById("mouseSensitivity").value = settings.mouseSensitivity, document.getElementById("mouseInvert").checked = -1 == settings.mouseInvert, document.getElementById("holdToAim").checked = settings.holdToAim, document.getElementById("enableChat").checked = settings.enableChat, document.getElementById("autoDetail").checked = settings.autoDetail, document.getElementById("shadowsEnabled").checked = settings.shadowsEnabled, document.getElementById("highRes").checked = settings.highRes, setDetailSettingsVisibility(settings.autoDetail)
    }()
};

//why is this code so fucking sketchy
i = window;
s = document;

window.addEventListener("contextmenu", function (e) {
    e.preventDefault()
}, false);
window.onresize = function () {
    resize()
};
window.onload = function () {
    selectedServer = getStoredNumber("selectedServer", 0);
    lastVer = getStoredString("lastVersionPlayed", version);
    localStorage.setItem("lastVersionPlayed", version);

    if (lastVer != version) return (req = window.indexedDB.deleteDatabase("babylonjs")).onerror = function (event) {
        window.location.reload(true)
    }, void (req.onsuccess = function (event) {
        window.location.reload(true)
    });

    // var req;

    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
    var str = "",
        missingFeatures = 0;
    BABYLON.Engine.isSupported() || (str += '<li>WebGL (<a href="https://legacy.onlypuppy7.online/faq.html#webgl" target="_window">More info</a>)', missingFeatures++);
    (!document.exitPointerLock || 0 <= navigator.userAgent.indexOf("10.1.2 Safari")) && (str += '<li>Pointer Lock (<a href="https://legacy.onlypuppy7.online/faq.html#pointerlock" target="_window">More info</a>)', missingFeatures++);
    localStorage || (str += "<li>LocalStorage", missingFeatures++);
    void 0 === new KeyboardEvent("").key && (str += "<li>KeyboardEvent.key", missingFeatures++);


    if (0 < missingFeatures) {
        str = 1 == missingFeatures ? "Your browser is missing a feature that Shell Shockers requires:<br><ul>" + str + "</ul>" : "Your browser is missing features that Shell Shockers requires:<br><ul>" + str + "</ul>";
        openAlertDialog("Oh, no!", '<div style="text-align: left">' + (str += "Downloading the latest version of your browser of choice will usually correct this. Internet Explorer is not supported.") + "</div>");
    } else {
        chatInEl = document.getElementById("chatIn");
        chatOutEl = document.getElementById("chatOut");
        killEl = document.getElementById("killTicker");
        "undefined" != typeof noAdBlock && (adBlock = false);
        
        // document.getElementById("privacyOptionsLink").style.display = isFromEU ? "block" : "none";
        gameType = getStoredNumber("gameType", GameType.ffa);
        for (var gameTypeSelect = document.getElementById("gameTypeSelect"), i = 0; i < GameTypes.length; i++) {
            var gt = GameTypes[i];
            gt.el = document.createElement("option"), gt.el.textContent = gt.longName, gameTypeSelect.appendChild(gt.el)
        };
        gameTypeSelect.selectedIndex = gameType,
            function () {
                var container = document.getElementById("bindingsContainer");
                for (var k in settingsKeyNames) {
                    var row = document.createElement("div"),
                        keyCell = document.createElement("span");
                    keyCell.className = "box defined", keyCell.innerText = getLocText("ui_settings_undefined"), keyCell.tabIndex = 1, keyCell.id = settingsKeyNames[k], keyCell.onmousedown = configKey, keyCell.onwheel = configKey, settingsKeyCells[settingsKeyNames[k]] = keyCell, row.appendChild(keyCell);
                    var nameCell = document.createElement("span");
                    nameCell.className = "label", nameCell.innerText = getLocText("ui_settings_bind_" + settingsKeyNames[k]), row.appendChild(nameCell), container.appendChild(row)
                };
            }(), loadSettings(),
            function () {
                var mapSelect = document.getElementById("mapSelect"),
                    el = document.createElement("option");
                for (var i in el.textContent = "[Random Map]", mapSelect.appendChild(el), minMaps) {
                    var map = minMaps[i],
                        el = document.createElement("option");
                    el.textContent = map.name, mapSelect.appendChild(el)
                };
            }();
        for (var playerList = document.getElementById("playerList"), slotTemplate = document.getElementById("playerSlot"), i = 0; i < 20; i++) {
            var slot = slotTemplate.cloneNode(true);
            playerList.appendChild(slot)
        };
        for (var containerEl = document.getElementById("leaderboard"), team = 0; team < 3; team++) {
            var teamEl = document.getElementById("teamSummary").cloneNode(true);
            teamEl.style.color = teamColors.text[team], teamEl.style.backgroundColor = teamColors.summaryBackground[team], teamSummaryEls.push(teamEl);
            teamEl.children[0];
            for (var i = 0; i < 20; i++) {
                var rowEl = document.getElementById("teamRow").cloneNode(true);
                rowEl.children[0].innerText = i + 1, rowEl.style.display = "flex", rowEl.style.background = i % 2 == 0 ? "rgba(0, 0, 0, 0.25)" : "transparent", teamEl.appendChild(rowEl)
            };
            containerEl.appendChild(teamEl)
        };

        fetchTwitchStreams();
        fetchHouseAds();
        resize();
        console.log("From EU: " + isFromEU);
        itemRenderer = new ItemRenderer;
        canvas = document.getElementById("canvas");
        engine = new BABYLON.Engine(canvas, true, null, false);
        engineCaps = engine.getCaps();
        BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume);
        0 == settings.volume ? BABYLON.Engine.audioEngine.audioContext.suspend() : BABYLON.Engine.audioEngine.audioContext.resume();
        settings.autoDetail || settings.highRes || lowerResolution();

        parsedUrl.query.openSettings && openSettingsMenu();
        parsedUrl.query.test && (testing = true);
        parsedUrl.query.noSkybox && (noSkybox = true);

        if (parsedUrl.query.testMap) {
            playOffline = true;
            mapTest.x = parsedUrl.query.x;
            mapTest.y = parsedUrl.query.y;
            mapTest.z = parsedUrl.query.z;
            mapTest.pitch = parsedUrl.query.pitch;
            mapTest.yaw = parsedUrl.query.yaw;
            playerLimit = 1;
            ws = {
                send: function () { }
            };
            inGame = true;
            engine.stopRenderLoop();
            void startGame();
            return;
        };

        let authToken = localStorage.getItem("LegacyShellAuthToken");
        let previousUsername = localStorage.getItem("LegacyShellPreviousUsername");
        try {
            if (authToken) {
                showSpinner("Retrieving Account", "I KNOW you're in here somewhere...");
                devlog("awaiting............");
                validateLoginViaAuthToken(previousUsername, authToken).then(result => {
                    // hideSpinner(); //will be hidden on resources loaded anyway
                    devlog(result);
                    if (result.error) {
                        devlog("fail 4");
                        showSpinner("Login Failed", result.error);
                        loginFail(result.error === "Too many requests. Please try again later."); //ratelimited
                    } else if (result.session) {
                        showSpinner("Logged In", "It's coming!");
                        loggedIn(result);
                    };
                }).catch((err) => {
                    devlog("damn", err)
                    // hideSpinner();
                    devlog("fail 3");
                    loginFail(true);
                });
            } else {
                devlog("fail 2");
                loginFail();
            };
        } catch (error) {
            devlog("fail 1");
            loginFail();
        };
        
        if (parsedUrl.hash) {
            openJoinBox();
            document.getElementById("joinCode").value = parsedUrl.hash;
        };
        var nameBox = document.getElementById("nickname");
        nameBox.value = getStoredString("lastNickname", "");
        nameBox.addEventListener("keyup", function (event) {
            nameBox.value = fixStringWidth(event.target.value);
            "Enter" != event.code && 13 != event.keyCode || 0 < nameBox.value.length && (nameBox.disabled = true, play());
        });
    };
};

function setControl(el) {
    ! function (el) {
        var els = document.getElementsByClassName("box defined");
        Array.prototype.slice.call(els).forEach(function (otherEl) {
            otherEl != el && otherEl.innerText == el.innerText && (delete inputToControlMap[otherEl.innerText], otherEl.className = "box undefined", otherEl.innerText = getLocText("ui_settings_undefined"))
        })
    }(el), delete inputToControlMap[el.oldText], inputToControlMap[el.innerText] = el.id, controlEl = null, window.onkeydown = null, window.onkeyup = null, localStorage.setItem("controlConfig", JSON.stringify(inputToControlMap))
};

function configKey(e) {
    var el = e.target;
    e = e || window.event, el == controlEl ? (1 == e.button && window.event.preventDefault(), el.className = "box defined", null != e.wheelDelta ? 0 < e.wheelDeltaY ? el.innerText = "WHEEL UP" : e.wheelDeltaY < 0 && (el.innerText = "WHEEL DOWN") : el.innerText = "MOUSE " + e.button, setControl(el)) : (controlEl && (controlEl.className = "box defined", controlEl.innerText = controlEl.oldText), el.oldText = el.innerText, el.className = "box active", el.innerText = getLocText("ui_settings_bindinput"), (controlEl = el).focus(), window.onkeydown = function (e) {
        var key = (e = e || window.event).key;
        if ("Escape" != key && "Tab" != key && "Enter" != key) return " " == key && (key = "space", e.preventDefault()), el.className = "box defined", el.innerText = key.toLocaleUpperCase(), setControl(el), e.stopPropagation(), false;
        el.className = "box defined", el.innerText = el.oldText, controlEl = null
    }, window.onkeyup = function (e) {
        return e.stopPropagation(), false
    })
};

function afterVideoAdComplete() {
    inGame ? (hideDarkOverlay(), timedGame && (openGameMenu(), showGameSummary(), resetGame())) : isGettingNugget ? buyChickenNuggetProduct() : (hideDarkOverlay(), joinGame()), BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume)
};

function loggedIn(accountDataResponse) {
    devlog("function loggedIn", accountDataResponse)
    var numPurchases;
    if (accountDataResponse.error) {
        statsEl.innerHTML = "Database error. Please send us a bug report!";
        console.log("accountDataResponse Error: " + JSON.stringify(accountDataResponse.error));
    } else {
        playerAccount.loggedIn(accountDataResponse);
        updatePlayerStatsDisplay();
        updateCurrentBalance();
        waitForSetupAndAuthComplete();
        numPurchases = void 0 === playerAccount.inventory || null === playerAccount.inventory ? 0 : playerAccount.inventory.length;
    };
    console.log("logged in");
    // statsEl.style.display = "none";
    document.getElementById("login").style.display = "none";
    document.getElementById("logout").style.display = "block";
    document.getElementById("user-greeting").style.display = "block";
    document.getElementById("user-greeting").innerText = "Welcome back, @" + playerAccount.username;
    document.getElementById("playerStats").style.display = "flex";
    customizer = new Customizer, extern.customizer = customizer, authAttemptComplete = true
    // if (!playerAccount.isLoggedIn && !loggingIn) {
    //     if (loggingIn = true, user.getIdToken(true).then(function (idToken) {
    //         (statsEl = document.getElementById("statsMessage")).innerHTML = "Retrieving your stats...", statsEl.style.display = "block", console.log("Using services server: " + servicesServer);
    //         try {
    //             var authWs = new WebSocket(servicesServer)
    //         } catch (e) {
    //             console.log(e)
    //         }
    //         showSpinner("Retrieving Account", "I KNOW you're in here somewhere..."), authWs.onopen = function (e) {
    //             var authData = {
    //                 cmd: "auth",
    //                 uid: user.uid,
    //                 token: idToken
    //             };
    //             "undefined" != typeof modifyAuthData && modifyAuthData(authData), authWs.send(JSON.stringify(authData)), console.log("authWs opened, and auth request sent")
    //         }, authWs.onmessage = function (e) {
    // }, authWs.onclose = function (e) {
    //     console.log("authWs closed: " + e.code + " " + e.reason), loggingIn = false
    // }, authWs.onerror = function (e) {
    //     statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("authWS Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"])), loggingIn = false
    // }
    //     }).catch(function (error) {
    //         console.log(error), loggingIn = false
    //     }), document.getElementById("login").style.display = "none", document.getElementById("logout").style.display = "block", user.photoURL) {
    //         var url = user.photoURL,
    //             pd = user.providerData[0];
    //         "facebook.com" == pd.providerId && (url = "https://graph.facebook.com/" + pd.uid + "/picture"), document.getElementById("profilePic").src = url, document.getElementById("profilePic").style.display = "block"
    //     }
    // }
};

function loginFail(dueToOffline) {
    if (!dueToOffline) {
        delete localStorage.LegacyShellAuthToken;
        delete localStorage.LegacyShellPreviousUsername;
    };
    devlog("loginFail");
    document.getElementById("login").style.display = "block";
    customizer = new Customizer;
    extern.customizer = customizer;
    authAttemptComplete = true;
    document.getElementById("logout").style.display = "none";
    document.getElementById("user-greeting").style.display = "none";
    document.getElementById("currentBalanceContainer").style.display = "none";
    document.getElementById("currentBalance").innerText = "0";
    purchasingEnabled = false;
    waitForSetupAndAuthComplete();
    //thanks, no thanks :P
    // console.log("Sending anon tags to OneSignal..."), unbloated3({
    //     has_account: false,
    //     maybe_school: false,
    //     is_chromebook: detectChromebook()
    // })
};

function openLoginDialog() {
    openAlertDialog(
        "Login",
        `<div id="LS-login-container">
            <form id="LS-loginForm">
                <label for="LS-username">Username:</label><br>
                <input type="text" id="LS-username" name="username" required pattern="[A-Za-z0-9_\\-]{3,20}" title="Username must be 3-20 characters long and can only include letters, numbers, underscores, and hyphens."><br>
                <label for="LS-password">Password:</label><br>
                <input type="password" id="LS-password" name="password" required pattern=".{8,}" title="Password must be at least 8 characters long."><br>
            </form>
            <div id="LS-login-error" style="color:red;display:none;">Error text.</div>
            <div style="text-align: center;">
                <p style="font-size: 0.9em;">
                    No account?
                    <button class="ssbutton purple" style="width: 8em; margin-top: 10px; margin-left: 10px;" onclick="extern.openRegisterDialog()">Register</button>
                </p>
                <p style="font-size: 0.8em; color: #555; max-width: 20em; margin: 0 auto; word-wrap: break-word;">
                    Note: These servers are unofficial and do not work with real Shell Shockers account details.
                </p>
            </div>
        </div>`,
        {
            label: "Login",
            width: "8em",
            onclick: clickedLogin
        },
        {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        }
    );
};

function openRegisterDialog() {
    openAlertDialog(
        "Register",
        `<div id="LS-register-container">
            <form id="LS-registerForm">
                <label for="LS-register-username">Username:</label><br>
                <input type="text" id="LS-register-username" name="username" required pattern="[A-Za-z0-9_\\-]{3,20}" title="Username must be 3-20 characters long and can only include letters, numbers, underscores, and hyphens."><br>
                <label for="LS-register-password">Password:</label><br>
                <input type="password" id="LS-register-password" name="password" required pattern=".{8,}" title="Password must be at least 8 characters long."><br>
            </form>
            <div id="LS-register-error" style="color:red;display:none;">Error text.</div>
            <div style="text-align: center;">
                <p style="font-size: 0.9em;">
                    Already have an account?
                    <button class="ssbutton purple" style="width: 8em; margin-top: 10px; margin-left: 10px;" onclick="extern.openLoginDialog()">Login</button>
                </p>
                <p style="font-size: 0.8em; color: #555; max-width: 20em; margin: 0 auto; word-wrap: break-word;">
                    Note: These servers are unofficial. Please use a unique username and password.
                </p>
            </div>
        </div>`,
        {
            label: "Create",
            width: "8em",
            onclick: clickedRegister
        },
        {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        }
    );
};

async function clickedLogin() {
    var username = document.getElementById("LS-username").value;
    var password = document.getElementById("LS-password").value;

    showSpinner("Retrieving Account", "I KNOW you're in here somewhere...");

    if (username.length < 3 || password.length < 2) {
        hideSpinner();
        document.getElementById("LS-login-error").style.display = "block";
        document.getElementById("LS-login-error").textContent = "Invalid username or password.";
    } else {
        try {
            let result = await validateLogin(username, sha256(password));
            hideSpinner();
            devlog(result)
            if (result.error) {
                document.getElementById("LS-login-error").style.display = "block";
                document.getElementById("LS-login-error").textContent = result.error;
            } else if (result.session) {
                loggedIn(result);
                closeAlertDialog();
            };
        } catch (error) {
            hideSpinner();
            console.error("Login failed:", error);
            document.getElementById("LS-login-error").style.display = "block";
            document.getElementById("LS-login-error").textContent = "Request error.";
        };
    }
};

async function clickedRegister() {
    var username = document.getElementById("LS-register-username").value;
    var password = document.getElementById("LS-register-password").value;

    showSpinner("Creating Account", "Get set, ready, GO!");

    try {
        if (username.length < 3 || !/^[A-Za-z0-9?!._-]+$/.test(username)) {
            hideSpinner();
            document.getElementById("LS-register-error").textContent = "Invalid username. Only letters, numbers, ?!._- are allowed.";
            document.getElementById("LS-register-error").style.display = "block";
            return false;
        } else if (!(/^(?=.*[A-Za-z])(?=.*\d).{8,}$/).test(password)) {
            hideSpinner();
            document.getElementById("LS-register-error").style.display = "block";
            document.getElementById("LS-register-error").textContent = "Password is too insecure.\nAt least 8 characters, 1 letter and 1 number are required."
        } else {
            let result = await validateRegister(username, sha256(password));
            hideSpinner();
            devlog(result);

            if (result.error) {
                document.getElementById("LS-register-error").style.display = "block";
                document.getElementById("LS-register-error").textContent = result.error;
            } else if (result.session) {
                loggedIn(result);
                closeAlertDialog();
            };
        };
    } catch (error) {
        hideSpinner();
        console.error("Register failed:", error);
        document.getElementById("LS-register-error").style.display = "block";
        document.getElementById("LS-register-error").textContent = "Request error.";
    };
};

function validateLogin(username, hashedPassword) {
    return new Promise((resolve, reject) => {
        devlog(username, hashedPassword);
        devlog("validateLogin called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        }

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateLogin",
                username: username,
                password: hashedPassword,
            }));
            console.log("servicesWs opened, and validateLogin request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            }
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

function validateLoginViaAuthToken(username, authToken) {
    return new Promise((resolve, reject) => {
        devlog(username, authToken);
        devlog("validateLogin called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        }

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateLoginViaAuthToken",
                username: username,
                authToken: authToken,
            }));
            console.log("servicesWs opened, and validateLoginViaAuthToken request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            };
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

function validateRegister(username, hashedPassword) {
    return new Promise((resolve, reject) => {
        devlog(username, hashedPassword);
        devlog("validateRegister called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        };

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateRegister",
                username: username,
                password: hashedPassword,
            }));
            console.log("servicesWs opened, and validateRegister request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            }
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

function onResourcesLoaded() {
    document.getElementById("mainMenu").style.display = "block";
    document.getElementById("nickname").disabled = false;
    showCornerButtons();
    resize();
    hideSpinner();
    customizer.startRendering();
    (consent = localStorage.getItem("consent")) && (consent = JSON.parse(consent));
    isFromEU && !consent && notify(document.getElementById("consent").innerHTML) //, aiptag.consented = consent && consent.ofAge && consent.targetedAds || !isFromEU, console.log("AIP consent: " + aiptag.consented)
};

function swiftShaderCheck() {
    if ("Google SwiftShader" != engine.getGlInfo().renderer || localStorage.getItem("swiftShaderNotice")) return false;
    return openAlertDialog("SwiftShader? GROSS!", '<div style="text-align: left">It looks like your graphics card is on Chrome\'s blacklist for some reason. The game will still run, but very slowly. To change this, enter "chrome://flags" in your address bar, search for "Override software rendering list", and enable it.<br><br>CAUTION: The blacklist exists for a reason. This may make your system unstable. Make sure you save anything you\'re working on before trying it!</div>', "OK"), localStorage.setItem("swiftShaderNotice", true), true
};

function getRequest(url, callback) {
    var req = new XMLHttpRequest;
    return !!req && ("function" != typeof callback && (callback = function () { }), req.onreadystatechange = function () {
        if (4 == req.readyState) return 200 === req.status ? callback(null, req.responseText) : callback(req.status, null)
    }, req.open("GET", url, true), req.send(null), req)
};

function closeFeedback() {
    inGame && captureKeys(), document.getElementById("feedback").style.display = "none", document.body.appendChild(document.getElementById("feedback")), closeAlertDialog()
};

function sendFeedback() {
    for (var emailEl = document.getElementById("feedbackEmail"), descriptionEl = document.getElementById("feedbackComments"), glInfo = engine.getGlInfo(), caps = engine.getCaps(), pickedWeaponIds = [], c = 0; c < CharClass.length; c++) pickedWeaponIds.push([playerAccount.pickedWeapons[c][0].id, playerAccount.pickedWeapons[c][1].id]);
    var debugJSON = "";
    debugObject.uuid = uuid;
    try {
        debugJSON = JSON.stringify({
            debugObject: debugObject,
            debugArray: debugArray
        })
    } catch (e) {
        console.log(e)
    } ! function (command, data, success, fail) {
        try {
            var serviceWs = new WebSocket(servicesServer)
        } catch (e) {
            console.log(e), fail && fail(e)
        }
        serviceWs.onopen = function (e) {
            data.cmd = command, serviceWs.send(JSON.stringify(data)), console.log("services opened, and " + command + " request sent")
        }, serviceWs.onmessage = function (e) {
            var response = JSON.parse(e.data);
            response.error ? (console.log(command + " error: " + JSON.stringify(response.error)), fail && fail(response.error)) : (console.log(command + " success"), success && success(response)), serviceWs.close()
        }, serviceWs.onclose = function (e) {
            console.log(command + " service closed: " + e.code + " " + e.reason), success && success(e)
        }, serviceWs.onerror = function (e) {
            console.log(command + " error: " + JSON.stringify(e, ["message", "arguments", "type", "name"])), fail && fail(e)
        }
    }("feedback", {
        feedbackType: document.getElementById("feedbackTypeSelect").selectedIndex,
        gameVersion: version,
        userAgent: window.navigator.userAgent,
        nickname: nickname,
        comments: descriptionEl.value,
        email: emailEl.value,
        // firebaseId: playerAccount.firebaseId || null,
        fromEU: isFromEU,
        gameServer: servers[selectedServer].name || null,
        session: playerAccount.session || null,
        ping: 0 < pingSamples ? Math.floor(pingTotal / pingSamples) : null,
        highestPing: highestPing || null,
        fps: 0 < fpsSamples ? Math.ceil(fpsTotal / fpsSamples) : null,
        gameType: gameType || null,
        privateGame: privateGame || null,
        localKills: kills || 0,
        localDeaths: deaths || 0,
        localStreak: bestOverallStreak || 0,
        url: parsedUrl.root,
        referrer: document.referrer,
        gameCode: gameCode || null,
        screenSize: screen.width + "x" + screen.height,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        innerSize: window.innerWidth + "x" + window.innerHeight,
        glVendor: glInfo.vendor,
        renderer: glInfo.renderer,
        glVersion: glInfo.version,
        maxTextureSize: caps.maxTextureSize,
        fov: camera ? camera.fov : null, //why tf it sends this? hack detection?
        controls: localStorage.getItem("controlConfig"),
        ofAge: consent ? consent.ofAge : null,
        targetedAds: consent ? consent.targetedAds : null,
        volume: settings.volume,
        mouseSensitivity: settings.mouseSensitivity,
        mouseInvert: settings.mouseInvert,
        holdToAim: settings.holdToAim,
        enableChat: settings.enableChat,
        autoDetail: settings.autoDetail,
        shadowsEnabled: settings.shadowsEnabled,
        highRes: settings.highRes,
        selectedClass: playerAccount.classIdx,
        selectedColor: playerAccount.colorIdx,
        hat: !playerAccount.hatItem ? null : playerAccount.hatItem.id,
        stamp: !playerAccount.stampItem ? null : playerAccount.stampItem.id,
        weapons: "[[0,0],[0,0],[0,0]]",
        timesPlayed: null,
        // xsollaToken: globalXsollaToken, //money!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        current_balance: playerAccount.currentBalance,
        // log: console.logArray(), note from author: this requires bwd's modified console function which is bad!
        debug: debugJSON
    }, function (res) {
        console.log(res), setTimeout(function () {
            notify("Your feedback has been received.<br>Thank you!", 3e3)
            // notify("we also just stole all ur fucking information ebcause we whores!")
        }, 1e3)
    }, function (err) {
        console.log(err)
    }), closeFeedback(), emailEl.value = "", descriptionEl.value = ""
};

function openJoinBox() {
    document.getElementById("customGame").style.display = "none", document.getElementById("joinGame").style.display = "block"
};

function play() {
    console.log("play()");
    dismissNotification();
    if (0 < settings.volume) try {
        BABYLON.Engine.audioEngine.audioContext.resume()
    } catch (e) {
        console.log(e)
    }
    0 == (nickname = document.getElementById("nickname").value.trim()).length && (nickname = randomName()), document.body.scrollTop = document.documentElement.scrollTop = 0, timesPlayed = getStoredNumber("timesPlayed", 0), localStorage.setItem("timesPlayed", timesPlayed + 1);
    var lastPreRoll = getStoredNumber("lastPreRoll", 0);
    0 == lastPreRoll && (lastPreRoll = Date.now(), localStorage.setItem("lastPreRoll", lastPreRoll)), adTest || Date.now() > lastPreRoll + 3e5 && timesPlayed % 2 == 1 && false ? (console.log("play() calls PVA"), playVideoAd()) : joinGame()
};

window.onbeforeunload = function (e) {
    if (0 < gameStartTime) {
        var timePlayed = Date.now() - gameStartTime;
        if (ga("send", "timing", "game", "play time", timePlayed), fbq("trackCustom", "EndGame", {
            timePlayed: timePlayed
        }), me && 0 < kills) {
            var ratio = Math.floor(kills / Math.max(kills + deaths, 1) * 100);
            ga("send", "event", "player stats", "kill ratio", classes[me.charClass].name, ratio), ga("send", "event", "player stats", "best kill streak", classes[me.charClass].name, bestOverallStreak)
        }
    }
    4 < pingSamples && (ga("send", "timing", "game", "ping", Math.floor(pingTotal / pingSamples), servers[selectedServer].name), ga("send", "event", "game", "stats", "fps", Math.ceil(fpsTotal / fpsSamples)), ga("send", "event", "game", "settings", "volume", settings.volume), ga("send", "event", "game", "settings", "mouse sensitivity", settings.mouseSensitivity), ga("send", "event", "game", "settings", "mouse invert", settings.mouseInvert))
};

var alertBarInterval, joinResult = null;

function joinGame() {
    var url;
    joinResult = null;
    var server = selectedServer;
    joinType = CommCode.joinPublicGame;
    var protocol = "ws://";
    "https:" === location.protocol && (protocol = "wss://");
    console.log("joinGame()", protocol);

    var joinGameId = document.getElementById("joinCode").value.trim(), mapId = 0;

    autoInvite = false;

    if ("none" != document.getElementById("createGame").style.display) {
        joinType = CommCode.createPrivateGame;
        url = protocol + servers[server].address;
        (mapId = document.getElementById("mapSelect").selectedIndex - 1) < 0 ? mapId = Math.randomInt(0, minMaps.length) : autoInvite = true;
    } else if ("" != joinGameId) {
        joinType = CommCode.joinPrivateGame;
        joinGameId.startsWith("#") && (joinGameId = joinGameId.substr(1));
        
        server = Number.parseInt(joinGameId.substr(0, 1), 36);
        gameId = Number.parseInt(joinGameId.substr(1, 3), 36);
        gameKey = Number.parseInt(joinGameId.substr(4, 2), 36);

        try {
            devlog(protocol, servers, server);
            url = protocol + servers[server].address;
        } catch (e) {
            return console.log("Game not found - Invalid server: " + url + ", " + server), openAlertDialog("Game Not Found", "Sorry! This game ID is either<br>invalid, or no longer exists.", {
                label: "OK"
            }), gameKey = gameId = 0, void (document.getElementById("joinCode").value = "")
        }
        selectedServer = server
    } else url = protocol + servers[server].address;
    showDarkOverlay(), showSpinner("Connecting", "Please wait!"), console.log("Connecting to: " + url),
    (ws = new WebSocket(url)).binaryType = "arraybuffer",
    ws.onopen = function (e) {
        console.log("WebSocket opened");
        localStorage.setItem("lastNickname", nickname);

        // ga("send", "event", "play game", "class", classes[playerAccount.classIdx].name);
        // fbq("trackCustom", "PlayGame", {
        //     charClass: classes[playerAccount.classIdx].name,
        //     server: servers[selectedServer].name
        // });

        //idk what this is for rn (worked it out now dw)
        var len = 16 + 2 * nickname.length;
        if (playerAccount.isLoggedIn) {
            console.log("id and session available", len);
            len += (2 * playerAccount.id.length) + (1 + (2 * playerAccount.session.length));
        };

        var output = new Comm.output(len);
        output.packInt8(CommCode.joinGame);
        output.packInt8(joinType);
        output.packInt8(gameType);
        output.packInt8(mapId);
        output.packInt16(gameId);
        output.packInt16(gameKey);
        output.packInt8(playerAccount.classIdx);
        output.packInt8(catalog.get8BitItemId(playerAccount.getPrimaryWeapon(), playerAccount.classIdx));
        output.packInt8(catalog.get8BitItemId(playerAccount.getSecondaryWeapon(), playerAccount.classIdx));
        output.packInt8(playerAccount.colorIdx);
        output.packInt8(catalog.get8BitItemId(playerAccount.hatItem, playerAccount.classIdx));
        output.packInt8(catalog.get8BitItemId(playerAccount.stampItem, playerAccount.classIdx));
        output.packString(nickname);
        devlog(len, output)
        if (playerAccount.isLoggedIn) {
            output.packString(playerAccount.session);
            devlog(len, output)
            output.packString(playerAccount.id);
            console.log("id: " + playerAccount.id);
            devlog(len, output)
        };
        ws.send(output.buffer);
    }, ws.onclose = function (e) {
        if (!freezeFrame)
            if (e.code == CloseCode.gameNotFound) console.log("Game not found - id: " + gameId + ", key: " + gameKey), openAlertDialog("Game Not Found", "Sorry! This game ID is either<br>invalid, or no longer exists.", {
                label: "OK"
            }), gameKey = gameId = 0, document.getElementById("joinCode").value = "";
            else if (e.code == CloseCode.gameFull) console.log("Game full - id: " + gameId + ", key: " + gameKey), openAlertDialog("Game Full", "Sorry, this game is currently full!<br>Wait a moment, or try another one!", {
                label: "OK"
            });
            else if (e.code == CloseCode.badName) {
                closeAlertDialog(), openAlertDialog("Invalid Name", "I'm going to guess you know why.", {
                    label: "Yes"
                });
                var el = document.getElementById("nickname");
                el.value = "", el.disabled = false, el.focus(), document.getElementById("playButton").disabled = false
            } else if (e.code == CloseCode.mainMenu) console.log("WebSocket closing - returning to Main Menu");
            else if (e.code == CloseCode.masterServerBusy) console.log("Master Server busy"), openAlertDialog("Matchmaker Busy", "Sorry! The match-maker is currently busy serving other players.<br>Please try again in a moment!", {
                label: "OK"
            }), gameKey = gameId = 0, document.getElementById("joinCode").value = "";
            else if (e.code == CloseCode.masterServerOffline) console.log("Master Server offline"), openAlertDialog("Matchmaker Offline", "Oops! The match-maker is currently inaccessible.<br>Drop us a line and let us know!", {
                label: "OK"
            }), gameKey = gameId = 0, document.getElementById("joinCode").value = "";
            else if (inGame) console.log("Connection lost: " + e.code + " " + e.reason), openAlertDialog("Connection Lost", "Please try a different server,<br>or try again later!", {
                label: "OK",
                onclick: reloadPage
            });
            else {
                console.log("Cannot connect: " + e.code + " " + e.reason);
                var message = "";
                switch (joinResult) {
                    case CommCode.banned:
                        message = "You are not allowed to join this game.<br><br>Maybe you know why?";
                        break;
                    default:
                        message = 'Please try a different server, reload<br>the page, or try again later!<br><br>Also, visit <a href="http://websocketstest.com" target="_window">websocketstest.com</a> to check for<br>problems with your network and/or system!'
                }
                openAlertDialog("Cannot Connect", message, {
                    label: "OK",
                    onclick: closeAlertDialog
                })
            }
    }, ws.onmessage = function (e) {
        var input = new Comm.input(e.data);
        switch (joinResult = input.unPackInt8U()) {
            case CommCode.gameJoined:
                console.log("CommCode.gameJoined received");
                document.getElementById("mainMenu").style.display = "none";
                meId = input.unPackInt8U();
                myTeam = input.unPackInt8U();
                gameType = input.unPackInt8U();
                gameId = input.unPackInt16U();
                gameKey = input.unPackInt16U();
                mapIdx = input.unPackInt8U();
                playerLimit = input.unPackInt8U();
                isGameOwner = 1 == input.unPackInt8U();
                console.log("is game owner: " + isGameOwner);
                inGame = true;
                startGame();
        }
    }
};

function setDetailSettingsVisibility(invisible) {
    var vis = invisible ? "hidden" : "visible";
    document.getElementById("extraDetails").style.visibility = vis, !invisible && inGame ? (settings.shadowsEnabled = gameScene.shadowsEnabled, settings.highRes = 1 == engine.getHardwareScalingLevel(), document.getElementById("shadowsEnabled").checked = settings.shadowsEnabled, document.getElementById("highRes").checked = settings.highRes, localStorage.setItem("shadowsEnabled", settings.shadowsEnabled ? "true" : "false"), localStorage.setItem("highRes", settings.highRes ? "true" : "false")) : inGame && (enableShadows(), increaseResolution())
};

function enableAutoDetail() {
    var opt = new BABYLON.SceneOptimizerOptions(40, 4e3),
        shadowOpt = new BABYLON.SceneOptimization(0);
    shadowOpt.apply = disableShadows, opt.optimizations.push(shadowOpt);
    var scalingOpt = new BABYLON.SceneOptimization(1);
    scalingOpt.apply = lowerResolution, opt.optimizations.push(scalingOpt), inGame && (optimizer = BABYLON.SceneOptimizer.OptimizeAsync(gameScene, opt))
};

function disableShadows() {
    return gameScene.shadowsEnabled = false, mapMesh && inGame && (mapMesh.material = gameScene.getMaterialByName("mapNoShadow")), true
};

function enableShadows() {
    gameScene.shadowsEnabled = true, mapMesh && inGame && (mapMesh.material = gameScene.getMaterialByName("map"))
};

function lowerResolution() {
    return engine.setHardwareScalingLevel(2), adaptToNewResolution(), true
};

function increaseResolution() {
    engine.setHardwareScalingLevel(1), adaptToNewResolution()
};

function adaptToNewResolution() {
    reticle && reticle.resize(), hitIndicator && hitIndicator.resize(), scope && scope.crosshairs.isEnabled() && scope.show()
};

function getStoredNumber(name, def) {
    var num = localStorage.getItem(name);
    return num ? Number(num) : def
}

function getStoredBool(name, def) {
    var str = localStorage.getItem(name);
    return str ? "true" == str : def
}

function getStoredString(name, def) {
    var str = localStorage.getItem(name);
    return str || def
}

function openAlertDialog(header, text, button1, button2, bar) {
    hideSpinner(), showDarkOverlay(), document.getElementById("alert").style.display = "block", document.getElementById("alertHeader").innerHTML = header, document.getElementById("alertMessage").innerHTML = text;
    var e = document.getElementById("alertButton1");
    (button1 ? (e.style.display = "inline-block", e.style.visibility = "visible", e.innerHTML = button1.label || "OK", e.style.width = button1.width || "8em", e.style.height = button1.height || "", e.onclick = button1.onclick || closeAlertDialog) : e.style.display = "none", e = document.getElementById("alertButton2"), button2 ? (e.style.display = "inline-block", e.style.visibility = "visible", e.innerHTML = button2.label || "Cancel", e.style.width = button2.width || "8em", e.style.height = button2.height || "", e.onclick = button2.onclick || closeAlertDialog) : e.style.display = "none", bar) ? function () {
        var el = document.getElementById("alertFooter");
        el.style.display = "block", alertBarInterval = interval.set(function () {
            el.innerText += "-", 10 < el.innerText.length && (el.innerText = "-")
        }, 200)
    }() : (document.getElementById("alertFooter").style.display = "none", interval.clear(alertBarInterval));
    document.exitPointerLock(), window.onkeydown = null, window.onkeyup = null
}

function closeAlertDialog() {
    document.getElementById("alert").style.display = "none", document.getElementById("alertFooter").style.display = "none", document.getElementById("nickname").disabled = false, hideDarkOverlay(), clearInterval(alertBarInterval)
};

function showDarkOverlay() {
    closeAlertDialog(), document.getElementById("overlay").style.display = "block", hideBannerAd(), hideMultisizeBannerAd(), document.getElementById("showBuyPassDialogButton").classList.add("hideme")
};

function hideDarkOverlay() {
    document.getElementById("overlay").style.display = "none", showBannerAd(), inGame || !playerAccount.isLoggedIn || playerAccount.isUpgraded() || document.getElementById("showBuyPassDialogButton").classList.remove("hideme")
};

function showMainMenuConfirm() {
    openAlertDialog("Main Menu", "Leave game and return<br>to the main menu?", {
        label: "Yes",
        width: "4em",
        onclick: showMainMenu
    }, {
        label: "No",
        width: "4em",
        onclick: closeAlertDialog
    })
};

function reloadPage() {
    window.location.reload()
};

function showMainMenu() {
    if (engine && engine.stopRenderLoop(), document.body.style.overflow = "visible", window.scrollY = 0, viewingPlayerId = meId = 0, inGame) {
        // document.getElementById("menuAdContainer").appendChild(document.getElementById("bannerAdContainer")), document.getElementById("inGameAd").style.display = "none;";
        me && (playerAccount.kills += kills, playerAccount.deaths += deaths, playerAccount.streak = Math.max(bestOverallStreak, playerAccount.streak), updatePlayerStatsDisplay()), closeAlertDialog(), interval.clearAll(), timeout.clearAll(), fetchTwitchStreams(), pingServers(), hideGameDom();
        // var oneSignalBell = document.getElementById("onesignal-bell-container");
        //oneSignalBell && (oneSignalBell.style.display = "inline-block"), 
        //this statement is so convoluted that i have no idea how this will be affected
        if (playerAccount.isLoggedIn && !playerAccount.isUpgraded() && document.getElementById("showBuyPassDialogButton").classList.remove("hideme"), document.getElementById("upgradeIndicator").classList.remove("ingame"), ws.close(CloseCode.mainMenu), ws = null, releaseKeys(), 0 < gameStartTime) {
            var timePlayed = Date.now() - gameStartTime;
            if (ga("send", "timing", "game", "play time", timePlayed), fbq("trackCustom", "EndGame", {
                timePlayed: timePlayed
            }), me && 0 < kills) {
                var ratio = Math.floor(kills / Math.max(kills + deaths, 1) * 100);
                ga("send", "event", "player stats", "kill ratio", classes[me.charClass].name, ratio), ga("send", "event", "player stats", "best kill streak", classes[me.charClass].name, bestOverallStreak)
            }
        }
        gameScene.dispose(), inGame = false, customizer = new Customizer(function () {
            document.getElementById("mainMenu").style.display = "block", showSmallAd()
        }), extern.customizer = customizer
    } else document.getElementById("mainMenu").style.display = "block"
};

function openCustomizerFromMainMenu() {
    hideBannerAd(), hideMultisizeBannerAd(), menuOut("mainMenu"), customizer.open()
};

function onFullscreenChange() {
    engine.resize()
};

function openSettingsMenu() {
    inGame && 1 == settings.enableChat && initChatIn(), hideBannerAd(), hideMultisizeBannerAd(), menuIn("settingsMenu")
};

function closeSettingsMenu() {
    menuOut("settingsMenu")
};

function fixStringWidth(str, len) {
    len = len || 80;
    var context = nameTestCanvas.getContext("2d");
    for (context.font = "1em Nunito, sans-serif"; ;) {
        if (context.measureText(str).width < len) break;
        str = str.substr(0, str.length - 1)
    }
    return str
}

function notify(msg, timeout) {
    var e = document.getElementById("notification");
    e.style.opacity = 0, e.style.top = "-3.5em", e.style.display = "flex", document.getElementById("notificationMessage").innerHTML = msg;
    var anim = 0,
        animIn = setInterval(function () {
            anim++, e.style.opacity = anim / 8, e.style.top = anim / 2 - 3.5 + "em", 8 == anim && (clearInterval(animIn), timeout && setTimeout(function () {
                dismissNotification()
            }, timeout))
        }, 32)
};

function dismissNotification(callback) {
    var anim = 8,
        e = document.getElementById("notification"),
        animIn = setInterval(function () {
            e.style.opacity = anim / 8, e.style.top = anim / 2 - 3.5 + "em", 0 == --anim && (clearInterval(animIn), e.style.display = "none", callback && callback())
        }, 32)
};

function promoteLogin() {
    var str = 'Login to enable this feature and others, including:<ul style="text-align: left"><li>Stat tracking - kills, deaths, etc.<li>Custom shell colors<li>Hats and accessories<li>Weapon skins</ul>';
    inGame ? openAlertDialog("Feature Unavailable to Guests", str, {
        label: "OK",
        width: "6em",
        onclick: closeAlertDialog
    }) : openAlertDialog("Feature Unavailable to Guests", str, {
        label: "Login",
        width: "6em",
        onclick: openLoginDialog
    }, {
        label: "Close",
        width: "6em",
        onclick: closeAlertDialog
    })
};

function showCornerButtons() {
    document.getElementById("cornerButtons").style.display = "block"
};

function hideGameDom() {
    document.getElementById("game").style.display = "none", document.getElementById("readouts").style.display = "none", document.getElementById("homeButton").style.display = "none", document.getElementById("friendsButton").style.display = "none"
};

function updatePlayerStatsDisplay() {
    var ratio = Math.floor(playerAccount.kills / Math.max(playerAccount.deaths, 1) * 100) / 100;
    document.getElementById("playerStatValues").innerHTML = playerAccount.kills.toLocaleString() + "<br>" + playerAccount.deaths.toLocaleString() + "<br>" + ratio + "<br>" + playerAccount.streak.toLocaleString()
};

function detectChromebook() {
    return /\bCrOS\b/.test(navigator.userAgent)
};

function unbloated2() { //no thanks!
    // console.log("Sending gameplay tags to OneSignal...");
    // var gameplayTags = {
    //     username: username,
    //     fps: Math.floor(fpsAverage)
    // };
    // unbloated3(gameplayTags), console.log("tags: " + JSON.stringify(gameplayTags))
};

function unbloated3(tags) { //nope! thanks!
    // OneSignal.push(function () {
    //     OneSignal.sendTags(tags).then(function (tagsSent) {
    //         console.log("Completed sending tags to OneSignal")
    //     })
    // })
};

function updateCurrentBalance() {
    document.getElementById("currentBalanceContainer").style.display = "inline-block", document.getElementById("currentBalance").innerText = playerAccount.currentBalance
};

function menuIn(domName, callback) {
    document.getElementById(domName).style.display = "block", callback && callback()
};

function menuOut(domName) {
    document.getElementById(domName).style.display = "none"
};

function menuFlexIn(domName) {
    document.getElementById(domName).style.display = "flex"
}
document.onfullscreenchange = onFullscreenChange, document.onmsfullscreenchange = onFullscreenChange, document.onmozfullscreenchange = onFullscreenChange, document.onwebkitfullscreenchange = onFullscreenChange;
var interval = {
    intervals: {},
    set: function (func, delay) {
        var newInterval = setInterval.apply(window, [func, delay].concat([].slice.call(arguments, 2)));
        return interval.intervals[newInterval] = true, newInterval
    },
    clear: function (handle) {
        return delete interval.intervals[handle], clearInterval(handle)
    },
    clearAll: function () {
        for (var all = Object.keys(interval.intervals), len = all.length; 0 < len--;) clearInterval(all.shift());
        interval.intervals = {}
    }
},
    timeout = {
        timeouts: {},
        set: function (func, delay) {
            var newTimeout = setTimeout.apply(window, [func, delay].concat([].slice.call(arguments, 2)));
            return timeout.timeouts[newTimeout] = true, newTimeout
        },
        clear: function (handle) {
            return delete timeout.timeouts[handle], clearTimeout(handle)
        },
        clearAll: function () {
            for (var all = Object.keys(timeout.timeouts), len = all.length; 0 < len--;) clearTimeout(all.shift());
            timeout.timeouts = {}
        }
    };

function randomName() {
    //69 is literally illegal!!!11
    for (var num, n1 = ["Captain", "Lord", "Supreme", "Master", "Pro", "Noob"], n2 = ["Egg", "Yolk", "Shell", "Cluck", "Chick", "Bird"]; 69 == (num = Math.randomInt(1, 99)););
    return 0 == Math.randomInt(0, 2) ? n1[Math.randomInt(0, n1.length)] + n2[Math.randomInt(0, n2.length)] + num : n2[Math.randomInt(0, n2.length)] + n1[Math.randomInt(0, n1.length)] + num
}

function checkBalance() {
    console.log("checkBalance called");
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify({
            cmd: "checkBalance",
            session: playerAccount.session
        })), console.log("servicesWs opened, and checkBalance request sent")
    }, servicesWs.onmessage = function (e) {
        checkBalanceData = JSON.parse(e.data), checkBalanceData.error ? console.log("checkBalance Error: " + JSON.stringify(checkBalanceData.error)) : playerAccount.currentBalance != checkBalanceData.current_balance && (playerAccount.currentBalance = checkBalanceData.current_balance, updateCurrentBalance()), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log("servicesWs closed: " + e.code + " " + e.reason)
    }, servicesWs.onerror = function (e) {
        statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
    }
};

function openBuyPassDialog() {
    playerAccount.isLoggedIn && (showDarkOverlay(), document.getElementById("buyPassDialog").classList.toggle("hideme"), document.exitPointerLock(), window.onkeydown = null, window.onkeyup = null)
};

function closeBuyPassDialog() {
    document.getElementById("buyPassDialog").classList.toggle("hideme"), hideDarkOverlay()
};

function buyChickenNuggetProduct() {
    isGettingNugget = false;
    callApi({
        cmd: "buyProduct",
        token: servicesToken,
        sku: "chicken_nugget_pass"
    }, showBoughtNuggetPopup, function (response) {
        openAlertDialog("Uh Oh!", "Something broke. Try reloading the game.", null, {
            label: "OK",
            width: "4em",
            onclick: closeAlertDialog
        })
    }), servicesToken = null
}

function showBoughtNuggetPopup() {
    setApplixirPopup(false), document.getElementById("gotNuggetPopup").classList.toggle("hideme");
};

var waitIteration = 0;

function waitForSetupAndAuthComplete() {
    200 <= waitIteration ? openAlertDialog("", '<div id="setupAndAuthTimedOut">Uh oh, there was a problem. Try reloading the page.</div>', {
        label: "Close",
        width: "8em",
        onclick: closeAlertDialog
    }) : null != customizer && true === customizer.isReady && authAttemptComplete && houseAdsLoaded ? (customizer.setupItems(), customizer.dressUpEgg(), setupUpgradeUI(), pingServers(true, function () {
        var showDate;
        onResourcesLoaded(), isRunning = true, function () {
            var searchParams = new URLSearchParams(document.location.search);
            if (false === searchParams.has("showItem")) return false;
            var showItemId = parseInt(searchParams.get("showItem"));
            return false !== (Number.isInteger(showItemId) && null !== catalog.findItemById(showItemId) && false === linkItemShown) && (linkItemShown = openItemInCustomizer(showItemId))
        }() || tryShowTaggedItems() || tryShowNugget() || true;
    })) : (waitIteration++, setTimeout(waitForSetupAndAuthComplete, 100))
};

function openItemInCustomizer(itemId) {
    if (!playerAccount.isLoggedIn) return promoteLogin(), false;
    document.getElementById("bigAd").style.display = "none", openCustomizerFromMainMenu();
    var item = catalog.findItemById(itemId);
    return customizer.openToItem(item), true
}

function tryShowTaggedItems() {
    if (null === showTaggedItems) return false;
    var shown = openTaggedItemsInCustomizer(showTaggedItems);
    return true === shown && (showTaggedItems = null), shown
}

function tryShowNugget() {
    return null !== showNugget && !playerAccount.isUpgraded() && (playerAccount.isLoggedIn ? (document.getElementById("bigAd").style.display = "none", openBuyPassDialog(), void (showNugget = null)) : (promoteLogin(), false))
};

function openTaggedItemsInCustomizer(tag) {
    return playerAccount.isLoggedIn ? (openCustomizerFromMainMenu(), customizer.openToTaggedItems(tag), true) : (promoteLogin(), false)
};

function showSpinner(header, footer) {
    document.getElementById("spinner").style.display = "block", document.getElementById("spinnerHeader").innerText = header, document.getElementById("spinnerFooter").innerText = footer
}

function hideSpinner() {
    document.getElementById("spinner").style.display = "none"
};

function checkUpgrade() {
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    var beforeStatus = playerAccount.isUpgraded();
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify({
            cmd: "getUpgrade",
            session: playerAccount.session
        })), console.log("servicesWs opened, and getUpgrade request sent")
    }, servicesWs.onmessage = function (e) {
        getUpgradeData = JSON.parse(e.data);
        devlog(getUpgradeData);
        getUpgradeData.error ? console.log("getUpgrade Error: " + JSON.stringify(getUpgradeData.error)) : (playerAccount.setUpgrade(getUpgradeData), setupUpgradeUI(), playerAccount.isUpgraded() && false === beforeStatus && loadBannerAd()), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log("servicesWs closed: " + e.code + " " + e.reason)
    }, servicesWs.onerror = function (e) {
        statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
    }
};

function setupUpgradeUI() {
    var buyPassDialog = document.getElementById("showBuyPassDialogButton"),
        upgradeIndicator = document.getElementById("upgradeIndicator");
    playerAccount.isLoggedIn ? playerAccount.isUpgraded() ? (buyPassDialog.classList.add("hideme"), upgradeIndicator.style.display = "block", customizer.setExtraColorState(true)) : (inGame ? upgradeIndicator.classList.remove("ingame") : buyPassDialog.classList.remove("hideme"), upgradeIndicator.style.display = "none", customizer.setExtraColorState(false)) : (buyPassDialog.classList.add("hideme"), upgradeIndicator.style.display = "none", customizer.setExtraColorState(false)), adBlock && document.getElementById("buyNugget").remove()
};

function createShowItemListHTML(numItems) {
    for (var itemContainer = document.getElementById("showItemContainer").cloneNode(true), itemList = itemContainer.querySelector("#showItemList"), i = 0; i < numItems; i++) {
        var appendIndexToId = function (element) {
            element.id += "_" + i
        },
            itemTemplate = document.getElementById("showItemTemplate").cloneNode(true);
        appendIndexToId(itemTemplate), appendIndexToId(itemTemplate.querySelector("#showItemCanvas")), appendIndexToId(itemTemplate.querySelector("#showItemName")), 1 < numItems && (itemTemplate.style.float = "left"), 0 < i && itemTemplate.classList.add("showItemTemplateLeft"), itemList.appendChild(itemTemplate)
    }
    return itemContainer.class = "", itemContainer
}

function renderItemsInShowItemList(items) {
    for (var i = 0; i < items.length; i++) {
        var itemCanvas = document.getElementById("showItemCanvas_" + i);
        items[i].renderToCanvas(itemCanvas), document.getElementById("showItemName_" + i).innerHTML = items[i].name
    }
};

function callApi(apiRequest, successCallback, errorCallback, closeCallback) {
    console.log(apiRequest.cmd + " called");
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify(apiRequest)), console.log("servicesWs opened, and " + apiRequest.cmd + " request sent")
    }, servicesWs.onmessage = function (e) {
        var response = null;
        try {
            response = JSON.parse(e.data)
        } catch (e) {
            return console.log("Invalid data returned from services API"), void errorCallback()
        }
        response.error ? (console.log(apiRequest.cmd + " error: " + JSON.stringify(response.error)), errorCallback(response)) : successCallback(response), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log(apiRequest.cmd + " servicesWs closed: " + e.code + " " + e.reason), closeCallback && closeCallback()
    }, servicesWs.onerror = function (e) {
        errorCallback()
    }
};

function getLocText(stringId) {
    return language[stringId][currentLanguage]
}

playerAccount = new function () {
    this.loggedOut = function () {
        this.session = null, this.kills = 0, this.deaths = 0, this.streak = 0, this.currentBalance = 0, this.classIdx = 0, this.inventory = [], this.pickedWeapons = [], this.stampItem = null, this.hatItem = null, this.colorIdx = 0, this.isLoggedIn = false, this.killMultiplier = 1, this.hideAds = false, this.upgradeExpiryDate = null, this.upgradeIsExpired = false, this.maybeSchoolEmail = false;
        for (var cIdx = 0; cIdx < CharClass.length; cIdx++) {
            var defaultPicks = [catalog.forClass[cIdx].primaryWeapons[0], catalog.forClass[cIdx].secondaryWeapons[0]];
            this.pickedWeapons.push(defaultPicks)
        }
    }, this.setClass = function (classIdx) {
        this.classIdx = classIdx
    }, this.pickWeapon = function (slot, weaponItem) {
        var foundInList = catalog.findItemInListById(weaponItem, catalog.forClass[this.classIdx].forWeaponSlot[slot]);
        false === foundInList && (weaponItem = catalog.forClass[this.classIdx].forWeaponSlot[slot][0]), this.pickedWeapons[this.classIdx][slot] = weaponItem
    }, this.getPickedWeaponInSlot = function (slot) {
        return this.pickedWeapons[this.classIdx][slot]
    }, this.getPrimaryWeapon = function () {
        return this.getPickedWeaponInSlot(Slot.Primary)
    }, this.getSecondaryWeapon = function () {
        return this.getPickedWeaponInSlot(Slot.Secondary)
    }, this.isUpgraded = function () {
        return void 0 !== this.upgradeProductId && null !== this.upgradeProductId && false === this.upgradeIsExpired
    }, this.isItemOwned = function (item) {
        for (var i = 0; i < this.inventory.length; i++)
            if (this.inventory[i] && this.inventory[i].id === item.id) return true;
        return false
    }, this.getEquippedItems = function () {
        var equippedItems = [this.getPrimaryWeapon(), this.getSecondaryWeapon()];
        return null !== this.hatItem && equippedItems.push(this.hatItem), null !== this.stampItem && equippedItems.push(this.stampItem), equippedItems
    }, this.isItemEquipped = function (item) {
        if (null === item) return false;
        var foundItem = catalog.findItemInListById(item.id, this.getEquippedItems());
        return null !== foundItem
    }, this.loggedIn = function (accountData) {
        devlog("this.loggedIn", accountData);
        var hasValue = function (a) {
            return null != a && 0 !== a
        };
        this.username = accountData.username;
        this.id = String(accountData.id);
        this.adminRoles = accountData.adminRoles;
        this.session = accountData.session;
        this.kills = accountData.kills;
        this.deaths = accountData.deaths;
        this.streak = accountData.streak;
        this.currentBalance = accountData.currentBalance;
        this.ownedItemIds = accountData.ownedItemIds;
        this.upgradeProductId = accountData.upgradeProductId;
        this.killMultiplier = hasValue(accountData.upgradeMultiplier) ? accountData.upgradeMultiplier : 1;
        this.hideAds = !!hasValue(accountData.upgradeAdFree) && accountData.upgradeAdFree;
        this.upgradeExpiryDate = hasValue(accountData.upgradeExpiryDate) ? accountData.upgradeExpiryDate : null;
        this.upgradeIsExpired = hasValue(accountData.upgradeExpiryDate) ? accountData.upgradeIsExpired : null;
        this.maybeSchoolEmail = accountData.maybeSchoolEmail;
        var version = void 0 === accountData.version || null === accountData.version ? 1 : accountData.version;
        localStorage.setItem("LegacyShellAuthToken", accountData.authToken);
        localStorage.setItem("LegacyShellPreviousUsername", accountData.username);

        if (1 <= version) {
            if (void 0 !== accountData.loadout && null !== accountData.loadout) {
                void 0 !== accountData.loadout.classIdx && null !== accountData.loadout.classIdx && this.setClass(accountData.loadout.classIdx);
                for (var outer = this, trySetPickedWeapon = function (weaponId, classIdx, slot) {
                    var weaponItem = catalog.forClass[classIdx].forWeaponSlot[slot][0];
                    hasValue(weaponId) && (weaponItem = catalog.findItemById(weaponId)), outer.pickedWeapons[classIdx][slot] = weaponItem
                }, c = 0; c < CharClass.length; c++) trySetPickedWeapon(accountData.loadout.primaryId[c], c, Slot.Primary), trySetPickedWeapon(accountData.loadout.secondaryId[c], c, Slot.Secondary);
                if (hasValue(accountData.loadout.hatId)) {
                    var hatItem = catalog.findItemById(accountData.loadout.hatId);
                    this.hatItem = hatItem
                }
                if (hasValue(accountData.loadout.stampId)) {
                    var stampItem = catalog.findItemById(accountData.loadout.stampId);
                    this.stampItem = stampItem
                }
                hasValue(accountData.loadout.colorIdx) && (this.colorIdx = accountData.loadout.colorIdx, 7 <= this.colorIdx && false === this.isUpgraded() && (this.colorIdx = 0))
            }
            if (hasValue(accountData.ownedItemIds))
                for (var i = 0; i < accountData.ownedItemIds.length; i++) {
                    var item = catalog.findItemById(accountData.ownedItemIds[i]);
                    this.inventory.push(item)
                }
        }
        this.isLoggedIn = true
    }, this.setUpgrade = function (getUpgradeData) {
        this.upgradeProductId = getUpgradeData.upgradeProductId;
        this.multiplier = getUpgradeData.multiplier;
        this.hideAds = getUpgradeData.hideAds;
        this.upgradeIsExpired = getUpgradeData.isExpired;
        7 <= this.colorIdx && false === this.isUpgraded() && (this.colorIdx = 0);
    }, this.syncToServer = function () {
        try {
            var servicesWs = new WebSocket(servicesServer)
        } catch (e) {
            console.log(e)
        }
        var updateHatId = void 0 !== playerAccount.hatItem && null !== playerAccount.hatItem ? playerAccount.hatItem.id : null,
            updateStampId = void 0 !== playerAccount.stampItem && null !== playerAccount.stampItem ? playerAccount.stampItem.id : null,
            loadout = {
                cmd: "saveEquip",
                session: this.session,
                class_idx: this.classIdx,
                soldier_primary_item_id: this.pickedWeapons[CharClass.Soldier][Slot.Primary].id,
                soldier_secondary_item_id: this.pickedWeapons[CharClass.Soldier][Slot.Secondary].id,    
                scrambler_primary_item_id: this.pickedWeapons[CharClass.Scrambler][Slot.Primary].id,
                scrambler_secondary_item_id: this.pickedWeapons[CharClass.Scrambler][Slot.Secondary].id,
                ranger_primary_item_id: this.pickedWeapons[CharClass.Ranger][Slot.Primary].id,
                ranger_secondary_item_id: this.pickedWeapons[CharClass.Ranger][Slot.Secondary].id,
                eggsploder_primary_item_id: this.pickedWeapons[CharClass.Eggsploder][Slot.Primary].id,
                eggsploder_secondary_item_id: this.pickedWeapons[CharClass.Eggsploder][Slot.Secondary].id,
                hat_id: updateHatId,
                stamp_id: updateStampId,
                color: this.colorIdx,
                save: "undefined" == typeof checkStatus || checkStatus()
            },
            json = JSON.stringify(loadout);
        servicesWs.onopen = function (e) {
            servicesWs.send(json), console.log("servicesWs opened, and saveEquip request sent")
        }, servicesWs.onmessage = function (e) {
            responseData = JSON.parse(e.data), responseData.error ? console.log("SyncToServer Error: " + JSON.stringify(responseData.error)) : console.log("SyncToServer completed successfully"), servicesWs.close()
        }, servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason)
        }, servicesWs.onerror = function (e) {
            console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
        }
    }, this.loggedOut()
};


//  _____  _______ ___ ___ _  _ 
// | __\ \/ /_   _| __| _ \ \| |
// | _| >  <  | | | _||   / .` |
// |___/_/\_\ |_| |___|_|_\_|\_|
// [LS] ######## Extern ---------------------------------

var extern = function () {
    return {
        openLoginDialog: openLoginDialog,
        openRegisterDialog: openRegisterDialog,
        globalThis: globalThis,
        this_1: this,
        Items: Items,
        logout: function (callback) {
            // firebase.auth().signOut().then(function () {
            // }, function (err) {
            //     console.log(err)
            // })
            document.getElementById("login").style.display = "block";
            document.getElementById("logout").style.display = "none";
            document.getElementById("user-greeting").style.display = "none";
            document.getElementById("profilePic").style.display = "none";
            document.getElementById("playerStats").style.display = "none";
            document.getElementById("statsMessage").style.display = "none";
            document.getElementById("currentBalanceContainer").style.display = "none";
            document.getElementById("currentBalance").innerText = "0";
            playerAccount.loggedOut();
            setupUpgradeUI();
            user = null;
            delete localStorage.LegacyShellAuthToken;
            delete localStorage.LegacyShellPreviousUsername;
            customizer.dressUpEgg();
        },
        play: play,
        closeCreateGameDialog: function () {
            document.getElementById("createGameDialog").style.display = "none", hideDarkOverlay()
        },
        openServerList: function () {
            openAlertDialog("Servers", "", {
                label: "Close",
                width: "6em",
                onclick: closeServerList
            });
            for (var serverItem = document.getElementById("serverItem"), list = document.createElement("form"), barColors = ["lime", "yellow", "orange", "red"], i = 0; i < servers.length; i++) {
                var server = serverItem.cloneNode(true);
                server.style.display = "block";
                var border, pingColor, checkEl = server.children[0].children[0],
                    nameEl = server.children[0].children[1],
                    barEl = (server.children[0].children[2], server.children[0].children[3]),
                    offlineEl = server.children[0].children[4],
                    msEl = server.children[0].children[5];
                nameEl.innerText = servers[i].name, checkEl.value = i, servers[i].ping ? (border = Math.min(5.4, Math.max(0, (servers[i].ping - 50) / 65)) + .1, pingColor = Math.min(3, Math.floor(servers[i].ping / 100)), barEl.style.display = "block", offlineEl.style.display = "none", barEl.style.backgroundColor = barColors[pingColor], barEl.style.borderRight = border + "em solid var(--egg-brown)", msEl.innerText = servers[i].ping + "ms") : (barEl.style.display = "none", offlineEl.style.display = "block"), list.appendChild(server)
            }
            document.getElementById("alertMessage").appendChild(list), list.children[selectedServer].children[0].children[0].checked = true, list.addEventListener("change", function (e) {
                selectServer(e.target.value)
            })
        },
        openCustomizerFromMainMenu: openCustomizerFromMainMenu,
        openCustomizerInGame: function () {
            hideGameDom(), engine.stopRenderLoop(), customizer.open(), customizer.startRendering()
        },
        showFeedbackForm: function () {
            inGame && releaseKeys(), ga("send", "event", "feedback opened"), openAlertDialog("Feedback", "", {
                label: "Send",
                width: "6em",
                onclick: sendFeedback
            }, {
                label: "Cancel",
                width: "6em",
                onclick: closeFeedback
            }), document.getElementById("alertButton1").style.visibility = "hidden", document.getElementById("alertMessage").appendChild(document.getElementById("feedback")), document.getElementById("feedback").style.display = "block"
        },
        feedbackChanged: function (e) {
            var fd = document.getElementById("feedbackComments"),
                fe = document.getElementById("feedbackEmail");
            feedbackValidateTimeout && clearTimeout(feedbackValidateTimeout), feedbackValidateTimeout = setTimeout(function () {
                "" != fd.value && "" != fe.value ? document.getElementById("alertButton1").style.visibility = "visible" : document.getElementById("alertButton1").style.visibility = "hidden"
            }, 200)
        },
        selectGameType: function (i) {
            gameType = i, localStorage.setItem("gameType", i)
        },
        openJoinBox: openJoinBox,
        closeJoinBox: function () {
            document.getElementById("customGame").style.display = "block", document.getElementById("joinGame").style.display = "none", document.getElementById("joinCode").value = "", history.replaceState(null, null, location.pathname)
        },
        openCreateBox: function () {
            document.getElementById("customGame").style.display = "none", document.getElementById("createGame").style.display = "block"
        },
        closeCreateBox: function () {
            document.getElementById("customGame").style.display = "block", document.getElementById("createGame").style.display = "none"
        },
        showChangelog: function () {
            openAlertDialog("Version " + version, document.getElementById("changelog").innerHTML, {
                label: "OK"
            });
        },
        showConfig: function () {
            openAlertDialog("LegacyShell Config", document.getElementById("config").innerHTML, {
                label: "OK"
            });
        },
        respawn: function () {
            if (playOffline) return me.playing = true, void canvas.requestPointerLock();
            console.log("Respawn pressed - respawnTime: " + respawnTime), (null == respawnTime || respawnTime < 0) && (interval.clearAll(), timeout.clearAll(), timedGame ? requestRespawn() : isTimeToPlayVideoAd() ? playVideoAd() : requestRespawn())
        },
        copyFriendCode: copyFriendCode,
        dismissNotification: dismissNotification,
        closeSettingsMenu: closeSettingsMenu,
        setVolume: function (el) {
            settings.volume = el.value, localStorage.setItem("volume", settings.volume), BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume), 0 == settings.volume ? BABYLON.Engine.audioEngine.audioContext.suspend() : BABYLON.Engine.audioEngine.audioContext.resume()
        },
        setMusicVolue: function (el) {
            settings.musicVolume = el.value, localStorage.setItem("musicVolume", settings.musicVolume), Music.menu && Music.menu.setVolume(el.value), Music.game && Music.game.setVolume(el.value)
        },
        setMouseSensitivity: function (el) {
            settings.mouseSensitivity = el.value, localStorage.setItem("mouseSensitivity", settings.mouseSensitivity)
        },
        setCheckOption: function (el) {
            var val = el.checked;
            switch (el.id) {
                case "mouseInvert":
                    val = el.checked ? -1 : 1;
                    break;
                case "autoDetail":
                    el.checked ? enableAutoDetail() : (optimizer.stop(), optimizer.dispose(), optimizer = null), setDetailSettingsVisibility(el.checked);
                    break;
                case "shadowsEnabled":
                    el.checked ? enableShadows() : disableShadows();
                    break;
                case "highRes":
                    el.checked ? increaseResolution() : lowerResolution();
                    break;
                case "enableChat":
                    el.checked ? (document.getElementById("enableChat").checked = true, settings.enableChat = true, localStorage.setItem("enableChat", true), chatInEl.value = "Press ENTER to chat", inGame && (chatOutEl.style.display = "block", chatInEl.style.display = "block")) : (settings.enableChat = false, localStorage.setItem("enableChat", false), inGame && (chatOutEl.style.display = "none", chatInEl.style.display = "none"))
            }
            settings[el.id] = val, localStorage.setItem(el.id, val)
        },
        openPrivacyOptions: function () {
            // closeSettingsMenu(), openAlertDialog("Privacy Options", document.getElementById("privacyOptions").innerHTML, {
            //     label: "OK"
            // });
            // var ofAgeCheck = document.getElementById("ofAgeCheck"),
            //     targetedAdsCheck = document.getElementById("targetedAdsCheck");
            // targetedAdsCheck.checked = consent ? (ofAgeCheck.checked = consent.ofAge, consent.targetedAds) : (consent = {
            //     ofAge: false,
            //     targetedAds: false
            // }, ofAgeCheck.checked = false), consent.ofAge || (targetedAdsCheck.disabled = true, document.getElementById("targetedAdsText").style.opacity = .25)
        },
        switchTeamDialog: function () {
            openAlertDialog("", 1 == me.team ? 'Switch to team<h1 class="redTeam">RED?</h1>Your score will be reset!' : 'Switch to team<h1 class="blueTeam">BLUE?</h1>Your score will be reset!', {
                label: "Yes",
                width: "5em",
                onclick: switchTeam
            }, {
                label: "No",
                width: "5em",
                onclick: closeAlertDialog
            })
        },
        showMainMenuConfirm: showMainMenuConfirm,
        inviteFriends: inviteFriends,
        openSettingsMenu: openSettingsMenu,
        toggleFullscreen: function () {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) (f = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen) && f.call(document);
            else {
                var f, e = document.body;
                (f = e.requestFullscreen || e.webkitRequestFullscreen || e.mozRequestFullScreen || e.msRequestFullscreen) && (f.call(e), ga("send", "event", "fullscreen"))
            }
        },
        hideBigAd: hideBigAd,
        clickedBigAd: function () {
            ga("send", "event", {
                eventCategory: "Big ad",
                eventAction: "click",
                eventLabel: houseAds.big[bigAdIdx].label
            }), houseAds.big[bigAdIdx].linksToNugget && (showNugget = true, hideBigAd(), tryShowNugget())
        },
        doConsent: function () {
            dismissNotification(function () {
                notify(document.getElementById("doConsent").innerHTML)
            })//, ga("send", "event", "privacy", "age gate", "agree"), consent = {
                // ofAge: true,
                // targetedAds: true
            //}, document.getElementById("login").style.display = "block", aiptag.consented = true, localStorage.setItem("consent", JSON.stringify(consent))
        },
        dontConsent: function () {
            dismissNotification(function () {
                notify(document.getElementById("dontConsent").innerHTML)
            })//, ga("send", "event", "privacy", "age gate", "disagree"), consent = {
            //     ofAge: false,
            //     targetedAds: false
            // }, aiptag.consented = false, localStorage.setItem("consent", JSON.stringify(consent))
        },
        setOfAge: function (e) {
            // var targetedAdsCheck = document.getElementById("targetedAdsCheck"),
            //     targetedAdsText = document.getElementById("targetedAdsText");
            // consent.ofAge = e.checked, ga("send", "event", "privacy", "of age", e.checked ? "yes" : "no"), e.checked ? (targetedAdsCheck.disabled = false, targetedAdsText.style.opacity = 1, document.getElementById("login").style.display = "block") : (consent.targetedAds = false, targetedAdsCheck.checked = false, targetedAdsCheck.disabled = true, targetedAdsText.style.opacity = .25, aiptag.consented = false, document.getElementById("login").style.display = "none"), localStorage.setItem("consent", JSON.stringify(consent))
        },
        setTargetedAds: function (e) {
            //consent.targetedAds = e.checked, aiptag.consented = e.checked, ga("send", "event", "privacy", "targetedAds", e.checked ? "yes" : "no"), localStorage.setItem("consent", JSON.stringify(consent))
        },
        configKey: configKey,
        onChatKeyDown: function (e) {
            var key = (e = e || window.event).key;
            switch (chatInEl.value = fixStringWidth(chatInEl.value, 280), key) {
                case "Enter":
                    var text = chatInEl.value.trim();
                    if ("" != text && text.indexOf("<") < 0) {
                        var output = new Comm.output(2 + 2 * text.length);
                        output.packInt8(CommCode.chat), output.packString(text), ws.send(output.buffer), addChat(text, me), me.chatLineCap--
                    }
                case "Tab":
                    initChatIn(), e.preventDefault(), e.stopPropagation(), captureKeys()
            }
        },
        clickedHouseAd: function () {
            ga("send", "event", {
                eventCategory: "House banner ad",
                eventAction: "click",
                eventLabel: houseAds.small[smallAdIdx].label
            }), houseAds.small[smallAdIdx].link && window.open(houseAds.small[smallAdIdx].link, "_window"), houseAds.small[smallAdIdx].linksToTaggedItems && (showTaggedItems = houseAds.small[smallAdIdx].linksToTaggedItems, tryShowTaggedItems()), houseAds.small[smallAdIdx].linksToItemId && openItemInCustomizer(houseAds.small[smallAdIdx].linksToItemId), houseAds.small[smallAdIdx].linksToNugget && (showNugget = true, tryShowNugget())
        },
        buyItem: function (itemId) {
            console.log("buyItem called for item ID: " + itemId);
            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            servicesWs.onopen = function (e) {
                var buyData = {
                    cmd: "buy",
                    session: playerAccount.session,
                    item_id: itemId,
                    save: "undefined" == typeof checkStatus || checkStatus()
                };
                servicesWs.send(JSON.stringify(buyData))
            }, servicesWs.onmessage = function (e) {
                switch (purchaseResult = JSON.parse(e.data), console.log("purchase response: " + purchaseResult.result), purchaseResult.result) {
                    case "SUCCESS":
                        if (void 0 !== purchaseResult.item_id && null !== purchaseResult) {
                            var boughtItem = catalog.findItemById(purchaseResult.item_id);
                            playerAccount.inventory.push(boughtItem);
                            devlog("nice", boughtItem, purchaseResult);
                        };
                        playerAccount.currentBalance = purchaseResult.current_balance;
                        updateCurrentBalance();
                        // customizer.clearItemLocks();
                        try {
                            customizer.boughtItem();
                        } catch (error) {
                            devlog("bruh it happened", error);
                        }
                        customizer.physicalUnlockBack(); //idk. there is same gay error.
                        break;
                    case "INSUFFICIENT_FUNDS":
                        openAlertDialog("Need More Eggs!", "You need more eggs", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ALREADY_OWNED":
                        openAlertDialog("Already Owned", "You already have this. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "PLAYER_NOT_FOUND":
                        openAlertDialog("Uh Oh", "There was a problem. Try logging in again.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ITEM_NOT_FOUND":
                        openAlertDialog("Uh Oh", "There was a problem. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ERROR":
                    default:
                        console.log("buyItem error: " + purchaseResult.error), openAlertDialog("Uh Oh", "There was a problem. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null)
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            }
        },
        buyEggs: function () {
            // purchasingEnabled ? XPayStationWidget.open() : getXsollaToken(true, null)
        },
        Customizer,
        playerAccount,
        openRedeemCodeDialog: function () {
            showDarkOverlay(), document.getElementById("redeemCodeDialog").style.display = "inline-block";
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.value = "";
            redeemCodeInput.disabled = false;
            document.getElementById("enterRedeemCode").style.display = "inline-block";
            document.getElementById("redeemCodeResult").style.display = "none";
            document.getElementById("previewCodeResult").style.display = "none";
            document.exitPointerLock(), window.onkeydown = null, window.onkeyup = null
        },
        closeRedeemCodeDialog: function () {
            document.getElementById("redeemCodeDialog").style.display = "none", hideDarkOverlay()
        },
        redeemCode: function () {
            document.getElementById("previewCodeResult").style.display = "none";

            const previewCodeResult = document.getElementById("previewCodeResult");
            if (previewCodeResult) {
                const itemList = previewCodeResult.querySelector("#showItemList");
                if (itemList) {
                    itemList.innerHTML = '';
                };
            };

            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.disbled = true;
            var code = redeemCodeInput.value;
            console.log("redeem code called", code);
            code && 0 != code.length && (servicesWs.onopen = function (e) {
                servicesWs.send(JSON.stringify({
                    cmd: "redeem",
                    session: playerAccount.session,
                    code: code
                }))
            }, servicesWs.onmessage = function (e) {
                // devlog("SIR! SIR! DO NOT REDEEM! SIR!");
                let redeemResult = JSON.parse(e.data);
                devlog(redeemResult);

                if (redeemResult.error) console.log("redeemCode Error: " + JSON.stringify(redeemResult.error));
                else {
                    console.log("redeemCode response: " + redeemResult.result);
                    var redeemCodeResultText = document.getElementById("redeemCodeResultText"),
                        redeemCodeSuccessButton = document.getElementById("redeemCodeCompleteButton");
                    switch (document.getElementById("enterRedeemCode").style.display = "none", document.getElementById("redeemCodeResult").style.display = "inline-block", redeemResult.result) {
                        case "SUCCESS":
                            redeemCodeResultText.innerHTML = "<h1>CODE CRACKED!!</h1>", 0 < redeemResult.eggs_given && void 0 !== redeemResult.eggs_given && null !== redeemResult.eggs_given && 0 < redeemResult.eggs_given && (redeemCodeResultText.innerHTML += '<div style="margin-top: 1em; margin-bottom: 2em; text-align: center;"><img src="img/egg_icon.png" style="width: 2em;" /><h2>+ ' + redeemResult.eggs_given + " </h2></div>", checkBalance());
                            var items = [];
                            if (redeemResult.item_ids)
                                for (var i = 0; i < redeemResult.item_ids.length; i++) {
                                    var redeemedItem = catalog.findItemById(redeemResult.item_ids[i]);
                                    playerAccount.isItemOwned(redeemedItem) || playerAccount.inventory.push(redeemedItem), items.push(redeemedItem)
                                }
                            if (customizer.setupItems(), 0 < items.length) {
                                var itemList = createShowItemListHTML(items.length);
                                redeemCodeResultText.innerHTML += itemList.innerHTML, renderItemsInShowItemList(items)
                            }
                            redeemCodeSuccessButton.style = "ssbutton green";
                            break;
                        case "CODE_PREV_REDEEMED":
                            redeemCodeResultText.innerText = "That code has already been used!", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "CODE_NOT_FOUND":
                            redeemCodeResultText.innerText = "Invalid code", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "ERROR":
                            console.log("error: " + redeemResult.error), redeemCodeResultText.innerText = "Uh oh, there was problem", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        default:
                            redeemCodeResultText.innerText = "Uh oh, there was problem. Try logging in again.", redeemCodeSuccessButton.style = "ssbutton red"
                    }
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            })
        },
        //this code is really, really, really shit. im sorry. the original function was already super convoluted.
        previewCode: function () {
            console.log("preview code called");
            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.disbled = true;
            var code = redeemCodeInput.value;
            code && 0 != code.length && (servicesWs.onopen = function (e) {
                servicesWs.send(JSON.stringify({
                    cmd: "preview",
                    session: playerAccount.session,
                    code: code
                }))
            }, servicesWs.onmessage = function (e) {
                // devlog("SIR! SIR! DO NOT REDEEM! SIR!");
                let previewResult = JSON.parse(e.data);
                devlog(previewResult);
                
                if (previewResult.error) console.log("previewCode Error: " + JSON.stringify(previewResult.error));
                else {
                    console.log("previewCode response: " + previewResult.result);
                    
                    let previewOrRedeem = previewResult.result == "SUCCESS" ? "previewCode" : "redeemCode";

                    var previewCodeResultText = document.getElementById(previewOrRedeem+"ResultText"),
                    previewCodeSuccessButton = document.getElementById(previewOrRedeem+"CompleteButton");
                    document.getElementById("enterRedeemCode").style.display = "none";
                    document.getElementById(previewOrRedeem+"Result").style.display = "inline-block";

                    switch (previewResult.result) {
                        case "SUCCESS":
                            previewCodeResultText.innerHTML = "<h1>Do you want to crack this code?</h1>", 0 < previewResult.eggs_given && void 0 !== previewResult.eggs_given && null !== previewResult.eggs_given && 0 < previewResult.eggs_given && (previewCodeResultText.innerHTML += '<div style="margin-top: 1em; margin-bottom: 2em; text-align: center;"><img src="img/egg_icon.png" style="width: 2em;" /><h2>+ ' + previewResult.eggs_given + " </h2></div>", checkBalance());
                            var usesRemaining = document.getElementById("usesCount");
                            if (usesRemaining) {
                                usesRemaining.textContent = previewResult.uses || 0;
                            };
                            var items = [];
                            if (previewResult.item_ids)
                                for (var i = 0; i < previewResult.item_ids.length; i++) {
                                    var redeemedItem = catalog.findItemById(previewResult.item_ids[i]);
                                    playerAccount.isItemOwned(redeemedItem) || playerAccount.inventory.push(redeemedItem), items.push(redeemedItem)
                                }
                            if (customizer.setupItems(), 0 < items.length) {
                                var itemList = createShowItemListHTML(items.length);
                                previewCodeResultText.innerHTML += itemList.innerHTML, renderItemsInShowItemList(items)
                            }
                            previewCodeSuccessButton.style = "ssbutton green";
                            break;
                        case "CODE_PREV_REDEEMED":
                            previewCodeResultText.innerText = "That code has already been used!", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "CODE_NOT_FOUND":
                            previewCodeResultText.innerText = "Invalid code", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "ERROR":
                            console.log("error: " + previewResult.error), previewCodeResultText.innerText = "Uh oh, there was problem", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        default:
                            previewCodeResultText.innerText = "Uh oh, there was problem. Try logging in again.", previewCodeSuccessButton.style = "ssbutton red"
                    }
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            })
        },
        openItemInCustomizer: openItemInCustomizer,
        openTaggedItemsInCustomizer: openTaggedItemsInCustomizer,
        closeGiveRewardDialog: function () {
            document.getElementById("giveRewardDialog").style.display = "none", hideDarkOverlay()
        },
        openBuyPassDialog: openBuyPassDialog,
        closeBuyPassDialog: closeBuyPassDialog,
        setApplixirPopup: setApplixirPopup,
        showBoughtNuggetPopup: showBoughtNuggetPopup,
        buyPass: function () {
        },
        openChickenNugget: function () {
            const nuggetFrame = document.getElementById("nuggetGame_Frame");
            const buyPassDialog = document.getElementById("buyPassDialog");
            const nuggetInstruction = document.getElementById("nuggetGame_Instruction");
            const nuggetDone = document.getElementById("nuggetGame_Done");
            const gotNuggetOK = document.getElementById("gotNuggetOK");

            nuggetFrame.src = "app_nugget/index.html";
            buyPassDialog.classList.add("hideme");
            nuggetInstruction.classList.remove("hideme");
            nuggetDone.classList.add("hideme");
            gotNuggetOK.classList.add("invisible");

            callApi({
                cmd: "token",
                session: playerAccount.session
            }, handleTokenSuccess, handleTokenError);
        
            function handleTokenSuccess(response) {
                console.log("token: " + JSON.stringify(response.token));
                isGettingNugget = true;
                servicesToken = response.token;
                setApplixirPopup(true);
                showBoughtNuggetPopup();
            };
        
            function handleTokenError(response) {
                console.log("error getting token");
                openAlertDialog(
                    "Uh Oh!",
                    response.error || "Something broke. Try reloading the game.",
                    null,
                    {
                        label: "OK",
                        width: "4em",
                        onclick: function () {
                            closeAlertDialog();
                            buyPassDialog.classList.toggle("hideme");
                        }
                    }
                );
            }
        },
        finishChickenNuggetGame: function () {
            document.getElementById("nuggetGame_Instruction").classList.toggle("hideme"), document.getElementById("nuggetGame_Done").classList.toggle("hideme"), document.getElementById("gotNuggetOK").classList.toggle("invisible")
        },
        closeChickenNugget: function () {
            document.getElementById("nuggetGame_Frame").src = "about:blank", checkUpgrade();
            var adElement = document.getElementById("shellshock-io_multisize");
            adElement.style.display = "none", document.getElementById("gameAdContainer").appendChild(adElement), document.getElementById("gotNuggetPopup").classList.toggle("hideme"), hideDarkOverlay()
        },
        enterSpectatorMode: function () {
            me && (document.getElementById("spectate").style.display = "block", document.getElementById("gameMenu").style.display = "none", document.getElementById("gameSummary").style.visibility = "hidden", document.getElementById("ffaFinal").style.display = "none", document.getElementById("teamFinal").style.display = "none", timedGame && betweenRounds || (document.getElementById("deathBox").style.display = "none", document.getElementById("health").style.display = "block", document.getElementById("killTicker").style.display = "block", document.getElementById("playerList").style.display = "block", chatting && chatInEl.focus()), hideMultisizeBannerAd(), document.getElementById("gameAdContainer").style.display = "none", player = function () {
                for (var i = 0; i < playerLimit; i++)
                    if (i != meId && players[i] && players[i].playing) return players[i]
            }(), player.id != meId && (viewingPlayer.actor.hands.setRenderingGroupId(0), viewingPlayer.weapon.actor.gunMesh.setRenderingGroupId(0), viewingPlayer.actor.hat && viewingPlayer.actor.hat.setEnabled(true)), player.actor.hands.setRenderingGroupId(1), player.weapon.actor.gunMesh.setRenderingGroupId(1), player.actor.hat && player.actor.hat.setEnabled(false), player.actor.hideNameSprite(), viewingPlayerId = (viewingPlayer = player).id, doFirstPersonCamera(player), document.getElementById("spectatingName").innerText = player.name);
            var player
        },
        spectatorSelect: function () { },
        clearSettings: function () {
            localStorage.removeItem("volume"), localStorage.removeItem("mouseSensitivity"), localStorage.removeItem("mouseInvert"), localStorage.removeItem("holdToAim"), localStorage.removeItem("enableChat"), localStorage.removeItem("autoDetail"), localStorage.removeItem("shadowsEnabled"), localStorage.removeItem("highRes"), localStorage.removeItem("controlConfig"), loadSettings()
        },
        applixirAdStatusHandler: function (status) {
            switch (console.log("Applixir status: " + status), status) {
                case "ad-started":
                case "fb-started":
                    applixirAdWatched = false;
                    break;
                case "ad-watched":
                case "fb-watched":
                case "network-error":
                case "cors-error":
                case "ads-unavailable":
                    applixirAdWatched = true;
                    break;
                case "sys-closing":
                    true === applixirAdWatched ? buyChickenNuggetProduct() : setApplixirPopup(false), applixirAdWatched = false;
                    break;
                case "ad-blocker":
                    setApplixirPopup(false), openAlertDialog("Ad Blocker Detected", "No ads - No nugget", null, {
                        label: "Fine",
                        width: "4em",
                        onclick: function () {
                            closeAlertDialog()
                        }
                    })
            }
        }
    }
}();


//   ___ _    ___  ___   _   _    ___ ___ 
//  / __| |  / _ \| _ ) /_\ | |  / __/ __|
// | (_ | |_| (_) | _ \/ _ \| |__\__ \__ \
//  \___|____\___/|___/_/ \_\____|___/___/
// [LS] ######## Extern ---------------------------------

function globalSS() {
    return {
        minMaps: minMaps,
        mapTest: mapTest,
        // playOffline: playOffline, //bools = rekt
        mapIdx: mapIdx,
        inGame: inGame,
    };
}