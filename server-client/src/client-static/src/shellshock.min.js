//     _                                      __                      
//     /                                    /    )   /           /   /
//    /       __    __    __    __          \       /__    __   /   / 
//   /      /___) /   ) /   ) /   ' /   /    \     /   ) /___) /   /  
// _/____/_(___ _(___/_(___(_(___ _(___/_(____/___/___/_(___ _/___/___
//                  /                 /                               
//              (_ /              (_ /                                
// LegacyShell Team 2024, Blue Wizard Digital 2019

// [LS] ######## LegacyShell Specific ---------------------------------
//  _    ___ ___   _   _____   _____ _  _ ___ _    _    
// | |  | __/ __| /_\ / __\ \ / / __| || | __| |  | |   
// | |__| _| (_ |/ _ \ (__ \ V /\__ \ __ | _|| |__| |__ 
// |____|___\___/_/ \_\___| |_| |___/_||_|___|____|____|
const VERSION = `LEGACYSHELLVERSION`;
const devmode = LEGACYSHELLDEVMODE;

// [LS] ######## BABYLONSTART ---------------------------------
//  ___   _   _____   ___    ___  _  _ 
// | _ ) /_\ | _ ) \ / / |  / _ \| \| |
// | _ \/ _ \| _ \\ V /| |_| (_) | .` |
// |___/_/ \_\___/ |_| |____\___/|_|\_|
LEGACYSHELLBABYLON


// [LS] ######## Items ---------------------------------
//  ___ _____ ___ __  __ ___ 
// |_ _|_   _| __|  \/  / __|
//  | |  | | | _|| |\/| \__ \
// |___| |_| |___|_|  |_|___/
var Items = [
    ...LEGACYSHELLITEMS
];


// [LS] ######## Maps ---------------------------------
//  __  __   _   ___  ___ 
// |  \/  | /_\ | _ \/ __|
// | |\/| |/ _ \|  _/\__ \
// |_|  |_/_/ \_\_|  |___/
minMaps = LEGACYSHELLMINMAPS;


// [LS] ######## Bullshit ---------------------------------
//  ___ _   _ _    _    ___ _  _ ___ _____ 
// | _ ) | | | |  | |  / __| || |_ _|_   _|
// | _ \ |_| | |__| |__\__ \ __ || |  | |  
// |___/\___/|____|____|___/_||_|___| |_|  

//Q: What is "bullshit"?
//A: Defining of these small, weird, misc dicts/lists/funcs.

LEGACYSHELLCONSTANTS

var interval = new IntervalManagerConstructor();
var timeout = new TimeoutManagerConstructor();

var NextRoundTimeout = 20;
var skybox;
var skyboxMaterial;

var engine;
var camera;
var customizer;
var itemRenderer;
var stampTexture;
var canvas;
var shadowGen;
var engineCaps;
var ws;
var selectedServer;
var meId;
var isGameOwner;
var viewingPlayerId;
var myTeam;
var nickname;
var gameStartTime;
var pingTotal;
var pingSamples;
var fpsTotal;
var fpsSamples;
var gameId;
var gameKey;
var mapIdx;
var gameType;
var privateGame;
/*var firebaseUi,*/;
var user;
var timesPlayed;
var chatInEl;
var chatOutEl;
var killEl;
var statsEl;
var purchasingEnabled;
var lastVer;
var globalXsollaToken;
var joinType;
var inputToControlMap;
var optimizer;
var inGame = false;
var playOffline = false;
var mapTest = {};
var settings = {};
var nameTestCanvas = document.createElement("canvas");
var freezeFrame = false;
var highestPing = 0;
var playerAccount = {};
var testing = false;
var teamSummaryEls = [];
var loggingIn = false;
var noSkybox = false;
var linkItemShown = false;
var showTaggedItems = null;
var showNugget = null;
var authAttemptComplete = false;
var checkedForReward = false;
var isRunning = false;
var autoInvite = false;
var servicesToken = null;
var isGettingNugget = false;
var adBlock = false; //pretty sure off is better, although idk
var playerLimit = 18;

var alertBarInterval, joinResult = null;


var shake;
var controlEl;
var feedbackValidateTimeout;
var settingsKeyNames = ["up", "down", "left", "right", "jump", "fire", "scope", "reload", "weapon", "grenade", "unfocus"];
var settingsKeyCells = {};
var lastMouseMovement = {};

var reward = null;
var debugArray = [];
var debugObject = {};
var consent = void 0;

var bigAdIdx;
var smallAdIdx;
var aipPrerollPlayer;
var houseAds;
var adTest = false;
var houseAdsLoaded = false;
var applixirAdWatched = false;

if ("undefined" == typeof window) var fs = require("fs");
var bigAdTimeout;

var tv1 = new BABYLON.Vector3;
var tv2 = new BABYLON.Vector3;

var bulletHoleManager;
var explosionSmokeManager;
var explosionFireManager;
var shellFragManager;
var respawnTime;
var uiCamera;
var grenadePowerUp;
var chatting;
var mapOverview;
var scope;
var reticle;
var hitIndicator;
var lastTimeStamp;
var fpsAverage;
var escPressed;
var kills;
var deaths;
var bestOverallStreak;
var timedGame;
var roundLength;
var roundEndTime;
var roundRestartTime;
var betweenRounds;
var respawnInterval;
var oldClockSeconds;
var gameScene;
var shadowLight;
var me;
var viewingPlayer;
var grenadeThrowPower;
var players;
var nameTexture;
var nameSprites;
var mapMesh;
var gameCode;
var munitionsManager;
var itemManager;
var Sounds = {};
var Music = {};
var mapOverviewAxis = 0;

var SPS;
var chatParser = document.createElement("DIV");
var prevCmd = [];
var pingStartTime;
var rotInc = Math.PI / 2;
var debugWindow;
var lastKey = null;

var lastLeadingTeam = 1;

var waitIteration = 0;

//tbh idk when this is used, if at all :joe_shrug:
String.prototype.format = String.prototype.f = function () {
    for (var s = this, i = arguments.length; i--;) s = s.replace(new RegExp("\\{" + i + "\\}", "gm"), arguments[i]);
    return s;
};

// [LS] ######## Comms ---------------------------------
//   ___ ___  __  __ __  __ ___ 
//  / __/ _ \|  \/  |  \/  / __|
// | (_| (_) | |\/| | |\/| \__ \
//  \___\___/|_|  |_|_|  |_|___/

LEGACYSHELLCOMM

//receiving msgs
const LegacyShellOnMessage = function (msg) {
    var input = new Comm.In(msg.data); 
    while (input.isMoreDataAvailable()) {
        var cmd = input.unPackInt8U();
        // if (cmd !== Comm.Code.sync)
        devlog("received cmd: ", Comm.Convert(cmd), msg);
        switch (cmd) {
            case Comm.Code.pause:
                var playerId = input.unPackInt8U();

                var player = players[playerId];
                player && player.removeFromPlay();
                break;
            case Comm.Code.clientReady:
                console.log("Comm.Code.clientReady received");
                roundLength = input.unPackInt16U();
                roundEndTime = input.unPackInt32U();
                roundRestartTime = input.unPackInt32U();
                if (roundLength > 0) {
                    timedGame = true;
                    if (roundEndTime > 0) {
                        document.getElementById("gameClock").style.display = "block";
                        roundEndTime += Date.now();
                    } else if (roundRestartTime > 0) {
                        document.getElementById("gameClock").style.display = "none";
                        document.getElementById("goButton").className = "ssbutton grey";
                        document.getElementById("goButtonLabel").innerText = "Wait...";
                        document.getElementById("playerList").style.display = "none";
                        setRespawnTime(Math.floor(roundRestartTime / 1000));
                    } else {
                        respawnTime = -1;
                    };
                } else {
                    timedGame = false;
                    respawnTime = -1;
                };
                openGameMenu();
                startRendering();
                if (autoInvite) {
                    inviteFriends();
                };
                break;
            case Comm.Code.addPlayer:
                var id = input.unPackInt8U();
                var uniqueId = input.unPackInt32U();
                var name = input.unPackString();
                var classIdx = input.unPackInt8U();
                var username = input.unPackString();

                devlog("addPlayer", id, uniqueId, name, classIdx);

                17 < id && devlog("playerId out of bounds: " + id + ", " + name);
                var playerData = {
                    id: id,
                    uniqueId: uniqueId,
                    name: name,
                    classIdx: classIdx,
                    username: username,
                    team: input.unPackInt8U(),
                    primaryWeaponItem: catalog.findItemBy8BitItemId(ItemType.Primary, classIdx, input.unPackInt8U()),
                    secondaryWeaponItem: catalog.findItemBy8BitItemId(ItemType.Secondary, classIdx, input.unPackInt8U()),
                    shellColor: input.unPackInt8U(),
                    hatItem: catalog.findItemBy8BitItemId(ItemType.Hat, classIdx, input.unPackInt8U()),
                    stampItem: catalog.findItemBy8BitItemId(ItemType.Stamp, classIdx, input.unPackInt8U()),
                    x: input.unPackFloat(),
                    y: input.unPackFloat(),
                    z: input.unPackFloat(),
                    dx: input.unPackFloat(),
                    dy: input.unPackFloat(),
                    dz: input.unPackFloat(),
                    yaw: input.unPackRadU(),
                    pitch: input.unPackRad(),
                    score: input.unPackInt32U(),
                    kills: input.unPackInt16U(),
                    deaths: input.unPackInt16U(),
                    streak: input.unPackInt16U(),
                    totalKills: input.unPackInt32U(),
                    totalDeaths: input.unPackInt32U(),
                    bestGameStreak: input.unPackInt16U(),
                    bestOverallStreak: input.unPackInt16U(),
                    shield: input.unPackInt8U(),
                    hp: input.unPackInt8U(),
                    playing: input.unPackInt8U(),
                    weaponIdx: input.unPackInt8U(),
                    controlKeys: input.unPackInt8U(),
                    randomSeed: input.unPackInt16U(),
                    upgradeProductId: input.unPackInt8U()
                };
                if (!players[playerData.id]) {
                    if (meId === playerData.id) {
                        //do nothing for the me player
                    } else {
                        playerData.name = playerData.name.replace(/<|>/g, "");
                        if (playerData.name.length === 0) {
                            playerData.name = "Anonymous";
                        } else {
                            playerData.name = fixStringWidth(playerData.name);
                            if (censor.detect(playerData.name)) {
                                playerData.name = randomName();
                            };
                        };
                    };
                    addPlayer(playerData);
                };
                break;
            case Comm.Code.removePlayer:
                var playerId = input.unPackInt8U();
                removePlayer(playerId);
                break;
            case Comm.Code.roundEnd:
                console.log("END ROUND");
                prepareGameSummary();
                betweenRounds = true;
                document.getElementById("help").style.display = "none";
                document.getElementById("tipContainer").style.display = "block";
                document.getElementById("goButton").className = "ssbutton grey";
                document.getElementById("goButtonLabel").innerText = "Wait...";
                Sounds.endRound.play();
                timeout.set(showContinueDialog, 3e3);
                setRespawnTime(NextRoundTimeout);
                break;
            case Comm.Code.roundStart:
                console.log("START ROUND");
                betweenRounds = false;
                document.getElementById("gameClock").style.display = "block";
                roundEndTime = Date.now() + 1e3 * roundLength;
                break;
            case Comm.Code.spawnItem:
                var id = input.unPackInt16U(),
                    kind = input.unPackInt8U(),
                    x = input.unPackFloat(),
                    y = input.unPackFloat(),
                    z = input.unPackFloat();
                itemManager.spawnItem(id, kind, x, y, z);
                break;
            case Comm.Code.collectItem:
                var playerId = input.unPackInt8U(),
                    kind = input.unPackInt8U(),
                    applyToWeaponIdx = input.unPackInt8U(),
                    id = input.unPackInt16U();
                itemManager.collectItem(kind, id), playerId == meId && me.collectItem(kind, applyToWeaponIdx);
                break;
            case Comm.Code.die:
                var killedPlayerName, byPlayerName, killedId = input.unPackInt8U(),
                    byId = input.unPackInt8U(),
                    rs = input.unPackInt8U(),
                    killedPlayer = players[killedId],
                    byPlayer = players[byId];
                if (killedPlayer) {
                    killedPlayerName = killedPlayer.name;
                    var pos = new BABYLON.Vector3(killedPlayer.x, killedPlayer.y + .32, killedPlayer.z);
                    killedPlayer.actor.deathSound.setPosition(pos), killedPlayer.actor.deathSound.play();
                    var soundIdx = Math.randomInt(0, Sounds.death.length);
                    Sounds.death[soundIdx].setPosition(pos), Sounds.death[soundIdx].play(), shellFragBurst(killedPlayer, 80, .2, 40), yolkBurst(killedPlayer), killedPlayer.die(), killedPlayer.actor.mesh.position.x = killedPlayer.x, killedPlayer.actor.mesh.position.y = killedPlayer.y, killedPlayer.actor.mesh.position.z = killedPlayer.z
                } else killedPlayerName = "N/A";
                if (byPlayer) {
                    if (byPlayerName = byPlayer.name, !byPlayer.isDead()) {
                        if (byPlayer.scoreKill(), byId == meId) {
                            var el = document.getElementById("bestStreak");
                            el.innerText = "BEST STREAK: " + byPlayer.bestOverallStreak
                        }
                        byId == meId && (kills++, bestOverallStreak = Math.max(bestOverallStreak, byPlayer.streak))
                    }
                } else byPlayerName = "N/A";
                if (killedId != meId) {
                    if (byId == meId) {
                        var killBox = document.getElementById("killBox");
                        killBox.style.display = "block", document.getElementById("KILLED_NAME").innerText = killedPlayerName;
                        var streakEl = document.getElementById("KILL_STREAK");
                        1 < me.streak ? streakEl.innerText = me.streak + "-KILL STREAK" : streakEl.innerText = "";
                        var scale = 1.5,
                            scaleInterval = interval.set(function () {
                                killBox.style.transform = "scale(" + scale + "," + scale + ")", (scale -= .05) <= 1 && (scale = 1, interval.clear(scaleInterval))
                            }, 33);
                        timeout.set(function () {
                            inGame && (killBox.style.display = "none")
                        }, 4e3)
                    }
                } else {
                    camera.parent = null, camera.position = new BABYLON.Vector3(viewingPlayer.actor.mesh.position.x, viewingPlayer.actor.mesh.position.y + .2, viewingPlayer.actor.mesh.position.z), byPlayer && (camera.lockedTarget = byPlayer.actor.bodyMesh), document.getElementById("KILLED_BY_NAME").innerText = byPlayerName;
                    var deathBox = document.getElementById("deathBox");
                    deathBox.style.display = "block";
                    var scale = 2,
                        scaleInterval = interval.set(function () {
                            deathBox.style.transform = "scale(" + scale + "," + scale + ")", (scale -= .05) <= 1 && inGame && (interval.clear(scaleInterval), scale = 1)
                        }, 33);
                    deaths++, setRespawnTime(rs), removeCanvasListeners(), timeout.set(function () {
                        inGame && (deathBox.style.display = "none", viewingPlayerId == meId && openGameMenu())
                    }, 3e3)
                }
                byPlayer && killedPlayer && addKillText(byPlayer, killedPlayer), rebuildPlayerList();
                break;
            case Comm.Code.chat:
                var playerId = input.unPackInt8U();
                var text = input.unPackString();
                var player = players[playerId];

                if (!player.muted) {
                    chatParser.innerHTML = text;
                    text = chatParser.textContent.trim();
                    if (player && 0 < text.length && !censor.detect(text) && text.indexOf("<") < 0) {
                        addChat(text, player);
                    };
                };
                break;
            case Comm.Code.jump:
                var id = input.unPackInt8U(),
                    player = players[id];
                if (!player) break;
                player.jump();
                break;
            case Comm.Code.sync:
                var id = input.unPackInt8U();
                var stateIdx = input.unPackInt8U();
                var x = input.unPackFloat();
                var y = input.unPackFloat();
                var z = input.unPackFloat();
                var dx = input.unPackFloat();
                var dy = input.unPackFloat();
                var dz = input.unPackFloat();
                var climbing = input.unPackInt8U();
                var player = players[id];

                //discarded so that it doesnt mess up the next packets.
                if (!player) {
                    for (var i = 0; i < FramesBetweenSyncs; i++) {
                        input.unPackInt8U();
                        input.unPackRadU();
                        input.unPackRad();
                    };
                    break
                };

                var oldx = player.x;
                var oldy = player.y;
                var oldz = player.z;
                var olddx = player.dx;
                var olddy = player.dy;
                var olddz = player.dz;
                var oldYaw = player.yaw;
                var oldPitch = player.pitch;
                var wasJumping = player.jumping;
                var wasClimbing = player.climbing;

                if (id == meId) {
                    for (var i = 0; i < FramesBetweenSyncs; i++) {
                        //discarded so that it doesnt mess up the next packets.
                        input.unPackInt8U();
                        input.unPackRadU();
                        input.unPackRad();
                    };
                    var i = stateIdx;
                    var state = player.stateBuffer[i];

                    // devlog("received stateidx:", i, player.stateIdx);

                    if (Math.abs(player.x - x) > minimumForCorrection) player.x = x;
                    if (Math.abs(player.y - y) > minimumForCorrection) player.y = y;
                    if (Math.abs(player.z - z) > minimumForCorrection) player.z = z;

                    player.dx = state.dx;
                    player.dy = state.dy;
                    player.dz = state.dz;
                    player.climbing = state.climbing;
                    player.jumping = state.jumping;

                    let oldKeys = me.controlKeys;

                    //this code is weird...
                    let is = [];

                    //what this does is it tries to catch up? i think?
                    while (i !== player.stateIdx) {
                        i = (i + 1) % stateBufferSize;

                        // is.push(i);

                        state = player.stateBuffer[i];
                        player.controlKeys = state.controlKeys;
                        player.yaw = state.yaw;
                        state.jump && player.jump();
                        player.update(state.delta, true);
                        player.stateBuffer[i].x = player.x;
                        player.stateBuffer[i].y = player.y;
                        player.stateBuffer[i].z = player.z;
                        player.stateBuffer[i].dx = player.dx;
                        player.stateBuffer[i].dy = player.dy;
                        player.stateBuffer[i].dz = player.dz;
                        player.stateBuffer[i].jumping = player.jumping;
                    };

                    // devlog(is);

                    var dist = Math.length3(player.x - oldx, player.y - oldy, player.z - oldz);
                    if (dist < .2) {
                        if (.02 < dist) {
                            player.corrections = FramesBetweenSyncs;
                            player.corrected.dx = player.x - oldx;
                            player.corrected.dy = player.y - oldy;
                            player.corrected.dz = player.z - oldz;
                        };
                        player.x = oldx;
                        player.y = oldy;
                        player.z = oldz;
                        player.dx = olddx;
                        player.dy = olddy;
                        player.dz = olddz;
                    } else {
                        player.corrections = 0
                    };

                    player.jumping = wasJumping;
                    player.climbing = wasClimbing;
                    if (wasJumping) {
                        player.corrected.dy = 0;
                        player.y = oldy;
                        player.dy = olddy;
                    };

                    player.yaw = oldYaw;
                    player.pitch = oldPitch;
                    player.controlKeys = oldKeys;
                } else {
                    // devlog("other player, received:", stateIdx, player.stateIdx);

                    // player.stateIdx = stateIdx;

                    player.stateIdx = 0 // ??????

                    // let is = [];

                    for (var i = 0; i < FramesBetweenSyncs; i++) {
                        let idx = i; //Math.mod(player.stateIdx + i, stateBufferSize);

                        player.stateBuffer[idx].controlKeys = input.unPackInt8U();
                        player.stateBuffer[idx].yaw = input.unPackRadU();
                        player.stateBuffer[idx].pitch = input.unPackRad();

                        // is.push([i, idx, player.stateBuffer[idx].controlKeys, player.stateBuffer[idx].yaw, player.stateBuffer[idx].pitch])
                    };

                    // devlog(is);

                    player.x = x;
                    if (!player.jumping) {
                        player.y = y;
                    };
                    player.z = z;

                    player.dx = dx;
                    player.dy = dy;
                    player.dz = dz;

                    player.climbing = climbing;
                };

                // devlog("(end sync)", player.name, id, player.stateIdx);
                break;
            case Comm.Code.fire:
                var id = input.unPackInt8U();

                tv1.x = input.unPackFloat();
                tv1.y = input.unPackFloat();
                tv1.z = input.unPackFloat();
                tv2.x = input.unPackFloat();
                tv2.y = input.unPackFloat();
                tv2.z = input.unPackFloat();

                var seed = input.unPackInt8U();

                var player = players[id];
                if (!player) break;
                if (id != meId) player.weapon.actor.fire();

                Math.seed = seed;
                player.weapon.fireMunitions(tv1, tv2);
                break;
            case Comm.Code.throwGrenade:
                var id = input.unPackInt8U(),
                    x = input.unPackFloat(),
                    y = input.unPackFloat(),
                    z = input.unPackFloat(),
                    dx = input.unPackFloat(),
                    dy = input.unPackFloat(),
                    dz = input.unPackFloat(),
                    player = players[id];
                if (!player) break;
                player.grenadeCount--;
                if (id != meId) {
                    player.actor.head.rotation.x = player.pitch;
                    player.actor.mesh.rotation.y = player.yaw;
                } else updateAmmoUi();

                player.actor.throwGrenade();
                munitionsManager.throwGrenade(player, {
                    x: x,
                    y: y,
                    z: z
                }, {
                    x: dx,
                    y: dy,
                    z: dz
                });
                break;
            case Comm.Code.reload:
                var id = input.unPackInt8U();
                players[id] && players[id].reload();
                break;
            case Comm.Code.swapWeapon:
                var id = input.unPackInt8U(),
                    weaponIdx = input.unPackInt8U();
                players[id] && players[id].swapWeapon(weaponIdx);
                break;
            case Comm.Code.hitMe:
                var hp = input.unPackInt8U();
                var dx = input.unPackFloat();
                var dz = input.unPackFloat();
                me.hp = hp;
                me.actor.hit();
                hitIndicator.hit(dx, dz);
                break;
            case Comm.Code.hitThem:
                var id = input.unPackInt8U();
                var hp = input.unPackInt8U();
                var player = players[id];
                if (!player) break;
                player.hp = hp;
                player.actor.hit();
                0 < hp && shellFragBurst(player, 30, .07, 20);
                break;
            case Comm.Code.respawn:
                var id = input.unPackInt8U();
                var x = input.unPackFloat();
                var y = input.unPackFloat();
                var z = input.unPackFloat();
                var yaw = input.unPackRadU();
                var pitch = input.unPackRad();
                var player = players[id];
                
                if (player) {
                    player.respawn({x, y, z, yaw, pitch});
                    if (id == meId) console.log("Comm.Code.respawn received from server for this player")
                };
                break;
            case Comm.Code.changeCharacter:
                var id = input.unPackInt8U();
                var classIdx = input.unPackInt8U();
                var primaryWeaponIdx = input.unPackInt8U();
                var secondaryWeaponIdx = input.unPackInt8U();
                var shellColor = input.unPackInt8U();
                var hatIdx = input.unPackInt8U();
                var stampIdx = input.unPackInt8U();
                var primaryWeaponItem = catalog.findItemBy8BitItemId(ItemType.Primary, classIdx, primaryWeaponIdx);
                var secondaryWeaponItem = catalog.findItemBy8BitItemId(ItemType.Secondary, classIdx, secondaryWeaponIdx);
                var hatItem = catalog.findItemBy8BitItemId(ItemType.Hat, classIdx, hatIdx);
                var stampItem = catalog.findItemBy8BitItemId(ItemType.Stamp, classIdx, stampIdx);
                var player = players[id];

                player && player.changeCharacter(classIdx, primaryWeaponItem, secondaryWeaponItem, shellColor, hatItem, stampItem);
                break;
            case Comm.Code.switchTeam:
                var id = input.unPackInt8U(),
                    toTeam = input.unPackInt8U(),
                    player = players[id];
                if (player) {
                    player.team = toTeam, player.score = 0, player.kills = 0, player.streak = 0, player.bestGameStreak = 0, id == meId && (myTeam = toTeam, setTeamButton());
                    for (var i = 0; i < playerLimit; i++)(player = players[i]) && player.actor && player.actor.updateTeam();
                    rebuildPlayerList()
                }
                break;
            case Comm.Code.switchTeamFail:
                openAlertDialog(getLocText("ui_game_fairteams_header"), getLocText("ui_game_fairteams_text"), {
                    label: "OK",
                    width: "8em"
                });
                break;
            case Comm.Code.ping:
                ping = Date.now() - pingStartTime, pingTotal += ping, pingSamples++;
                var el = document.getElementById("ping");

                if (ping < 100) {
                    el.style.color = "#0f0";
                } else if (ping < 150) {
                    el.style.color = "#ff0";
                } else if (ping < 200) {
                    el.style.color = "#f90";
                } else {
                    el.style.color = "#f00";
                };

                el.innerText = ping + "ms";
                setTimeout(function () {
                    var output = new Comm.Out(1);
                    output.packInt8(Comm.Code.ping);
                    pingStartTime = Date.now();
                    if (ws) {
                        wsSend(output, "ping");
                    };
                }, 1e3); //every second
                break;
            case Comm.Code.notification:
                notify(input.unPackString(), 1e3 * input.unPackInt8U());
                break;
            case Comm.Code.gameLocked:
                notify(getLocText("ui_game_locked"), 1e4);
                break;
            case Comm.Code.updateBalance:
                var newBalance = input.unPackInt32U();
                console.log("updating balance from server: " + newBalance);
                playerAccount.currentBalance = newBalance;
                updateCurrentBalance();
                break;
            case Comm.Code.expireUpgrade:
                console.log("upgrade has expired");
                checkUpgrade();
                break;
            default:
                console.log("Comm.Code error: " + cmd + "/" + String.fromCharCode(cmd) + " - previous cmd: " + JSON.stringify(prevCmd))
        };
        prevCmd.push(cmd), 4 < prevCmd.length && prevCmd.shift();
    };
};

// [LS] ######## Catalog ---------------------------------
//   ___   _ _____ _   _    ___   ___ 
//  / __| /_\_   _/_\ | |  / _ \ / __|
// | (__ / _ \| |/ _ \| |_| (_) | (_ |
//  \___/_/ \_\_/_/ \_\____\___/ \___|

LEGACYSHELLCATALOG

var catalog = new CatalogConstructor(Items);

// [LS] Customizer CONSTRUCTOR
function Customizer(callback) {
    this.isReady = false, this.camX = 0, this.camY = .4, this.camRadius = 3.4, this.rotY = 0, this.rotX = 0, this.jump = 0, this.turnCountdown = 60, this.selectedItem = 0, this.buyingItem = null, this.currentPickedItem = null, this.currentRenderFunc = null, this.currentHighlightFunc = null, this.currentSelectByIndexFunc = null, this.currentSelectByItemFunc = null, this.setupScene(), this.setupItems(), this.setupWeaponStats();
    var outer = this;
    loadResources(this.scene, function () {
        outer.onResourcesLoaded(), outer.isReady = true, callback && callback()
    });
};
Customizer.prototype.onResourcesLoaded = function () {
    var outer = this;
    console.log("customizer created, starting renderering"), this.startRendering();
    try {
        var meshName = playerAccount.getPrimaryWeapon().item_data.meshName;
        this.avatar = new function (c) {
            this.scene = outer.scene;
            this.id = -1;
            this.name = "";
            this.x = 0;
            this.y = 0;
            this.z = 0, this.hp = 100, this.hatItem = playerAccount.hatItem, this.stampItem = playerAccount.stampItem, this.shellColor = playerAccount.colorIdx, this.actor = new PlayerActor(this), this.actor.mesh.rotation.y = outer.rotY, this.weapon = new classes[c].weapon(this, meshName), this.weapon.actor.equip()
        }(playerAccount.classIdx), console.log("avatar created: " + this.avatar);
        var lastNow = Date.now();
        this.scene.registerBeforeRender(function () {
            var now = Date.now(),
                delta = now - lastNow;
            lastNow = now, delta /= 17, outer.update(delta)
        })
    } catch (e) {
        console.log(e)
    }
};
Customizer.prototype.startRendering = function () {
    var outer = this;
    engine.runRenderLoop(function () {
        outer.scene.render()
    })
};
Customizer.prototype.update = function (delta) {
    if (this.avatar.actor.handsToWeaponSkeleton(), this.camera.target.x += (this.camX - this.camera.target.x) / 5, this.camera.target.y += (this.camY - this.camera.target.y) / 5, this.camera.radius += (this.camRadius - this.camera.radius) / 5, this.avatar.actor.head.rotation.x += (this.rotX - this.avatar.actor.head.rotation.x) / 5, this.avatar.actor.mesh.rotation.y += (this.rotY - this.avatar.actor.mesh.rotation.y) / 5, this.avatar.actor.mesh.rotation.x = .5 * this.avatar.actor.head.rotation.x, this.avatar.actor.mesh.position.x = .1 * -this.avatar.actor.mesh.rotation.y, this.avatar.actor.mesh.position.y += delta * this.jump, this.jump -= .002 * delta, this.avatar.actor.mesh.position.y = Math.max(0, this.avatar.actor.mesh.position.y + this.jump * delta), this.turnCountdown -= delta, this.turnCountdown <= 0) {
        var rx = .6 * Math.random() - .4,
            ry = 2 * Math.random() - 1 + .5 * this.camX,
            d = Math.length2(rx - this.rotX, ry - this.rotY);
        this.rotX = rx, this.rotY = ry, this.jump = Math.min(.01, d / 100), this.turnCountdown = 90 * Math.random() + 30
    }
};
Customizer.prototype.open = function () {
    menuIn("customizationMenu"), document.getElementById("customizeButton").style.display = "none", document.getElementById("customizerBackButton").style.display = "inline", document.getElementById("customizerClassSelectorContainer").appendChild(document.getElementById("classSelector")), document.getElementById("redeemCodeButton").style.display = playerAccount.session ? "inline" : "none", this.camX = .39, this.camY = .3, this.camRadius = 3.4, this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.initHatButton(), this.initStampButton()
};
Customizer.prototype.openToItem = function (item) {
    switch (item.item_type_id) {
        case ItemType.Primary:
            this.openWeaponSelectorToItem(Slot.Primary, item);
            break;
        case ItemType.Secondary:
            this.openWeaponSelectorToItem(Slot.Secondary, item);
            break;
        case ItemType.Hat:
            this.openHatSelectorToItem(item);
            break;
        case ItemType.Stamp:
            this.openStampSelectorToItem(item)
    }
    this.currentSelectByItemFunc(item), item.poseEgg()
};
Customizer.prototype.openToTaggedItems = function (tag) {
    var taggedItems = catalog.getTaggedItems(tag);
    this.openItemSelector("Items: " + tag, taggedItems, null, null, false, false)
};
Customizer.prototype.close = function () {
    playerAccount.syncToServer();
    menuOut("customizationMenu"), document.getElementById("customizerBackButton").style.display = "none", document.getElementById("redeemCodeButton").style.display = "none", document.getElementById("customizeButton").style.display = "inline", document.getElementById("mainMenuClassSelectorContainer").appendChild(document.getElementById("classSelector")), inGame ? (engine.stopRenderLoop(), startRendering(), me.changeCharacter(playerAccount.classIdx, playerAccount.getPrimaryWeapon(), playerAccount.getSecondaryWeapon(), playerAccount.colorIdx, playerAccount.hatItem, playerAccount.stampItem, 0, 0), chatting && chatInEl.focus(), showBannerAdWithPlaceholder("multisizeBannerAdPlaceholder"), loadBannerAd()) : menuIn("mainMenu", function () {
        showBannerAd(), loadBannerAd()
    }), this.camX = 0, this.camY = .4, this.camRadius = 3.4
};
Customizer.prototype.updatePageArrows = function () {
    document.getElementById("itemPageLeft").style.visibility = 0 < this.page ? "visible" : "hidden", document.getElementById("itemPageRight").style.visibility = this.page < this.numItems / this.pageSize - 1 ? "visible" : "hidden";
    var str = "Page " + (this.page + 1) + "/" + Math.ceil(this.numItems / this.pageSize);
    document.getElementById("itemPageCount").innerText = str
};
Customizer.prototype.flipPage = function (dir) {
    this.page += dir, this.currentRenderFunc(), this.updatePageArrows()
};
Customizer.prototype.iteratePage = function (callbackPerItem) {
    for (var start = this.page * this.pageSize, end = Math.min(start + this.pageSize, this.numItems), i = start, b = 0; i < end; i++, b++) callbackPerItem(i, b)
};
Customizer.prototype.renderEmptyButton = function () {
    var i = document.getElementById("noItemImg");
    document.getElementById("item0").getContext("2d").drawImage(i, 0, 0)
};
Customizer.prototype.clearItemButtons = function () {
    for (var i = 0; i < this.pageSize; i++) {
        document.getElementById("item" + i).getContext("2d").clearRect(0, 0, 256, 256)
    }
    this.clearItemLocks()
};
Customizer.prototype.clearItemLocks = function () {
    for (var i = 0; i < this.pageSize; i++) this.setItemLocked(i, false, 0), this.setItemRequiresPhysicalUnlock(i, false)
};
Customizer.prototype.clearHighlight = function () {
    for (var i = 0; i < this.pageSize; i++) document.getElementById("item" + i).className = "itemButton"
};
Customizer.prototype.highlightSelectedIndex = function (listIndex) {
    var start = this.page * this.pageSize,
        end = start + this.pageSize;
    start <= listIndex && listIndex < end && (pageIndex = listIndex % this.pageSize, document.getElementById("item" + pageIndex).className = "itemButtonSelected")
};
Customizer.prototype.isItemPickable = function (item) {
    var requiresPhysicalPurchase = this.doesItemRequirePhysicalUnlock(item);
    return 0 === item.price && !requiresPhysicalPurchase || playerAccount.inventory.includes(item)
};
Customizer.prototype.doesItemRequirePhysicalUnlock = function (item) {
    return void 0 !== item.item_data.unlock && null !== item.item_data.unlock && "physical" === item.item_data.unlock
};
Customizer.prototype.setItemLocked = function (displayIdx, locked, price) {
    document.getElementById("lockedItem" + displayIdx).style.visibility = locked ? "visible" : "hidden", document.getElementById("lockedItemCost" + displayIdx).innerText = price
};
Customizer.prototype.setItemRequiresPhysicalUnlock = function (displayIdx, requiresPhysicalPurchase) {
    document.getElementById("lockedItemPhysical" + displayIdx).style.visibility = requiresPhysicalPurchase ? "visible" : "hidden"
};
Customizer.prototype.boughtItem = function () {
    this.currentPickedItem = this.buyingItem;
    this.currentPickedItem.pick();
    this.currentPickedItem.poseEgg();
    this.buyingItem = null;
    this.currentRenderFunc(this.currentPickedItem);
    menuOut("buyItem");
    menuFlexIn("itemSelectorGrid");
    menuIn("itemSelectorBackButton");
};
Customizer.prototype.buyItemBack = function () {
    null !== this.currentPickedItem ? this.currentPickedItem.poseEgg() : this.buyingItem.takeOffItem(), this.buyingItem = null, this.currentHighlightFunc(), menuOut("buyItem"), menuOut("getMoreEggsLoozer"), menuFlexIn("itemSelectorGrid"), menuIn("itemSelectorBackButton")
};
Customizer.prototype.physicalUnlockBack = function () {
    this.buyItemBack(), menuOut("physicalUnlock")
};
Customizer.prototype.pickColor = function (idx) {
    if (this.avatar && (playerAccount.isUpgraded() || !(7 < idx))) {
        playerAccount.colorIdx = idx;
        for (var ci = 0; ci < shellColors.length; ci++) {
            var colorSelector = document.getElementById("color" + ci);
            ci === playerAccount.colorIdx ? colorSelector.classList.add("selectedColor") : colorSelector.classList.remove("selectedColor")
        }
        this.avatar.actor.setShellColor(playerAccount.colorIdx)
    }
};
Customizer.prototype.pickNextClass = function (dir) {
    var classIdx = Math.mod(playerAccount.classIdx + dir, CharClass.length);
    this.pickClass(classIdx)
};
Customizer.prototype.pickClass = function (classIdx) {
    playerAccount.setClass(classIdx);
    var primaryWeaponItem = playerAccount.getPrimaryWeapon();
    this.poseWithWeapon(primaryWeaponItem), this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.updateWeaponStatsUI()
};
Customizer.prototype.updateWeaponStatsUI = function () {
    if (this.avatar)
        for (var key in document.getElementById("className").innerText = classes[playerAccount.classIdx].name, document.getElementById("classWeapon").innerText = this.avatar.weapon.subClass.weaponName, weaponStats) {
            var pct = (this.avatar.weapon.subClass[key] + weaponStats[key].min) / (weaponStats[key].max - Math.abs(weaponStats[key].min));
            pct = 5.6 - 5.5 * pct, document.getElementById(weaponStats[key].name).style.borderRight = pct + "em solid var(--egg-brown)"
        }
};
Customizer.prototype.dressUpEgg = function () {
    null != playerAccount && void 0 !== this.avatar && null !== this.avatar && (this.pickClass(playerAccount.classIdx), this.poseWithWeapon(playerAccount.getPrimaryWeapon()), this.poseWithHat(playerAccount.hatItem), this.poseWithStamp(playerAccount.stampItem), this.pickColor(playerAccount.colorIdx))
};
Customizer.prototype.initWeaponButton = function (slot) {
    var currentPickedWeaponItem = playerAccount.getPickedWeaponInSlot(slot),
        canvasId = slot === Slot.Primary ? "primarySelectorButton" : "secondarySelectorButton",
        c = document.getElementById(canvasId);
        devlog(currentPickedWeaponItem);
    itemRenderer.renderToCanvas(currentPickedWeaponItem.item_data.meshName, c, this.weaponCam[slot])
};
Customizer.prototype.openWeaponSelector = function (slot) {
    this.openWeaponSelectorToItem(slot, playerAccount.getPickedWeaponInSlot(slot))
};
Customizer.prototype.openWeaponSelectorToItem = function (slot, weaponItem) {
    var weaponList = catalog.forClass[playerAccount.classIdx].forWeaponSlot[slot],
        title = slot === Slot.Primary ? "Primary Weapons" : "Secondary Weapons";
    this.openItemSelector(title, weaponList, weaponItem, false, true)
};
Customizer.prototype.poseWithWeapon = function (weaponItem) {
    this.avatar && (this.avatar.weapon && this.avatar.weapon.actor.dispose(), this.avatar.weapon = weaponItem.instantiateNew(this.avatar), this.avatar.weapon.actor.equip(), this.initWeaponButton(0), this.initWeaponButton(1))
};
Customizer.prototype.initHatButton = function () {
    var c = document.getElementById("hatSelectorButton");
    if (null !== playerAccount.hatItem) itemRenderer.renderToCanvas(playerAccount.hatItem.item_data.meshName, c, this.hatCam);
    else {
        var i = document.getElementById("noHatImg"),
            ctx = c.getContext("2d");
        ctx.clearRect(0, 0, 256, 256), ctx.drawImage(i, 0, 0)
    }
};
Customizer.prototype.openHatSelector = function () {
    this.openHatSelectorToItem(playerAccount.hatItem)
};
Customizer.prototype.openHatSelectorToItem = function (hatItem) {
    this.openItemSelector("Hats", catalog.hats, hatItem, true, true)
};
Customizer.prototype.poseWithHat = function (hatItem) {
    null === hatItem ? this.avatar.actor.removeHat() : this.avatar.actor.wearHat(hatItem)
};
Customizer.prototype.initStampButton = function () {
    var c = document.getElementById("stampSelectorButton");
    if (null !== playerAccount.stampItem) itemRenderer.renderStampToCanvas(playerAccount.stampItem, c);
    else {
        var i = document.getElementById("noStampImg"),
            ctx = c.getContext("2d");
        ctx.clearRect(0, 0, 256, 256), ctx.drawImage(i, 0, 0)
    }
};
Customizer.prototype.openStampSelector = function () {
    this.openStampSelectorToItem(playerAccount.stampItem)
};
Customizer.prototype.openStampSelectorToItem = function (stampItem) {
    this.openItemSelector("Stamps", catalog.stamps, stampItem, true, true)
};
Customizer.prototype.poseWithStamp = function (stampItem) {
    null === stampItem ? this.avatar.actor.removeStamp() : this.avatar.actor.applyStamp(stampItem)
};
Customizer.prototype.openItemSelector = function (title, itemList, item, firstItemBlank, highlightSelected) {
    if (playerAccount.isLoggedIn) {
        this.camX = .6, this.camY = .35, this.pageSize = 9;
        var uiItems = this.filterItemsForUI(itemList),
            blankFirstItemShim = true === firstItemBlank ? 1 : 0;
        this.numItems = uiItems.length + blankFirstItemShim;
        var itemIdx = 0;
        null !== item && null === (itemIdx = this.getItemIndex(item, uiItems)) && (itemIdx = 0), highlightSelected && playerAccount.isItemEquipped(item) && (this.currentPickedItem = item), this.page = Math.floor(itemIdx / this.pageSize), this.currentRenderFunc = this.encloseRenderPageFunc(uiItems, firstItemBlank, highlightSelected), this.currentHighlightFunc = this.encloseHighlightFunc(uiItems, firstItemBlank, highlightSelected), this.currentSelectByIndexFunc = this.encloseSelectByIndexFunc(uiItems, firstItemBlank, highlightSelected), this.currentSelectByItemFunc = this.encloseSelectByItemFunc(uiItems, firstItemBlank, highlightSelected), this.currentRenderFunc(), this.currentHighlightFunc(), this.updatePageArrows(), document.getElementById("itemSelectorHeader").innerText = title, menuOut("customizationMenu"), menuIn("itemSelectorMenu")
    } else promoteLogin()
};
Customizer.prototype.encloseRenderPageFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function () {
        outer.clearItemButtons(), outer.iteratePage(function (i, b) {
            if (true === firstItemBlank && 0 === i) outer.renderEmptyButton(), outer.setItemLocked(0, false, 0), outer.setItemRequiresPhysicalUnlock(0, false);
            else {
                var renderingItem = itemList[true === firstItemBlank ? i - 1 : i],
                    canvas = document.getElementById("item" + b);
                renderingItem.renderToCanvas(canvas);
                var locked = !outer.isItemPickable(renderingItem),
                    requiresPhysicalUnlock = outer.doesItemRequirePhysicalUnlock(renderingItem);
                outer.setItemRequiresPhysicalUnlock(b, locked && requiresPhysicalUnlock), outer.setItemLocked(b, locked && !requiresPhysicalUnlock, renderingItem.price)
            }
        }), outer.currentHighlightFunc()
    }
};
Customizer.prototype.encloseHighlightFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function () {
        outer.clearHighlight(), false !== highlightSelected && outer.iteratePage(function (i, b) {
            if (true === firstItemBlank && 0 === i) null === outer.currentPickedItem && outer.highlightSelectedIndex(0);
            else {
                var item = itemList[true === firstItemBlank ? i - 1 : i];
                null !== outer.currentPickedItem && item.id === outer.currentPickedItem.id && outer.highlightSelectedIndex(i)
            }
        })
    }
};
Customizer.prototype.encloseSelectByIndexFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function (displayIndex) {
        var listIndex = displayIndex;
        true === firstItemBlank && listIndex--;
        var noItem = true === firstItemBlank && 0 === displayIndex,
            item = noItem ? null : itemList[listIndex];
        true === noItem || outer.isItemPickable(item) ? (true === highlightSelected && outer.highlightSelectedIndex(displayIndex), true === noItem ? (outer.currentPickedItem.takeOffItem(), outer.currentPickedItem = null) : (item.pick(), item.poseEgg())) : (console.log("here, item: " + item.id), item.select(), item.poseEgg(), this.buyingItem = item, outer.itemSelected(item))
    }
};
Customizer.prototype.encloseSelectByItemFunc = function (itemList, firstItemBlank) {
    return function (item) {
        var itemIdx = this.getItemIndex(item, itemList);
        true === firstItemBlank && itemIdx++, this.currentSelectByIndexFunc(itemIdx)
    }
};
Customizer.prototype.itemSelected = function (item) {
    (menuOut("itemSelectorGrid"), menuOut("itemSelectorBackButton"), this.doesItemRequirePhysicalUnlock(item)) ? (menuFlexIn("physicalUnlock"), document.getElementById("physicalUnlockText").innerText = void 0 !== item.item_data.physicalUnlockText ? item.item_data.physicalUnlockText : "Buy a REAL THING to unlock this item!", document.getElementById("physicalUnlockButton").onclick = function () {
        return customizer.openPhysicalItemStoreDialog(), false
    }) : playerAccount.currentBalance >= item.price ? (menuFlexIn("buyItem"), document.getElementById("buyItemText").innerText = item.price, document.getElementById("buyItemButton").onclick = function () {
        return extern.buyItem(item.id), false
    }) : (menuFlexIn("getMoreEggsLoozer"), document.getElementById("moreEggsPrice").innerText = item.price)
};
Customizer.prototype.getItemIndex = function (item, itemList) {
    if (null === item) return null;
    for (var i = 0; i < itemList.length; i++)
        if (item.id === itemList[i].id) return i;
    return null
};
Customizer.prototype.selectItem = function (pageIndex) {
    listIndex = pageIndex + this.page * this.pageSize, listIndex < this.numItems && (this.clearHighlight(), this.currentSelectByIndexFunc(listIndex))
};
Customizer.prototype.closeItemSelector = function () {
    menuOut("itemSelectorMenu");
    var primaryWeapon = playerAccount.getPickedWeaponInSlot(Slot.Primary);
    this.poseWithWeapon(primaryWeapon), this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.initHatButton(), this.initStampButton(), this.open()
};
Customizer.prototype.filterItemsForUI = function (itemList) {
    for (var uiItems = [], i = 0; i < itemList.length; i++) true === itemList[i].showInUI && uiItems.push(itemList[i]);
    return uiItems
};
Customizer.prototype.setupItems = function () {
    this.extendStampItems(), this.extendHatItems();
    for (var cIdx = 0; cIdx < CharClass.length; cIdx++) this.extendWeaponItems(cIdx, Slot.Primary), this.extendWeaponItems(cIdx, Slot.Secondary)
};
Customizer.prototype.extendItems = function (itemList, renderItemToCanvasFunc, poseEggWithItemFunc, selectItemFunc, takeOffItemFunc, pickItemFunc) {
    for (var i = 0; i < itemList.length; i++) {
        var showInUI = true === itemList[i].is_available || true === playerAccount.isItemOwned(itemList[i]);
        itemList[i].showInUI = showInUI, itemList[i].renderToCanvas = renderItemToCanvasFunc, itemList[i].poseEgg = poseEggWithItemFunc, itemList[i].select = selectItemFunc, itemList[i].takeOffItem = takeOffItemFunc, itemList[i].pick = pickItemFunc
    }
};
Customizer.prototype.extendWeaponItems = function (classIdx, slot) {
    var outer = this,
        weaponList = catalog.forClass[classIdx].forWeaponSlot[slot],
        poseEggWithWeaponFunc = function () {
            outer.poseWithWeapon(this)
        };
    this.extendItems(weaponList, function (canvas) {
        itemRenderer.renderToCanvas(this.item_data.meshName, canvas, outer.weaponCam[slot])
    }, poseEggWithWeaponFunc, function () {
        outer.currentPickedItem = playerAccount.getPickedWeaponInSlot(slot)
    }, function () {
        poseEggWithWeaponFunc(this.currentPickedItem)
    }, function () {
        void 0 !== this.exclusive_for_class && null !== this.exclusive_for_class && this.exclusive_for_class !== playerAccount.classIdx && outer.pickClass(this.exclusive_for_class), playerAccount.pickWeapon(slot, this), outer.initWeaponButton(slot)
    })
};
Customizer.prototype.extendHatItems = function () {
    var outer = this;
    this.extendItems(catalog.hats, function (canvas) {
        itemRenderer.renderToCanvas(this.item_data.meshName, canvas, outer.hatCam)
    }, function () {
        outer.poseWithHat(this)
    }, function () {
        outer.currentPickedItem = playerAccount.hatItem
    }, function () {
        playerAccount.hatItem = null, outer.poseWithHat(null)
    }, function () {
        outer.currentPickedItem = this, playerAccount.hatItem = this, outer.initHatButton()
    })
};
Customizer.prototype.extendStampItems = function () {
    var outer = this;
    this.extendItems(catalog.stamps, function (canvas) {
        itemRenderer.renderStampToCanvas(this, canvas)
    }, function () {
        outer.poseWithStamp(this)
    }, function () {
        outer.currentPickedItem = playerAccount.stampItem
    }, function () {
        playerAccount.stampItem = null, outer.poseWithStamp(null)
    }, function () {
        outer.currentPickedItem = this, playerAccount.stampItem = this, outer.initStampButton()
    })
};
Customizer.prototype.setupScene = function () {
    this.scene = new BABYLON.Scene(engine), this.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2, this.scene.fogDensity = .06;
    var skyColor = new BABYLON.Color3(.35, .65, .8); //background colour. pre 0.15.7: new BABYLON.Color3(.52, .68, .82) post: .35, .65, .8
    this.scene.fogColor = skyColor, this.scene.clearColor = skyColor;
    var topLight = new BABYLON.DirectionalLight("", new BABYLON.Vector3(0, -1, 0), this.scene);
    topLight.intensity = 1;
    var hemLight = new BABYLON.HemisphericLight("", new BABYLON.Vector3(.25, 1, -.5), this.scene);
    hemLight.intensity = .8, (hemLight = new BABYLON.HemisphericLight("", new BABYLON.Vector3(0, -1, 0), this.scene)).intensity = .5, hemLight.diffuse = new BABYLON.Color3(.6, .8, 1), (shadowGen = new BABYLON.ShadowGenerator(1024, topLight)).useBlurExponentialShadowMap = true, shadowGen.frustumEdgeFalloff = 1, shadowGen.blurScale = 2, shadowGen.blurBoxOffset = 1, this.camera = new BABYLON.ArcRotateCamera("", .5 * Math.PI, 1.5, this.camRadius, new BABYLON.Vector3(this.camX, this.camY, 0), this.scene), this.scene.activeCameras.push(this.camera), this.camera.maxZ = 100, this.camera.fov = .5, this.camera.minZ = .1;
    var groundMat = new BABYLON.StandardMaterial("groundMat", this.scene);
    groundMat.diffuseColor = new BABYLON.Color3(.35, .5, .6); //pre 0.15.7: new BABYLON.Color3(.4, .5, .6) post: .35, .5, .6
    groundMat.specularColor = BABYLON.Color3.Black();
    var ground = BABYLON.Mesh.CreatePlane("ground", 100, this.scene);
    ground.rotation.x = Math.PI / 2, ground.receiveShadows = true, ground.material = groundMat, this.scene.render();
    for (var i = 0; i < shellColors.length; i++) document.getElementById("color" + i).style.background = shellColors[i];
    stampTexture = new BABYLON.Texture("img/stamps.png?v=" + version, this.scene), this.weaponCam = [{
        alpha: 0,
        radius: 1.3,
        primaryGun: true
    }, {
        alpha: 0,
        radius: 1,
        secondaryGun: true
    }], this.hatCam = {
        alpha: 0,
        radius: 1.3
    }
};
Customizer.prototype.setExtraColorState = function (available) {
    for (var pickColorClosure = function (colorIdx) {
        return function () {
            extern.customizer.pickColor(colorIdx)
        }
    }, i = 7; i < shellColors.length; i++) {
        var colorSwatch = document.getElementById("color" + i);
        true === available ? (colorSwatch.onclick = pickColorClosure(i), colorSwatch.classList.remove("lockedColor")) : (colorSwatch.onclick = extern.openBuyPassDialog, colorSwatch.classList.add("lockedColor"))
    }
};
Customizer.prototype.setupWeaponStats = function () {
    var setupWeaponStatsInList = function (weaponList) {
        for (var i = 0; i < weaponList.length; i++) {
            var weapon = item_classes[weaponList[i].item_data.class];
            for (var key in weaponStats) weaponStats[key].flip ? (weaponStats[key].max = Math.max(weaponStats[key].max, -weapon[key]), weaponStats[key].min = Math.min(weaponStats[key].min, -weapon[key])) : (weaponStats[key].max = Math.max(weaponStats[key].max, weapon[key]), weaponStats[key].min = 0)
        }
    };
    setupWeaponStatsInList(catalog.primaryWeapons), setupWeaponStatsInList(catalog.secondaryWeapons)
};

// [LS] ItemRenderer CONSTRUCTOR
function ItemRenderer() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = 256;
    this.canvas.height = 256;
    this.canvas.style.position = "fixed";
    this.canvas.style.top = "-100em";
    this.canvas.style.left = "1em";
    document.body.appendChild(this.canvas);
    this.engine = new BABYLON.Engine(this.canvas, true, null, false);
    this.scene = new BABYLON.Scene(this.engine);
    this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
    this.meshes = {
        Skeletons: {}
    };
    loadMaterials(this.scene);
    loadMeshes(this.scene, ["egg", "gun_cluck9mm", "gun_eggk47", "gun_csg1", "gun_dozenGauge", "gun_rpegg"], null, function () { });
    this.stampSprites = new BABYLON.SpriteManager("", "img/stamps.png?v=" + version, 256, 128, this.scene);
    this.camera = new BABYLON.ArcRotateCamera("", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), this.scene);
    this.scene.activeCameras.push(this.camera);
    this.camera.fov = .5;
    this.camera.maxZ = 100;
    this.camera.minZ = .1;
};
ItemRenderer.prototype.renderToCanvas = function (meshName, destCanvas, cam) {
    this.engine.clear(), this.camera.alpha = 0, this.camera.beta = Math.PI90, this.camera.radius = cam.radius || 1;
    cam.y;
    try {
        var mesh = this.scene.getMeshByName(meshName).clone();
    } catch (error) {
        // devlog(meshName);
    };
    cam.primaryGun ? (mesh.rotation.x = -.7, mesh.position.y = -.1, mesh.position.z = -.1) : cam.secondaryGun ? (mesh.position.z = -.32, mesh.position.y = .05) : (mesh.position.y = -.25, mesh.rotation.y = 2, mesh.rotation.x = .25), mesh.computeWorldMatrix();
    var verts = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    this.scene.updateTransformMatrix();
    for (var min = {
        x: 1e4,
        y: 1e4
    }, max = {
        x: -1e4,
        y: -1e4
    }, i = 0; i < verts.length; i += 3) {
        var sp = BABYLON.Vector3.Project(new BABYLON.Vector3(verts[i], verts[i + 1], verts[i + 2]), mesh.getWorldMatrix(), this.scene.getTransformMatrix(), this.camera.viewport.toGlobal(this.engine));
        min.x = Math.min(min.x, sp.x), max.x = Math.max(max.x, sp.x), min.y = Math.min(min.y, sp.y), max.y = Math.max(max.y, sp.y)
    }
    var cx = (max.x + min.x) / 2 - 128,
        cy = (max.y + min.y) / 2 - 128;
    mesh.position.z -= cx / 512, mesh.position.y += cy / 512, this.scene.render(), mesh.dispose();
    var ctx = destCanvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256), ctx.drawImage(this.canvas, 0, 0)
};
ItemRenderer.prototype.renderStampToCanvas = function (stampItem, destCanvas) {
    var s = new BABYLON.Sprite("", this.stampSprites),
        x = stampItem.item_data.x,
        y = stampItem.item_data.y;
    s.cellIndex = x + 16 * y, s.size = 1, this.camera.alpha = 0, this.camera.beta = 0, this.camera.radius = 2.5, this.scene.render(), s.dispose();
    var ctx = destCanvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256), ctx.drawImage(this.canvas, 0, 0)
};

function openItemInCustomizer(itemId) {
    if (!playerAccount.isLoggedIn) return promoteLogin(), false;
    document.getElementById("bigAd").style.display = "none", openCustomizerFromMainMenu();
    var item = catalog.findItemById(itemId);
    return customizer.openToItem(item), true
};

function tryShowTaggedItems() {
    if (null === showTaggedItems) return false;
    var shown = openTaggedItemsInCustomizer(showTaggedItems);
    return true === shown && (showTaggedItems = null), shown
};

function openTaggedItemsInCustomizer(tag) {
    return playerAccount.isLoggedIn ? (openCustomizerFromMainMenu(), customizer.openToTaggedItems(tag), true) : (promoteLogin(), false)
};

function renderItemsInShowItemList(items) {
    for (var i = 0; i < items.length; i++) {
        var itemCanvas = document.getElementById("showItemCanvas_" + i);
        items[i].renderToCanvas(itemCanvas), document.getElementById("showItemName_" + i).innerHTML = items[i].name
    };
};

function createShowItemListHTML(numItems) {
    for (var itemContainer = document.getElementById("showItemContainer").cloneNode(true), itemList = itemContainer.querySelector("#showItemList"), i = 0; i < numItems; i++) {
        var appendIndexToId = function (element) {
            element.id += "_" + i
        },
            itemTemplate = document.getElementById("showItemTemplate").cloneNode(true);
        appendIndexToId(itemTemplate), appendIndexToId(itemTemplate.querySelector("#showItemCanvas")), appendIndexToId(itemTemplate.querySelector("#showItemName")), 1 < numItems && (itemTemplate.style.float = "left"), 0 < i && itemTemplate.classList.add("showItemTemplateLeft"), itemList.appendChild(itemTemplate)
    };
    return itemContainer.class = "", itemContainer
};

function openCustomizerFromMainMenu() {
    hideBannerAd();
    hideMultisizeBannerAd();
    menuOut("mainMenu");
    customizer.open();
};

// [LS] ######## Collider ---------------------------------
//   ___ ___  _    _    ___ ___  ___ ___ 
//  / __/ _ \| |  | |  |_ _|   \| __| _ \
// | (_| (_) | |__| |__ | || |) | _||   /
//  \___\___/|____|____|___|___/|___|_|_\

LEGACYSHELLCOLLIDER

var Collider;

// [LS] ######## Actor Constructors ---------------------------------
//    _   ___ _____ ___  ___  ___ 
//   /_\ / __|_   _/ _ \| _ \/ __|
//  / _ \ (__  | || (_) |   /\__ \
// /_/ \_\___| |_| \___/|_|_\|___/


// [LS] PlayerActor CONSTRUCTOR
function PlayerActor(player) {
    this.player = player, this.scene = player.scene, this.mesh = new BABYLON.TransformNode, this.hat = null;
    player.hatItem, player.stampItem;
    this.bodyMesh = this.scene.cloneMesh("egg", this.mesh);
    this.bodyMesh.position.y = .32;
    this.bodyMesh.player = this.player;
    this.bodyMesh.material = this.scene.getMaterialByName("eggShell");
    this.bodyMesh.material.setTexture("textureSampler", stampTexture);
    this.head = new BABYLON.TransformNode;
    this.head.parent = this.mesh;
    this.head.position.y = .3;
    this.head.position.z = 0;
    this.gunContainer = new BABYLON.TransformNode;
    this.gunContainer.parent = this.head;
    this.gunContainer.rotation.y = -.14;
    this.gunContainer.rotation.x = -.035;
    this.setupStowAnims();
    this.eye = new BABYLON.TransformNode;
    this.eye.position.y = .1;
    this.eye.position.x = 0;
    this.eye.parent = this.head;
    this.hands = this.scene.cloneMesh("hands", this.gunContainer);
    // devlog(this.hands);
    this.hands.skeleton = this.scene.cloneSkeleton("hands_skeleton");
    this.hands.material = this.scene.getMaterialByName("standard");
    this.gripBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("gripHand")];
    this.foreBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("foreHand")];
    this.bodyMesh.overlayColor = BABYLON.Color3.Green();
    this.hands.overlayColor = BABYLON.Color3.Green();
    0 < this.player.shield && (this.bodyMesh.renderOverlay = true, this.hands.renderOverlay = true);
    this.setShellColor(this.player.shellColor);
    shake = 0;
    shadowGen && shadowGen.getShadowMap().renderList.push(this.bodyMesh);
    if (inGame) {
        this.player.id == meId ? this.hands.setRenderingGroupId(1) : (this.setupNameSprite(), this.showNameSprite()), inGame && this.updateTeam();
    } else {
        this.bodyMesh.outlineColor = teamColors.outline[0].clone(), this.bodyMesh.outlineColor.a = 0;
    };
    this.mesh.position.x = this.player.x;
    this.mesh.position.y = this.player.y;
    this.mesh.position.z = this.player.z;
    this.deathSound = Sounds.shellBurst.clone();
    this.player.id == meId ? this.hitSound = Sounds.hit.clone() : (this.wearHat(this.player.hatItem), this.applyStamp(this.player.stampItem), this.hitSound = this.bodyMesh.attachSound(Sounds.hit));
    /* playOffline && this.hands.setEnabled(false), */ 
    this.bobbleIntensity = 0;
    this.scope = false;
    this.zoomed = false;
    this.hitSoundDelay = 0;
};
PlayerActor.prototype.wearHat = function (hatItem) {
    this.removeHat(), null !== hatItem && (this.hat = this.scene.cloneMesh(hatItem.item_data.meshName, this.bodyMesh), this.hat.position.y = -.02)
};
PlayerActor.prototype.removeHat = function () {
    void 0 !== this.hat && null !== this.hat && this.hat.dispose()
};
PlayerActor.prototype.applyStamp = function (stampItem) {
    this.removeStamp(), null !== stampItem && (this.bodyMesh.stampU = stampItem.item_data.x / 16, this.bodyMesh.stampV = 1 - stampItem.item_data.y / 16)
};
PlayerActor.prototype.removeStamp = function () {
    this.bodyMesh.stampU = 0, this.bodyMesh.stampV = 1
};
PlayerActor.prototype.drawTextOnNameTexture = function (text, x, y, size, color, center) {
    var shadowCoords = [{
        x: 0,
        y: -4
    }, {
        x: -4,
        y: 0
    }, {
        x: 4,
        y: 0
    }, {
        x: 0,
        y: 4
    }],
        coords = [{
            x: 0,
            y: -1
        }, {
            x: -1,
            y: 0
        }, {
            x: 1,
            y: 0
        }, {
            x: 0,
            y: 1
        }];
    x += this.player.id % 4 * 512, y = -y + (2048 - 256 * Math.floor(this.player.id / 4)), center && (x += 256 - function (name, size) {
        var context = nameTestCanvas.getContext("2d");
        return context.font = "bold " + size + "px Nunito, sans-serif", context.measureText(name).width
    }(text, size) / 2);
    for (var i = 0; i < 4; i++) nameTexture.drawText(text, x + shadowCoords[i].x, y + shadowCoords[i].y, "bold " + size + "px Nunito, sans-serif", "rgba(0, 0, 0, 0.5)", "transparent");
    for (i = 0; i < 4; i++) nameTexture.drawText(text, x + coords[i].x, y + coords[i].y, "bold " + size + "px Nunito, sans-serif", color, "transparent")
};
PlayerActor.prototype.setupNameSprite = function () {
    var tx = this.player.id % 4 * 512,
        ty = 2048 - 256 * Math.floor(this.player.id / 4);
    nameTexture.clearRect(tx, ty - 256, 512, 256), this.drawTextOnNameTexture(this.player.name, 0, 32, 60, "white", true)
};
PlayerActor.prototype.updateTeam = function () {
    this.player.id == meId || (0 < this.player.team ? (this.player.team == myTeam ? this.bodyMesh.outlineColor = teamColors.outline[this.player.team].clone() : this.bodyMesh.outlineColor.a = 0, this.nameSprite && (this.nameSprite.width = .6, this.nameSprite.height = .3, this.nameSprite.color = teamColors.outline[this.player.team])) : this.bodyMesh.outlineColor.a = 0)
};
PlayerActor.prototype.update = function (delta) {
    var bcos = Math.cos(this.player.bobble) * this.bobbleIntensity,
        bsina = Math.abs(Math.sin(this.player.bobble) * this.bobbleIntensity),
        bsin = Math.sin(2 * this.player.bobble) * this.bobbleIntensity;
    if (0 < this.player.shield) {
        var alpha = .7 * Math.random() + .2;
        this.bodyMesh.overlayAlpha = alpha, this.hands.overlayAlpha = alpha
    }
    if (this.player.id == meId) this.scope && this.player.isAtReady(true) ? (camera.fov = camera.fov + (this.player.weapon.actor.scopeFov - camera.fov) / 3, this.gunContainer.rotation.y *= .667, this.gunContainer.rotation.x *= .667, this.gunContainer.position.x += (-.25 - this.gunContainer.position.x) / 3, this.gunContainer.position.y += (this.player.weapon.actor.scopeY - this.gunContainer.position.y) / 4, this.gunContainer.position.z += (-.05 - this.gunContainer.position.z) / 3, this.player.weapon.hasScope && !this.zoomed && camera.fov < this.player.weapon.actor.scopeFov + .05 && (scope.show(), this.gunContainer.setEnabled(false), this.zoomed = true)) : (camera.fov = camera.fov + (1.25 - camera.fov) / 3, this.gunContainer.rotation.y += (2 * bcos - .14 - this.gunContainer.rotation.y) / 3, this.gunContainer.rotation.x += (.75 * bsin - .035 - this.gunContainer.rotation.x) / 3, this.gunContainer.position.x *= .667, this.gunContainer.position.y *= .667, this.gunContainer.position.z *= .667, this.zoomed && camera.fov > this.player.weapon.actor.scopeFov + .05 && (scope.hide(), this.gunContainer.setEnabled(true), this.zoomed = false));
    else if (this.gunContainer.rotation.y += (2 * bcos - .14 - this.gunContainer.rotation.y) / 3, this.gunContainer.rotation.x += (.75 * bsin - .035 - this.gunContainer.rotation.x) / 3, 0 < this.player.team && this.player.team == myTeam && this.nameSprite) {
        var dist = Math.length3(this.player.x - me.x, this.player.y - me.y, this.player.z - me.z),
            fac = Math.pow(dist, 1.25);
        this.nameSprite.width = fac / 10 + .6, this.nameSprite.height = fac / 20 + .3
    }
    var dx = this.player.x - this.mesh.position.x,
        dy = this.player.y - this.mesh.position.y,
        dz = this.player.z - this.mesh.position.z;
    dist = Math.length3(dx, dy, dz);
    this.player.id == meId ? (this.mesh.position.x += dx / 2, this.mesh.position.y += dy / 2, this.mesh.position.z += dz / 2) : (this.mesh.position.x += dx / 6, this.mesh.position.y += dy / 2, this.mesh.position.z += dz / 6);
    var bobbleTarget;
    Math.radDifference(this.player.yaw, this.mesh.rotation.y), Math.radDifference(this.player.pitch, this.head.rotation.x);
    if (this.mesh.rotation.y = this.player.yaw, this.head.rotation.x = this.player.pitch, this.bodyMesh.rotation.x = this.head.rotation.x / 4, bobbleTarget = this.player.jumping ? 0 : Math.length3(this.player.dx, this.player.dy, this.player.dz), this.bobbleIntensity += (bobbleTarget - this.bobbleIntensity) / 10, this.bodyMesh.rotation.z = 5 * bcos, this.bodyMesh.position.y = 1.5 * bsina + .32, 0 < shake)
        if ((shake *= .9) < .001) shake = 0;
        else {
            var x = Math.random() * shake - .5 * shake,
                y = Math.random() * shake - .5 * shake,
                z = Math.random() * shake - .5 * shake;
            this.eye.rotation.x += (x - this.eye.rotation.x) / 10, this.eye.rotation.y += (y - this.eye.rotation.y) / 10, this.eye.rotation.z += (z - this.eye.rotation.z) / 10
        }
    else this.eye.rotation.x *= .9, this.eye.rotation.y *= .9, this.eye.rotation.z *= .9;
    if (this.player.id != meId) {
        var visible = isMeshVisible(this.mesh, .31);
        this.mesh.setVisible(visible), visible ? this.showNameSprite() : this.hideNameSprite(), this.nameSprite && this.positionNameSprite()
    }
    this.hitSoundDelay = Math.max(this.hitSoundDelay - delta, 0)
};
PlayerActor.prototype.positionNameSprite = function () {
  if (this.nameSprite) {
    var mp = this.mesh.position.clone();
    mp.y += 0.5 * this.nameSprite.height + 0.65;
    var v = new BABYLON.Vector3(
      camera.globalPosition.x - mp.x,
      camera.globalPosition.y - mp.y,
      camera.globalPosition.z - mp.z
    ).normalize();
    v.scaleInPlace(0.4), v.addInPlace(mp), (this.nameSprite.position = v);
  }
};
PlayerActor.prototype.showNameSprite = function () {
    this.player.playing && !this.nameSprite && (this.nameSprite = new BABYLON.Sprite("", nameSprites), this.nameSprite.invertV = true, this.nameSprite.width = .6, this.nameSprite.height = .3, this.nameSprite.cellIndex = this.player.id, this.nameSprite.color = teamColors.outline[this.player.team])
};
PlayerActor.prototype.hideNameSprite = function () {
    this.nameSprite && (this.nameSprite.dispose(), this.nameSprite = null)
};
PlayerActor.prototype.scopeIn = function () {
    this.scope = true
};
PlayerActor.prototype.scopeOut = function () {
    this.scope = false
};
PlayerActor.prototype.hit = function () {
    this.hitSoundDelay <= 0 && (this.hitSound.play(), this.hitSoundDelay = 10)
};
PlayerActor.prototype.removeFromPlay = function () {
    // devlog("removeFromPlay");
    this.scope = false, this.zoomed = false, this.throwingGrenade = false, this.gripBone._frozen = false, this.mesh.setEnabled(false), this.hideNameSprite()
    // if (playOffline) this.mesh.setEnabled(true);
};
PlayerActor.prototype.restoreToPlay = function () {
    // devlog("restoreToPlay");
    this.mesh.setEnabled(true), this.gunContainer.setEnabled(true), this.player.id != meId && this.showNameSprite()
    // if (playOffline) this.mesh.setEnabled(true);
};
PlayerActor.prototype.remove = function () {
    this.mesh.disposeOfSounds(), this.mesh.dispose(), this.hideNameSprite()
};
PlayerActor.prototype.fire = function () {
    this.zoomed && this.player.weapon.hasScope && (shake = .25, this.eye.rotation.x = -.1)
};
PlayerActor.prototype.reachForGrenade = function () {
    var that = this;
    this.throwingGrenade = true, this.gripBone._frozen = true, this.hands.skeleton.enableBlending(.2), this.hands.skeleton.beginAnimation("grenade_grab", false, 1, function () {
        that.hands.skeleton && that.hands.skeleton.disableBlending()
    })
};
PlayerActor.prototype.throwGrenade = function () {
    var that = this;
    this.player.id == meId && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden"), this.hands.skeleton.beginAnimation("grenade_throw", false, 1, function () {
        that.hands.skeleton && (that.throwingGrenade = false, that.gripBone._frozen = false)
    })
};
PlayerActor.prototype.setShellColor = function (colorIdx) {
    (colorIdx < 0 || colorIdx >= shellColors.length) && (console.log("Shell color out of bounds: " + colorIdx), colorIdx = 0);
    var color = BABYLON.Color3.FromHexString(shellColors[colorIdx]);
    this.bodyMesh.colorMult = color, this.hands.colorMult = color
};
PlayerActor.prototype.setWeaponSkeleton = function (skeleton) {
    this.skeleton = skeleton, this.weaponGripBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("gripHand")], this.weaponForeBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("foreHand")]
};
PlayerActor.prototype.handsToWeaponSkeleton = function () {
    this.gripBone.position = this.weaponGripBone.position, this.gripBone.setRotationQuaternion(this.weaponGripBone.rotationQuaternion), 1 != this.throwingGrenade && (this.foreBone.position = this.weaponForeBone.position, this.foreBone.setRotationQuaternion(this.weaponForeBone.rotationQuaternion))
};
PlayerActor.prototype.setupStowAnims = function () {
    var gunRotationAnimation = new BABYLON.Animation("", "rotation", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunScaleAnimation = new BABYLON.Animation("", "scaling", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunPositionAnimation = new BABYLON.Animation("", "position", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunRotationEase = new BABYLON.CubicEase;
    gunRotationEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunRotationAnimation.setEasingFunction(gunRotationEase);
    var gunScaleEase = new BABYLON.CubicEase;
    gunScaleEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunScaleAnimation.setEasingFunction(gunScaleEase);
    var gunPositionEase = new BABYLON.CubicEase;
    gunPositionEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunPositionAnimation.setEasingFunction(gunPositionEase);
    var gunRotationKeys = [{
        frame: 0,
        value: new BABYLON.Vector3(-.035, -.14, 0)
    }, {
        frame: 25,
        value: new BABYLON.Vector3(1, -1.5, 0)
    }, {
        frame: 30,
        value: new BABYLON.Vector3(-1, -1.5, 0)
    }, {
        frame: 55,
        value: new BABYLON.Vector3(-.035, -.14, 0)
    }],
        gunScaleKeys = [{
            frame: 0,
            value: new BABYLON.Vector3(1, 1, 1)
        }, {
            frame: 25,
            value: new BABYLON.Vector3(.25, .25, .25)
        }, {
            frame: 30,
            value: new BABYLON.Vector3(.25, .25, .25)
        }, {
            frame: 55,
            value: new BABYLON.Vector3(1, 1, 1)
        }],
        gunPositionKeys = [{
            frame: 0,
            value: new BABYLON.Vector3(0, 0, 0)
        }, {
            frame: 25,
            value: new BABYLON.Vector3(.1, .1, -.2)
        }, {
            frame: 30,
            value: new BABYLON.Vector3(.1, 0, -.2)
        }, {
            frame: 55,
            value: new BABYLON.Vector3(0, 0, 0)
        }];
    gunRotationAnimation.setKeys(gunRotationKeys), gunScaleAnimation.setKeys(gunScaleKeys), gunPositionAnimation.setKeys(gunPositionKeys), this.gunContainer.animations.push(gunRotationAnimation), this.gunContainer.animations.push(gunScaleAnimation), this.gunContainer.animations.push(gunPositionAnimation)
};

// [LS] GrenadeActor CONSTRUCTOR
function GrenadeActor(grenade, scene) {
    this.grenade = grenade, this.scene = grenade.scene, this.mesh = this.scene.cloneMesh("grenade"), this.mesh.setEnabled(false), this.explodeSound = Sounds.grenade.explode.clone(), this.pinSound = this.mesh.attachSound(Sounds.grenade.pin), this.beepSound = this.mesh.attachSound(Sounds.grenade.beep), this.beep = false, this.flashColor = null
}
GrenadeActor.prototype.throw = function () {
    this.mesh.setEnabled(true), this.mesh.position.x = this.grenade.x, this.mesh.position.y = this.grenade.y, this.mesh.position.z = this.grenade.z, this.grenade.player.id == meId ? this.flashColor = flashColors[0] : this.flashColor = flashColors[this.grenade.player.team], this.pinSound.play(), this.bounce()
};
GrenadeActor.prototype.update = function () {
    this.mesh.position.x = this.grenade.x, this.mesh.position.y = this.grenade.y, this.mesh.position.z = this.grenade.z, this.mesh.rotation.x += this.rx, this.mesh.rotation.y += this.ry, this.mesh.rotation.z += this.rz, 1 < Math.sqrt(this.grenade.ttl) % 2 ? (0 == this.beep && (this.beepSound.play(), this.beep = true), this.mesh.emissiveColor = this.flashColor) : (this.mesh.emissiveColor = BABYLON.Color3.Black(), this.beep = false)
};
GrenadeActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};
GrenadeActor.prototype.bounce = function () {
    var s = Math.length3(this.grenade.dx, this.grenade.dy, this.grenade.dz);
    this.rx = (2 * Math.random() - 1) * s, this.ry = (2 * Math.random() - 1) * s, this.rz = (2 * Math.random() - 1) * s
};
GrenadeActor.prototype.stop = function () {
    this.rx = 0, this.ry = 0, this.rz = 0
};

// [LS] BulletActor CONSTRUCTOR
function BulletActor(bullet) {
    this.scene = bullet.scene, this.bullet = bullet, this.delayFrames = 0, this.mesh = this.scene.getMeshByName("bullet").createInstance(""), this.mesh.setEnabled(false)
}
BulletActor.prototype.fire = function () {
    this.bullet.player.id == meId ? this.delayFrames = Math.ceil(ping / 17) + 5 : this.delayFrames = 5, this.mesh.position.x = this.bullet.x, this.mesh.position.y = this.bullet.y, this.mesh.position.z = this.bullet.z, this.mesh.lookAt(new BABYLON.Vector3(this.bullet.x + this.bullet.dx, this.bullet.y + this.bullet.dy, this.bullet.z + this.bullet.dz)), this.mesh.rotation.x += .015, this.mesh.rotation.y -= .015, this.mesh.scaling.z = .5
};
BulletActor.prototype.update = function () {
    --this.delayFrames <= 0 && this.mesh.setEnabled(true), this.mesh.position.x = this.bullet.x, this.mesh.position.y = this.bullet.y, this.mesh.position.z = this.bullet.z, this.bullet.player.id != meId && (this.mesh.scaling.z = Math.min(this.mesh.scaling.z + .03, 3))
};
BulletActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] RocketActor CONSTRUCTOR
function RocketActor(rocket) {
    this.rocket = rocket, this.scene = rocket.scene, this.armed = false, this.delayFrames = 0, this.mesh = this.scene.getMeshByName("rocket").createInstance(""), this.mesh.setEnabled(false), this.explodeSound = Sounds.rpegg.explode.clone(), this.poofSound = Sounds.rpegg.poof.clone(), this.flySound = this.mesh.attachSound(Sounds.rpegg.fly)
}
RocketActor.prototype.fire = function () {
    this.armed = false, this.rocket.player.id == meId ? this.delayFrames = Math.ceil(ping / 17) + 3 : this.delayFrames = 3, this.mesh.position.x = this.rocket.x, this.mesh.position.y = this.rocket.y, this.mesh.position.z = this.rocket.z, this.mesh.lookAt(new BABYLON.Vector3(this.rocket.x + this.rocket.dx, this.rocket.y + this.rocket.dy, this.rocket.z + this.rocket.dz)), this.mesh.rotation.x += .015, this.mesh.rotation.y -= .015
};
RocketActor.prototype.update = function () {
    if (--this.delayFrames <= 0 && this.mesh.setEnabled(true), !this.armed && this.rocket.ttArmed <= 0 && (this.armed = true, this.flySound.play()), this.delayFrames % 4 == 0) {
        var dx = .04 * Math.random() - .02,
            dy = .04 * Math.random() - .02,
            dz = .04 * Math.random() - .02;
        this.rocket.ttArmed <= 0 && (addExplosionSprite(explosionSmokeManager, 10, this.rocket.x, this.rocket.y, this.rocket.z, dx, dy, dz, .4), addExplosionSprite(explosionFireManager, 10, this.rocket.x, this.rocket.y, this.rocket.z, dx, dy, dz, .4))
    }
    this.mesh.position.x = this.rocket.x, this.mesh.position.y = this.rocket.y, this.mesh.position.z = this.rocket.z
};
RocketActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] GunActor CONSTRUCTOR
function GunActor(gun, meshName) {
    this.gun = gun, this.meshName = meshName, this.scene = gun.scene, this.standardMeshName = gun.subClass.standardMeshName, this.playerActor = gun.player.actor, this.skeleton = this.scene.cloneSkeleton("gun_" + this.standardMeshName + "_skeleton")
};
GunActor.prototype.setup = function (muzFlashZ) {
    this.gunMesh = this.scene.cloneMesh(this.meshName, this.playerActor.gunContainer), this.gunMesh.skeleton = this.skeleton, this.gunMesh.setEnabled(false), muzFlashZ && (this.muzzleFlash = this.scene.cloneMesh("muzzleFlash", this.playerActor.gunContainer), this.muzzleFlash.setEnabled(false), this.muzzleFlash.parent = this.playerActor.gunContainer, this.muzzleFlash.position.x = .25, this.muzzleFlash.position.z = muzFlashZ), this.gun.player.id == meId && (this.gunMesh.setRenderingGroupId(1), this.muzzleFlash && this.muzzleFlash.setRenderingGroupId(1))
};
GunActor.prototype.addSoundEvent = function (animation, frame, sound) {
    frame += this.skeleton.getAnimationRange(animation).from;
    var event = new BABYLON.AnimationEvent(frame, function () {
        sound.play()
    });
    this.skeleton.bones[0].animations[0].addEvent(event)
};
GunActor.prototype.dispose = function () {
    this.gunMesh.dispose()
};
GunActor.prototype.stow = function () {
    var that = this;
    this.scene.beginAnimation(this.playerActor.gunContainer, 0, 25, false, 1, function () {
        that.gunMesh.setEnabled(false), that.gun.equip()
    })
};
GunActor.prototype.equip = function () {
    this.gunMesh.setEnabled(true), this.playerActor.setWeaponSkeleton(this.skeleton), this.scene.beginAnimation(this.playerActor.gunContainer, 30, 55, false, 1)
};
GunActor.prototype.dryFire = function () {
    this.dryFireSound.play()
};
GunActor.prototype.denyFire = function () {
    reticle.fireDenied(), this.dryFireSound.play(), this.denyFireSound.play()
};
GunActor.prototype.fire = function () {
    if (this.fireSound && this.fireSound.play(), this.muzzleFlash) {
        this.muzzleFlash.rotation.z = 3.141 * Math.random(), this.muzzleFlash.setEnabled(true);
        var that = this;
        setTimeout(function () {
            that.muzzleFlash.setEnabled(false)
        }, 40)
    }
    this.skeleton.beginAnimation("fire")
};
GunActor.prototype.reload = function () {
    this.gun.longReloadTime == this.gun.shortReloadTime ? this.skeleton.beginAnimation("reload") : 0 < this.gun.ammo.rounds ? this.skeleton.beginAnimation("shortReload") : this.skeleton.beginAnimation("longReload")
};
GunActor.prototype.update = function () { };

// [LS] Eggk47Actor CONSTRUCTOR
function Eggk47Actor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = .9, this.scopeY = .0438, this.setup(.6), this.fireSound = this.gunMesh.attachSound(Sounds.eggk47.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var removeMag = this.gunMesh.attachSound(Sounds.eggk47.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.eggk47.insertMag),
        cycle = this.gunMesh.attachSound(Sounds.eggk47.cycle);
    this.addSoundEvent("shortReload", 40, removeMag), this.addSoundEvent("shortReload", 130, insertMag), this.addSoundEvent("longReload", 40, removeMag), this.addSoundEvent("longReload", 130, insertMag), this.addSoundEvent("longReload", 155, cycle)
};
(Eggk47Actor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] DozenGaugeActor CONSTRUCTOR
function DozenGaugeActor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = 1, this.scopeY = .072, this.setup(.6), this.fireSound = this.gunMesh.attachSound(Sounds.dozenGauge.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var open = this.gunMesh.attachSound(Sounds.dozenGauge.open),
        load = this.gunMesh.attachSound(Sounds.dozenGauge.load),
        close = this.gunMesh.attachSound(Sounds.dozenGauge.close);
    this.addSoundEvent("reload", 0, open), this.addSoundEvent("reload", 80, load), this.addSoundEvent("reload", 115, close)
};
(DozenGaugeActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] CSG1Actor CONSTRUCTOR
function CSG1Actor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = .5, this.scopeY = .0345, this.setup(.6), this.fireSound = this.gunMesh.attachSound(Sounds.csg1.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var removeMag = this.gunMesh.attachSound(Sounds.eggk47.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.eggk47.insertMag),
        pullAction = this.gunMesh.attachSound(Sounds.csg1.pullAction),
        releaseAction = this.gunMesh.attachSound(Sounds.csg1.releaseAction);
    this.addSoundEvent("shortReload", 30, removeMag), this.addSoundEvent("shortReload", 120, insertMag), this.addSoundEvent("longReload", 30, pullAction), this.addSoundEvent("longReload", 75, removeMag), this.addSoundEvent("longReload", 165, insertMag), this.addSoundEvent("longReload", 200, releaseAction)
};
(CSG1Actor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] Cluck9mmActor CONSTRUCTOR
function Cluck9mmActor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = 1.1, this.scopeY = .069, this.setup(.48), this.fireSound = this.gunMesh.attachSound(Sounds.cluck9mm.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire);
    var removeMag = this.gunMesh.attachSound(Sounds.cluck9mm.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.cluck9mm.insertMag),
        cycle = this.gunMesh.attachSound(Sounds.eggk47.cycle);
    this.addSoundEvent("shortReload", 15, removeMag), this.addSoundEvent("shortReload", 100, insertMag), this.addSoundEvent("longReload", 15, removeMag), this.addSoundEvent("longReload", 100, insertMag), this.addSoundEvent("longReload", 155, cycle)
};
(Cluck9mmActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] RPEGGActor CONSTRUCTOR
function RPEGGActor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = .9, this.scopeY = .1 - .0862, this.setup(.51), this.fireSound = this.gunMesh.attachSound(Sounds.rpegg.fire), this.dryFireSound = this.gunMesh.attachSound(Sounds.eggk47.dryFire), this.denyFireSound = this.gunMesh.attachSound(Sounds.rpegg.denyFire);
    var loadRocket = this.gunMesh.attachSound(Sounds.rpegg.load);
    this.addSoundEvent("reload", 115, loadRocket)
};
(RPEGGActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;
ItemActor.prototype.update = function (delta) {
    this.mesh.rotation.y += .03 * delta
};

// [LS] ItemActor CONSTRUCTOR
function ItemActor(kind) {
    this.kind = kind, this.scene = gameScene
};
ItemActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] AmmoActor CONSTRUCTOR
function AmmoActor() {
    ItemActor.call(this, ItemTypes.AMMO), this.mesh = this.scene.getMeshByName("ammo").createInstance(""), this.mesh.setEnabled(false), shadowGen && shadowGen.getShadowMap().renderList.push(this.mesh)
};
AmmoActor.prototype = Object.create(ItemActor.prototype);
AmmoActor.prototype.constructor = ItemActor;

// [LS] GrenadeItemActor CONSTRUCTOR
function GrenadeItemActor() {
    ItemActor.call(this, ItemTypes.GRENADE), this.mesh = this.scene.getMeshByName("grenadeItem").createInstance(""), this.mesh.setEnabled(false), shadowGen && shadowGen.getShadowMap().renderList.push(this.mesh)
};
GrenadeItemActor.prototype = Object.create(ItemActor.prototype);
GrenadeItemActor.constructor = ItemActor;

// [LS] ######## Object Constructors ---------------------------------
//   ___  ___    _ ___ ___ _____ ___ 
//  / _ \| _ )_ | | __/ __|_   _/ __|
// | (_) | _ \ || | _| (__  | | \__ \
//  \___/|___/\__/|___\___| |_| |___/                                 

LEGACYSHELLPLAYERCONSTRUCTOR

LEGACYSHELLBULLETS

LEGACYSHELLGUNS

// [LS] Scope CONSTRUCTOR
function Scope() {
    this.crosshairs = new BABYLON.AbstractMesh("", gameScene), this.crosshairs.setEnabled(false), this.crosshairs.position.z = 2;
    var p = [new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(1, 0, 0)],
        l = BABYLON.MeshBuilder.CreateLines("", {
            points: p
        }, gameScene);
    l.layerMask = 536870912, l.color = BABYLON.Color3.Black(), l.parent = this.crosshairs, p = [new BABYLON.Vector3(0, -1, 0), new BABYLON.Vector3(0, 1, 0)], (l = BABYLON.MeshBuilder.CreateLines("", {
        points: p
    }, gameScene)).layerMask = 536870912, l.color = BABYLON.Color3.Black(), l.parent = this.crosshairs
};
Scope.prototype.show = function () {
    var h = engine.getRenderHeight();
    this.crosshairs.scaling.x = h / 2, this.crosshairs.scaling.y = h / 2, this.crosshairs.setEnabled(true), document.getElementById("scopeBorder").style.display = "block", camera.viewport.width = h / engine.getRenderWidth(), camera.viewport.x = .5 - .5 * camera.viewport.width
};
Scope.prototype.hide = function () {
    this.crosshairs.setEnabled(false), document.getElementById("scopeBorder").style.display = "none", camera.viewport.width = 1, camera.viewport.x = 0
};

// [LS] HitIndicator CONSTRUCTOR
function HitIndicator() {
    this.mesh = new BABYLON.Mesh("hitIndicator", gameScene), this.mesh.updatable = true, this.mesh.hasVertexAlpha = true, this.positions = [0, 0, 0, 0, .5, 0, .5, .5, 0, .5, 0, 0, .5, -.5, 0, 0, -.5, 0, -.5, -.5, 0, -.5, 0, 0, -.5, .5, 0];
    this.colors = new Array(48).fill(0);
    for (var i = 0; i < 48; i += 4) this.colors[i] = 1, this.colors[i + 1] = .9, this.colors[i + 2] = 0, this.colors[i + 3] = -.5;
    var vertexData = new BABYLON.VertexData;
    vertexData.positions = this.positions, vertexData.indices = [0, 1, 8, 0, 2, 1, 0, 2, 1, 0, 3, 2, 0, 3, 2, 0, 4, 3, 0, 4, 3, 0, 5, 4, 0, 5, 4, 0, 6, 5, 0, 6, 5, 0, 7, 6, 0, 7, 6, 0, 8, 7, 0, 8, 7, 0, 1, 8], vertexData.colors = this.colors, vertexData.applyToMesh(this.mesh, true), this.mesh.layerMask = 536870912, this.mesh.material = gameScene.getMaterialByName("ui"), this.resize()
};
HitIndicator.prototype.resize = function () {
    this.mesh.scaling.x = engine.getRenderWidth(), this.mesh.scaling.y = engine.getRenderHeight()
};
HitIndicator.prototype.update = function (delta) {
    for (var i = 7; i < 48; i += 4) this.colors[i] -= (this.colors[i] + .5) / 10 * delta;
    var mult = Math.pow(.9, delta);
    me && me.playing && (camera.position.x *= mult, camera.position.z *= mult), this.mesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, this.colors, true)
};
HitIndicator.prototype.hit = function (dx, dz) {
    var a = Math.radRange(-Math.atan2(dx, -dz) - me.yaw + .393);
    a = Math.floor(a / Math.PI2 * 8);
    var vec = new BABYLON.Vector2(-this.positions[3 * a + 3], -this.positions[3 * a + 4]).normalize();
    camera.position.x = .03 * vec.x, camera.position.z = .03 * vec.y, this.colors[4 * a + 7] = 2
};

// [LS] Reticle CONSTRUCTOR
function Reticle() {
    this.crosshairs = [];
    for (var i = 0; i < 4; i++) this.crosshairs.push(document.getElementById("crosshair" + i));
    this.readyBrackets = document.getElementById("readyBrackets")
};
Reticle.prototype.show = function () {
    if (document.getElementById("reticleContainer").className = "", me.weapon.subClass.readySpread) {
        this.readyBrackets.className = "notReady";
        var size = .069 * me.weapon.subClass.readySpread * 10 + "em";
        this.readyBrackets.style.width = size, this.readyBrackets.style.height = size
    } else this.readyBrackets.className = "hideme"
};
Reticle.prototype.hide = function () {
    document.getElementById("reticleContainer").className = "hideme"
};
Reticle.prototype.fireDenied = function () {
    this.readyBrackets.className = "";
    var that = this;
    setTimeout(function () {
        that.readyBrackets.className = "notReady"
    }, 10)
};
Reticle.prototype.update = function (delta) {
    if (me.weapon) {
        for (var i = 0; i < 4; i++) {
            var spread = me.shotSpread + me.weapon.subClass.accuracy;
            this.crosshairs[i].style.transform = "rotate(" + 90 * i + "deg) translateY(" + (.069 * spread + .12) + "em)"
        }
        me.weapon.subClass.readySpread && (spread <= 5 * me.weapon.subClass.accuracy ? this.readyBrackets.className = "ready" : this.readyBrackets.className = "notReady")
    }
};
Reticle.prototype.resize = function () { };


// [LS] ######## MANAGERS ---------------------------------
//  __  __   _   _  _   _   ___ ___ ___  ___ 
// |  \/  | /_\ | \| | /_\ / __| __| _ \/ __|
// | |\/| |/ _ \| .` |/ _ \ (_ | _||   /\__ \
// |_|  |_/_/ \_\_|\_/_/ \_\___|___|_|_\|___/

// [LS] Pool CONSTRUCTOR
LEGACYSHELLPOOL

// [LS] MunitionsManager CONSTRUCTOR
LEGACYSHELLMUNITIONSMANAGER

// [LS] ItemManager CONSTRUCTOR
LEGACYSHELLITEMMANAGER


// [LS] ######## Math Extensions ---------------------------------
//  __  __   _ _____ _  _ 
// |  \/  | /_\_   _| || |
// | |\/| |/ _ \| | | __ |
// |_|  |_/_/ \_\_| |_||_|

LEGACYSHELLMATHEXTENSIONS

extendMath(Math);

// [LS] ######## Horseshit ---------------------------------
//  _  _  ___  ___  ___ ___ ___ _  _ ___ _____ 
// | || |/ _ \| _ \/ __| __/ __| || |_ _|_   _|
// | __ | (_) |   /\__ \ _|\__ \ __ || |  | |  
// |_||_|\___/|_|_\|___/___|___/_||_|___| |_|  

//Q: What is "horseshit"?
//A: Stuff to do with ads and trackers. Most if not all is now disabled - nice.

function ga() {
    //yeah screw the tracker
};

function fetchHouseAds() {
    getRequest(parsedUrl.root + "housePromo.json?" + Date.now(), function (err, res) {
        err ? (houseAds = {
            big: [],
            small: [],
            houseAdPercentChance: 100
        }, houseAdsLoaded = true) : (houseAds = JSON.parse(res), houseAdsLoaded = true, function () {
            for (var adIdxs = [], i = 0; i < houseAds.small.length; i++) houseAds.small[i].active && adIdxs.push(i);
            0 < adIdxs.length && (smallAdIdx = adIdxs[Date.now() % adIdxs.length], document.getElementById("houseAd_300x250").src = "img/promo/" + houseAds.small[smallAdIdx].id + houseAds.small[smallAdIdx].imageExt)
        }())
    })
};

function hideBigAd() {
    clearTimeout(bigAdTimeout), document.getElementById("bigAd").style.display = "none", loadBannerAd()
};

function uglifyLogs () { //oh no! it isnt ever called! ah, so sad...
    window.console = function (origConsole) {
        window.console && origConsole || (origConsole = {});
        var logArray = [];
        return {
            dir: function () {
                origConsole.dir && origConsole.dir.apply(origConsole, arguments)
            },
            log: function () {
                this.addLog(arguments), origConsole.log && origConsole.log.apply(origConsole, arguments)
            },
            warn: function () {
                this.addLog(arguments), origConsole.warn && origConsole.warn.apply(origConsole, arguments)
            },
            error: function () {
                this.addLog(arguments), origConsole.error && origConsole.error.apply(origConsole, arguments)
            },
            info: function () {
                this.addLog(arguments), origConsole.info && origConsole.info.apply(origConsole, arguments)
            },
            addLog: function (args) {
                var msg = args[0];
                "object" == typeof msg && (msg = JSON.stringify(msg)), logArray.push(msg), 100 < logArray.length && logArray.shift()
            },
            logArray: function () {
                return logArray
            },
            clearLog: function () {
                logArray = []
            }
        }
    }(window.console);

    //this is fucking shit. why is this here? what does this achieve? its awful for debugging, it doesnt hide the fucking crashes from the end user. so why is it here????
    // window.onerror = function (msg, url, lineNo, columnNo, error) {
    //     var str = ["Message: " + msg, "URL: " + url, "Line: " + lineNo, "Column: " + columnNo].join("\n");
    //     return str += JSON.stringify(error, ["message", "arguments", "type", "name"]) + "\n", console.log(str), false
    // };
};

function PlayerReward(tag, openUrl, openUrlMsg) { //unused in legacyshell
    this.tag = tag, this.openUrl = openUrl, this.openUrlMsg = openUrlMsg, this.wasUrlOpened = null
};

//this could go into bs but eh.
parsedUrl.query.adTest && (adTest = true);
var lastBannerLoaded, aipBannerDisplayed = false,
    aipMultisizeBannerDisplayed = false;

function loadBannerAd() {
    if ("none" == document.getElementById("overlay").style.display)
        if (document.getElementById("placeholder_300x250").style.display = "none", document.getElementById("multisizeBannerAdPlaceholder").style.display = "none", inGame && betweenRounds) displayBannerAd("bannerAdContainer", "houseAd_300x250"), ga("send", "event", {
            eventCategory: "House banner ad",
            eventAction: "show",
            eventLabel: houseAds.small[smallAdIdx].label
        });
        else if (inGame) {
            if (true !== playerAccount.hideAds) displayBannerAd("gameAdContainer", tag = "shellshock-io_multisize"), loadMultisizeAd(tag)
        } else {
            // if (true === playerAccount.hideAds && (0 === houseAds.houseAdPercentChance || 0 === houseAds.small.length)) return void (document.getElementById("menuAdContainer").style.display = "none");
            // if (100 * Math.random() <= houseAds.houseAdPercentChance || true === playerAccount.hideAds) return void displayBannerAd("bannerAdContainer", "houseAd_300x250");
            // var tag;
            // displayBannerAd("bannerAdContainer", tag = "shellshock-io_300x250"), aipBannerDisplayed ? aiptag.cmd.display.push(function () {
            //     aipRefreshBannerForTag(tag)
            // }) : (aiptag.cmd.display.push(function () {
            //     aipDisplayBannerForTag(tag)
            // }), aipBannerDisplayed = true)
        }
};

// window.onbeforeunload = function (e) { //glowing stuff
//     if (0 < gameStartTime) {
//         var timePlayed = Date.now() - gameStartTime;
//         if (ga("send", "timing", "game", "play time", timePlayed), fbq("trackCustom", "EndGame", {
//             timePlayed: timePlayed
//         }), me && 0 < kills) {
//             var ratio = Math.floor(kills / Math.max(kills + deaths, 1) * 100);
//         }
//     }
//     if (4 < pingSamples) {
//         ga("send", "timing", "game", "ping", Math.floor(pingTotal / pingSamples), servers[selectedServer].name);
//         ga("send", "event", "game", "stats", "fps", Math.ceil(fpsTotal / fpsSamples));
//         ga("send", "event", "game", "settings", "volume", settings.volume);
//         ga("send", "event", "game", "settings", "mouse sensitivity", settings.mouseSensitivity);
//         ga("send", "event", "game", "settings", "mouse invert", settings.mouseInvert);
//     };
// };

function loadMultisizeAd(tag) { //no
    // console.log("loading multisize ad"), aipMultisizeBannerDisplayed ? aiptag.cmd.display.push(function () {
    //     aipRefreshBannerForTag(tag)
    // }) : (aiptag.cmd.display.push(function () {
    //     aipDisplayBannerForTag(tag)
    // }), aipMultisizeBannerDisplayed = true)
};

//why is this code so fucking sketchy
// i = window;
// s = document;

function displayBannerAd(parentContainerId, id) { //sod off
    // var el = document.getElementById(parentContainerId);
    // el.style.display = "block";
    // for (var i = 0; i < el.children.length; i++) el.children[i].id == id ? (document.getElementById(id).style.display = "block", lastBannerLoaded = id) : document.getElementById(el.children[i].id).style.display = "none"
};

function hideBannerAd() {
    // hideBannerAdInContainer("bannerAdContainer", "placeholder_300x250")
};

function hideMultisizeBannerAd() {
    // hideBannerAdInContainer("gameAdContainer", "multisizeBannerAdPlaceholder"), aiptag.cmd.display.push(function () {
    //     aipDisplayTag.destroy("shellshock-io_multisize")
    // })
};

function hideBannerAdInContainer(parentContainerId, placeholderId) {
    // for (var el = document.getElementById(parentContainerId), i = 0; i < el.children.length; i++) document.getElementById(el.children[i].id).style.display = "none";
    // document.getElementById(placeholderId).style.display = "block"
};

function showBannerAd() {
    // showBannerAdWithPlaceholder("placeholder_300x250")
};

function showBannerAdWithPlaceholder(placeholderId) {
    // document.getElementById(placeholderId).style.display = lastBannerLoaded ? (document.getElementById(lastBannerLoaded).style.display = "block", "none") : "block"
};

function aipDisplayBannerForTag(tag) {
    try {
        aipDisplayTag.display(tag)
    } catch (e) {
        console.log(e)
    }
};

function aipRefreshBannerForTag(tag) {
    // try {
    //     aipDisplayTag.refresh(tag)
    // } catch (e) {
    //     console.log(e)
    // }
};

function playVideoAd() { //no thanks
    // if (true !== playerAccount.hideAds) {
    //     0,
    //         false,
    //         console.log("AIP preroll"),
    //         showDarkOverlay(),
    //         aiptag.cmd.player.push(function () {
    //             try {
    //                 aipPrerollPlayer.startPreRoll()
    //             } catch (e) {
    //                 console.log(e)
    //             }
    //         }),
    //         localStorage.setItem("lastPreRoll", Date.now())
    // }
    // else afterVideoAdComplete()
};

function isTimeToPlayVideoAd() {
    if (true === playerAccount.hideAds) return false;
    var lastPreRoll = getStoredNumber("lastPreRoll", Date.now()),
        timeout = 42e4;
    return adTest && (timeout = 2e3), 1 < timesPlayed && 1 < deaths && Date.now() > lastPreRoll + timeout
}

function setApplixirPopup(show) {
    var applixirPopup = document.getElementById("applixirPopup"),
        applixirParentFrame = document.getElementById("applixir_parentFrame");
    if (true === show) {
        applixirPopup.classList.remove("hideme");
        var frameSrc = "app_nugget/applixir.html?firebaseId=" + playerAccount.firebaseId;
        frameSrc += "&reward=nugget", applixirParentFrame.src = frameSrc
    } else applixirPopup.classList.add("hideme"), applixirParentFrame.src = "about:blank"
};

function showSmallAd() { //no.
    // loadBannerAd(), swiftShaderCheck()
};

// function afterVideoAdComplete() {
//     inGame ? (hideDarkOverlay(), timedGame && (openGameMenu(), showGameSummary(), resetGame())) : isGettingNugget ? buyChickenNuggetProduct() : (hideDarkOverlay(), joinGame()), BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume)
// };

function swiftShaderCheck() {
    if ("Google SwiftShader" != engine.getGlInfo().renderer || localStorage.getItem("swiftShaderNotice")) return false;
    return openAlertDialog("SwiftShader? GROSS!", '<div style="text-align: left">It looks like your graphics card is on Chrome\'s blacklist for some reason. The game will still run, but very slowly. To change this, enter "chrome://flags" in your address bar, search for "Override software rendering list", and enable it.<br><br>CAUTION: The blacklist exists for a reason. This may make your system unstable. Make sure you save anything you\'re working on before trying it!</div>', "OK"), localStorage.setItem("swiftShaderNotice", true), true
};

function detectChromebook() {
    return /\bCrOS\b/.test(navigator.userAgent)
};

function unbloated2() { //no thanks!
    // console.log("Sending gameplay tags to OneSignal...");
    // var gameplayTags = {
    //     username: username,
    //     fps: Math.floor(fpsAverage)
    // };
    // unbloated3(gameplayTags), console.log("tags: " + JSON.stringify(gameplayTags))
};

function unbloated3(tags) { //nope! thanks!
    // OneSignal.push(function () {
    //     OneSignal.sendTags(tags).then(function (tagsSent) {
    //         console.log("Completed sending tags to OneSignal")
    //     })
    // })
};

// [LS] ######## Loading ---------------------------------
//  _    ___   _   ___ ___ _  _  ___ 
// | |  / _ \ /_\ |   \_ _| \| |/ __|
// | |_| (_) / _ \| |) | || .` | (_ |
// |____\___/_/ \_\___/___|_|\_|\___|


// [LS] Load Sequence: Startup
function onPageLoaded () {
    selectedServer = getStoredNumber("selectedServer", 0);
    lastVer = getStoredString("lastVersionPlayed", version);
    localStorage.setItem("lastVersionPlayed", version);

    if (lastVer != version) return (req = window.indexedDB.deleteDatabase("babylonjs")).onerror = function (event) {
        window.location.reload(true)
    }, void (req.onsuccess = function (event) {
        window.location.reload(true)
    });

    // var req;

    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
    var str = "",
        missingFeatures = 0;
    BABYLON.Engine.isSupported() || (str += '<li>WebGL (<a href="https://legacy.onlypuppy7.online/faq.html#webgl" target="_window">More info</a>)', missingFeatures++);
    (!document.exitPointerLock || 0 <= navigator.userAgent.indexOf("10.1.2 Safari")) && (str += '<li>Pointer Lock (<a href="https://legacy.onlypuppy7.online/faq.html#pointerlock" target="_window">More info</a>)', missingFeatures++);
    localStorage || (str += "<li>LocalStorage", missingFeatures++);
    void 0 === new KeyboardEvent("").key && (str += "<li>KeyboardEvent.key", missingFeatures++);


    if (0 < missingFeatures) {
        str = 1 == missingFeatures ? "Your browser is missing a feature that Shell Shockers requires:<br><ul>" + str + "</ul>" : "Your browser is missing features that Shell Shockers requires:<br><ul>" + str + "</ul>";
        openAlertDialog("Oh, no!", '<div style="text-align: left">' + (str += "Downloading the latest version of your browser of choice will usually correct this. Internet Explorer is not supported.") + "</div>");
    } else {
        chatInEl = document.getElementById("chatIn");
        chatOutEl = document.getElementById("chatOut");
        killEl = document.getElementById("killTicker");
        "undefined" != typeof noAdBlock && (adBlock = false);
        
        // document.getElementById("privacyOptionsLink").style.display = isFromEU ? "block" : "none";
        gameType = getStoredNumber("gameType", GameType.ffa);
        for (var gameTypeSelect = document.getElementById("gameTypeSelect"), i = 0; i < GameTypes.length; i++) {
            var gt = GameTypes[i];
            gt.el = document.createElement("option"), gt.el.textContent = gt.longName, gameTypeSelect.appendChild(gt.el)
        };
        gameTypeSelect.selectedIndex = gameType,
            function () {
                var container = document.getElementById("bindingsContainer");
                for (var k in settingsKeyNames) {
                    var row = document.createElement("div"),
                        keyCell = document.createElement("span");
                    keyCell.className = "box defined", keyCell.innerText = getLocText("ui_settings_undefined"), keyCell.tabIndex = 1, keyCell.id = settingsKeyNames[k], keyCell.onmousedown = configKey, keyCell.onwheel = configKey, settingsKeyCells[settingsKeyNames[k]] = keyCell, row.appendChild(keyCell);
                    var nameCell = document.createElement("span");
                    nameCell.className = "label", nameCell.innerText = getLocText("ui_settings_bind_" + settingsKeyNames[k]), row.appendChild(nameCell), container.appendChild(row)
                };
            }(), loadSettings(),
            function () {
                var mapSelect = document.getElementById("mapSelect"),
                    el = document.createElement("option");
                for (var i in el.textContent = "[Random Map]", mapSelect.appendChild(el), minMaps) {
                    var map = minMaps[i],
                        el = document.createElement("option");
                    el.textContent = map.name, mapSelect.appendChild(el)
                };
            }();
        for (var playerList = document.getElementById("playerList"), slotTemplate = document.getElementById("playerSlot"), i = 0; i < 20; i++) {
            var slot = slotTemplate.cloneNode(true);
            playerList.appendChild(slot)
        };
        for (var containerEl = document.getElementById("leaderboard"), team = 0; team < 3; team++) {
            var teamEl = document.getElementById("teamSummary").cloneNode(true);
            teamEl.style.color = teamColors.text[team], teamEl.style.backgroundColor = teamColors.summaryBackground[team], teamSummaryEls.push(teamEl);
            teamEl.children[0];
            for (var i = 0; i < 20; i++) {
                var rowEl = document.getElementById("teamRow").cloneNode(true);
                rowEl.children[0].innerText = i + 1, rowEl.style.display = "flex", rowEl.style.background = i % 2 == 0 ? "rgba(0, 0, 0, 0.25)" : "transparent", teamEl.appendChild(rowEl)
            };
            containerEl.appendChild(teamEl)
        };

        fetchTwitchStreams();
        fetchHouseAds();
        resize();
        console.log("From EU: " + isFromEU);
        itemRenderer = new ItemRenderer;
        canvas = document.getElementById("canvas");
        engine = new BABYLON.Engine(canvas, true, null, false);
        engineCaps = engine.getCaps();
        BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume);
        0 == settings.volume ? BABYLON.Engine.audioEngine.audioContext.suspend() : BABYLON.Engine.audioEngine.audioContext.resume();
        settings.autoDetail || settings.highRes || lowerResolution();

        parsedUrl.query.openSettings && openSettingsMenu();
        parsedUrl.query.test && (testing = true);
        parsedUrl.query.noSkybox && (noSkybox = true);

        if (parsedUrl.query.testMap) {
            playOffline = true;
            mapTest.x = parsedUrl.query.x;
            mapTest.y = parsedUrl.query.y;
            mapTest.z = parsedUrl.query.z;
            mapTest.pitch = parsedUrl.query.pitch;
            mapTest.yaw = parsedUrl.query.yaw;
            playerLimit = 1;
            ws = {
                send: function () { }
            };
            inGame = true;
            engine.stopRenderLoop();
            void startGame();
            return;
        };

        let authToken = localStorage.getItem("LegacyShellAuthToken");
        let previousUsername = localStorage.getItem("LegacyShellPreviousUsername");
        try {
            if (authToken) {
                showSpinner("Retrieving Account", "I KNOW you're in here somewhere...");
                devlog("awaiting............");
                validateLoginViaAuthToken(previousUsername, authToken).then(result => {
                    // hideSpinner(); //will be hidden on resources loaded anyway
                    devlog(result);
                    if (result.error) {
                        devlog("fail 4");
                        showSpinner("Login Failed", result.error);
                        loginFail(result.error === "Too many requests. Please try again later."); //ratelimited
                    } else if (result.session) {
                        showSpinner("Logged In", "It's coming!");
                        loggedIn(result);
                    };
                }).catch((err) => {
                    devlog("damn", err)
                    // hideSpinner();
                    devlog("fail 3");
                    loginFail(true);
                });
            } else {
                devlog("fail 2");
                loginFail();
            };
        } catch (error) {
            devlog("fail 1");
            loginFail();
        };
        
        if (parsedUrl.hash) {
            openJoinBox();
            document.getElementById("joinCode").value = parsedUrl.hash;
        };
        var nameBox = document.getElementById("nickname");
        nameBox.value = getStoredString("lastNickname", "");
        nameBox.addEventListener("keyup", function (event) {
            nameBox.value = fixStringWidth(event.target.value);
            "Enter" != event.code && 13 != event.keyCode || 0 < nameBox.value.length && (nameBox.disabled = true, play());
        });
    };
};
window.onload = onPageLoaded;

// [LS] Load Sequence: Joining and prepping the game
function play() { //1st, button pressed on menu
    console.log("play()");
    dismissNotification();
    if (0 < settings.volume) try {
        BABYLON.Engine.audioEngine.audioContext.resume()
    } catch (e) {
        console.log(e)
    };
    if (0 == (nickname = document.getElementById("nickname").value.trim()).length) {
        nickname = randomName();
    };
    document.body.scrollTop = document.documentElement.scrollTop = 0;
    timesPlayed = getStoredNumber("timesPlayed", 0);
    localStorage.setItem("timesPlayed", timesPlayed + 1);
    
    // var lastPreRoll = getStoredNumber("lastPreRoll", 0);
    // 0 == lastPreRoll && (lastPreRoll = Date.now(), localStorage.setItem("lastPreRoll", lastPreRoll)), adTest || Date.now() > lastPreRoll + 3e5 && timesPlayed % 2 == 1 && false ? (console.log("play() calls PVA"), playVideoAd()) : joinGame()

    joinGame();
};

function joinGame() { //2nd, request made to server to find game. handles cases where game isnt found
    var url;
    joinResult = null;
    var server = selectedServer;
    joinType = Comm.Code.joinPublicGame;
    var protocol = "ws://";
    "https:" === location.protocol && (protocol = "wss://");
    console.log("joinGame()", protocol);

    var joinGameId = document.getElementById("joinCode").value.trim();
    var mapId = 0;

    autoInvite = false;

    if ("none" != document.getElementById("createGame").style.display) {
        joinType = Comm.Code.createPrivateGame;
        url = protocol + servers[server].address;
        (mapId = document.getElementById("mapSelect").selectedIndex - 1) < 0 ? mapId = Math.randomInt(0, minMaps.length) : autoInvite = true;
    } else if ("" != joinGameId) {
        joinType = Comm.Code.joinPrivateGame;
        joinGameId.startsWith("#") && (joinGameId = joinGameId.substr(1));
        
        server = Number.parseInt(joinGameId.substr(0, 1), 36);
        gameId = Number.parseInt(joinGameId.substr(1, 3), 36);
        gameKey = Number.parseInt(joinGameId.substr(4, 2), 36);

        try {
            devlog(protocol, servers, server);
            url = protocol + servers[server].address;
        } catch (e) {
            return console.log("Game not found - Invalid server: " + url + ", " + server), openAlertDialog("Game Not Found", "Sorry! This game ID is either<br>invalid, or no longer exists.", {
                label: "OK"
            }), gameKey = gameId = 0, void (document.getElementById("joinCode").value = "")
        }
        selectedServer = server
    } else url = protocol + servers[server].address;
    showDarkOverlay();
    showSpinner("Connecting", "Please wait!");
    console.log("Connecting to: " + url);
    (ws = new WebSocket(url)).binaryType = "arraybuffer";

    ws.onopen = function (e) {
        console.log("WebSocket opened");
        localStorage.setItem("lastNickname", nickname);

        //added dynamic output buffer size so this isnt necessary. trust me: the "performance" ISNT WORTH IT
        // var len = 16 + 2 * nickname.length;
        // if (playerAccount.isLoggedIn) {
        //     console.log("session available", len);
        //     len += (1 + (2 * playerAccount.session.length));
        // };

        var output = new Comm.Out(); //len
        output.packInt8(Comm.Code.joinGame);
        output.packInt8(joinType);
        output.packInt8(gameType);
        output.packInt8(mapId);
        output.packInt16(gameId);
        output.packInt16(gameKey);
        output.packInt8(playerAccount.classIdx);
        output.packInt8(catalog.get8BitItemId(playerAccount.getPrimaryWeapon(), playerAccount.classIdx));
        output.packInt8(catalog.get8BitItemId(playerAccount.getSecondaryWeapon(), playerAccount.classIdx));
        output.packInt8(playerAccount.colorIdx);
        output.packInt8(catalog.get8BitItemId(playerAccount.hatItem, playerAccount.classIdx));
        output.packInt8(catalog.get8BitItemId(playerAccount.stampItem, playerAccount.classIdx));
        output.packString(nickname);
        if (playerAccount.isLoggedIn) {
            output.packString(playerAccount.session);
            // devlog(len, output)
            // output.packString(playerAccount.account_id);
            // console.log("account_id: " + playerAccount.account_id);
            // devlog(len, output)
        };
        wsSend(output, "joinGame");
    }, ws.onclose = function (e) {
        if (!freezeFrame)
            if (e.code == Comm.Close.gameNotFound) {
                console.log("Game not found - id: " + gameId + ", key: " + gameKey);
                openAlertDialog("Game Not Found", "Sorry! This game ID is either<br>invalid, or no longer exists.", {
                    label: "OK"
                });
                gameKey = gameId = 0;
                document.getElementById("joinCode").value = "";
            } else if (e.code == Comm.Close.gameFull) {
                console.log("Game full - id: " + gameId + ", key: " + gameKey);
                openAlertDialog("Game Full", "Sorry, this game is currently full!<br>Wait a moment, or try another one!", {
                    label: "OK"
                });
            } else if (e.code == Comm.Close.badName) {
                closeAlertDialog();
                openAlertDialog("Invalid Name", "I'm going to guess you know why.", {
                    label: "Yes"
                });
                var el = document.getElementById("nickname");
                el.value = "";
                el.disabled = false;
                el.focus();
                document.getElementById("playButton").disabled = false;
            } else if (e.code == Comm.Close.mainMenu) {
                console.log("WebSocket closing - returning to Main Menu");
            } else if (e.code == Comm.Close.masterServerBusy) {
                console.log("Master Server busy");
                openAlertDialog("Matchmaker Busy", "Sorry! The match-maker is currently busy serving other players.<br>Please try again in a moment!", {
                    label: "OK"
                });
                gameKey = gameId = 0;
                document.getElementById("joinCode").value = "";
            } else if (e.code == Comm.Close.masterServerOffline) {
                console.log("Master Server offline");
                openAlertDialog("Matchmaker Offline", "Oops! The match-maker is currently inaccessible.<br>Drop us a line and let us know!", {
                    label: "OK"
                });
                gameKey = gameId = 0;
                document.getElementById("joinCode").value = "";
            } else if (inGame) {
                console.log("Connection lost: " + e.code + " " + e.reason);
                openAlertDialog("Connection Lost", "Please try a different server,<br>or try again later!", {
                    label: "OK",
                    onclick: reloadPage
                });
            } else {
                console.log("Cannot connect: " + e.code + " " + e.reason);
                var message = "";
                switch (joinResult) {
                    case Comm.Code.banned:
                        message = "You are not allowed to join this game.<br><br>Maybe you know why?";
                        break;
                    default:
                        message = 'Please try a different server, reload<br>the page, or try again later!<br><br>Also, visit <a href="http://websocketstest.com" target="_window">websocketstest.com</a> to check for<br>problems with your network and/or system!'
                }
                openAlertDialog("Cannot Connect", message, {
                    label: "OK",
                    onclick: closeAlertDialog
                })
            }
    }, ws.onmessage = function (e) {
        var input = new Comm.In(e.data);
        var joinResult = input.unPackInt8U();
        devlog("joinResult", joinResult, Comm.Code.gameJoined, joinResult == Comm.Code.gameJoined, joinResult === Comm.Code.gameJoined);
        switch (joinResult) {
            case Comm.Code.gameJoined:
                console.log("Comm.Code.gameJoined received");
                document.getElementById("mainMenu").style.display = "none";
                meId = input.unPackInt8U();
                myTeam = input.unPackInt8U();
                gameType = input.unPackInt8U();
                gameId = input.unPackInt16U();
                gameKey = input.unPackInt16U();
                mapIdx = input.unPackInt8U();
                playerLimit = input.unPackInt8U();
                isGameOwner = 1 == input.unPackInt8U();
                console.log("is game owner: " + isGameOwner);
                devlog("meId, myTeam, gameType, gameId, gameKey, mapIdx, playerLimit, isGameOwner", meId, myTeam, gameType, gameId, gameKey, mapIdx, playerLimit, isGameOwner);
                inGame = true;
                startGame();
                break;
        }; 
    };
};

var unfocused = false;

function startGame () { //3rd, initialises much of the game's variables, creates scene.
    //no thanks!
    // var oneSignalBell = document.getElementById("onesignal-bell-container");
    // oneSignalBell && (oneSignalBell.style.display = "none");
    document.getElementById("showBuyPassDialogButton").classList.add("hideme");
    document.getElementById("upgradeIndicator").classList.add("ingame");
    players = [], {};
    oldClockSeconds = viewingPlayer = me = respawnTime = null;
    grenadePowerUp = betweenRounds = !(escPressed = true);
    lastTimeStamp = performance.now(), 0;
    ping = 0;
    bestOverallStreak = deaths = kills = fpsAverage = fpsSamples = fpsTotal = pingSamples = pingTotal = highestPing = 0;
    gameStartTime = Date.now(), Date.now() + 1e3;
    engine.clear(BABYLON.Color3.Black());
    engine.stopRenderLoop();
    gameScene = new BABYLON.Scene(engine);
    settings.autoDetail || (gameScene.shadowsEnabled = settings.shadowsEnabled);
    gameScene.autoClear = false;
    gameScene.autoClearDepthAndStencil = false;
    settings.autoDetail && enableAutoDetail();

    gameScene.ambientColor = new BABYLON.Color3(.2, .2, .2);
    gameScene.fogMode = BABYLON.Scene.FOGMODE_EXP;
    gameScene.fogColor = new BABYLON.Color4(.5, .55, .6, 1);
    gameScene.fogDensity = .025;
    gameScene.clearColor = BABYLON.Color3.Black();

    shadowLight = new BABYLON.DirectionalLight("", new BABYLON.Vector3(0, -1, 0), gameScene)
    shadowLight.lightmapMode = BABYLON.Light.LIGHTMAP_SHADOWSONLY;
    shadowLight.intensity = 1.2;
    shadowLight.autoUpdateExtends = false;
    shadowLight.shadowMinZ = .05;
    shadowLight.shadowMaxZ = 40;
    shadowLight.shadowFrustumSize = 15;
    //todo: shadow improver
    shadowGen = new BABYLON.ShadowGenerator(1024 * 1, shadowLight);
    shadowGen.forceBackFacesOnly = true;

    gameScene.sunLight = new BABYLON.HemisphericLight("sunLight", new BABYLON.Vector3(0, -1, 0), gameScene);
    gameScene.sunLight.intensity = .8, camera = new BABYLON.TargetCamera("camera", BABYLON.Vector3.Zero(), gameScene);

    gameScene.activeCameras.push(camera);

    camera.maxZ = 100;
    camera.fov = 1.25;
    camera.minZ = .05;

    (uiCamera = new BABYLON.FreeCamera("uiCamera", new BABYLON.Vector3(0, 0, -1), gameScene)).mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
    uiCamera.layerMask = 536870912;
    uiCamera.autoClear = false;
    gameScene.activeCameras.push(uiCamera);
    nameTexture = new BABYLON.DynamicTexture("", 2048, gameScene, true, 2);
    (nameSprites = new BABYLON.SpriteManager("", "", 24, {
        width: 512,
        height: 256
    }, gameScene)).fogEnabled = false;
    nameSprites.texture = nameTexture;
    window.onfocus = function () {
        lastTimeStamp = performance.now();
    };
    window.onblur = function () { };
    
    unfocused = false;

    document.onpointerlockchange = function () {
        if (me) {
            if (!unfocused) {
                if (document.pointerLockElement) hideGameMenu();
                else {
                    lastKey = null;
                    me.controlKeys = 0;
                    me.releaseTrigger();
    
                    if (escPressed) {
                        var output = new Comm.Out(1);
                        output.packInt8(Comm.Code.pause);
                        wsSend(output, "pause");
                        setRespawnTime(5);
                        timeout.set(function () {
                            me.removeFromPlay();
                        }, 3e3);
                    };
                    "none" == document.getElementById("overlay").style.display && showGameMenu()
                };
                escPressed = true;
            };
        };
    };
    
    //this was an IIF for some reason. noting in case it was important???
    chatOutEl.innerHTML = "";
    if (settings.enableChat == 1) {
        initChatIn();
        chatOutEl.style.display = "block";
        chatInEl.style.display = "block";
    };
    killEl.innerHTML = "";
    chatOutEl.value = "";
    hideMultisizeBannerAd();
    document.getElementById("gameAdContainer").style.display = "none";
    document.getElementById("killBox").style.display = "none";
    document.getElementById("deathBox").style.display = "none";
    document.getElementById("scopeBorder").style.display = "none";
    document.getElementById("help").style.display = "block";
    document.getElementById("tipContainer").style.display = "none";
    document.getElementById("goButton").className = "ssbutton green";
    document.getElementById("goButtonLabel").innerHTML = "▶ PLAY!&nbsp;";
    document.getElementById("gameClock").style.display = "none";
    document.getElementById("gameClock").style.fontSize = "2em";
    document.getElementById("gameSummary").style.visibility = "hidden";
    document.getElementById("ffaFinal").style.display = "none";
    document.getElementById("teamFinal").style.display = "none";
    setTeamButton();
    console.log("resetGameUI");
    //end IIF

    var helpEl = document.getElementById("helpControls");
    helpEl.innerHTML = "";
    var helpSlots = {
        up: null,
        down: null,
        left: null,
        right: null,
        jump: null,
        fire: null,
        scope: null,
        reload: null,
        weapon: null,
        grenade: null
    };
    for (var k in inputToControlMap) helpSlots[inputToControlMap[k]] = k;
    var count = 0;
    for (var k in helpSlots) helpEl.innerHTML += helpSlots[k], count++, helpEl.innerHTML += 4 <= count ? "<br>" : " ";
    if (gameType != GameType.teams) {
        document.getElementById("teamButtonContainer").style.display = "none";
        document.getElementById("goButton").style.height = "6.5em";
    } else {
        document.getElementById("teamButtonContainer").style.display = "block";
        document.getElementById("goButton").style.height = "4em";
    };
    document.body.style.overflow = "hidden";

    loadResources(gameScene, onLoadingComplete);
};

function loadResources(scene, onComplete) { //4th, orchestrator function for materials, sounds, meshes, map
    devlog("loadResources");
    Sounds = {};
    loadMaterials(scene);

    loadSounds(scene, function () {
        loadObjectMeshes(scene, function () {
            loadMapMeshes(scene, function () {
                onComplete();
            })
        });
    });
};

function loadMaterials(scene) { //5th, defines materials
    var mat;

    mat = new BABYLON.StandardMaterial("bullet", scene);
    mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
    if (shadowGen) {
        var definesList = ["#define RECEIVESHADOWS"];
        engineCaps.textureFloat && definesList.push("#define SHADOWFULLFLOAT")
    } else definesList = [];
    definesList.push("#define DIRT"), mat = new BABYLON.ShaderMaterial("map", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor"],
        defines: definesList
    });
    if (shadowGen) {
        mat.setTexture("shadowSampler", shadowGen.getShadowMapForRendering());
        mat.setMatrix("shadowLightMat", shadowGen.getTransformMatrix());
        mat.setVector3("shadowParams", shadowGen.getDarkness(), shadowGen.getShadowMap().getSize().width, shadowGen.bias);
    };
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor)
    };
    
    mat = new BABYLON.ShaderMaterial("mapNoShadow", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor"],
        defines: ["#define DIRT"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor)
    };

    mat = new BABYLON.ShaderMaterial("standard", scene, "standard", {
        attributes: ["position", "normal", "color", "uv", BABYLON.VertexBuffer.MatricesIndicesKind, BABYLON.VertexBuffer.MatricesWeightsKind],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "colorMult"],
        defines: ["#define COLORMULT"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        if (effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor), effect.setColor3("colorMult", mesh.colorMult || BABYLON.Color3.White()), mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            var matrices = mesh.skeleton.getTransformMatrices(mesh);
            matrices && effect && effect.setMatrices("mBones", matrices)
        }
    };

    mat = new BABYLON.ShaderMaterial("standardInstanced", scene, "standard", {
        attributes: ["position", "normal", "color", "uv", "world0", "world1", "world2", "world3"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor"],
        defines: ["#define INSTANCES"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor)
    };

    mat = new BABYLON.ShaderMaterial("eggShell", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "hp", "cameraPosition", "outlineColor", "colorMult", "stampOffset"],
        defines: ["#define EGGSHELL"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor), effect.setFloat("hp", mesh.player.hp / 100), effect.setColor3("colorMult", mesh.colorMult || BABYLON.Color3.White()), effect.setFloat3("cameraPosition", scene.activeCamera.globalPosition.x, scene.activeCamera.globalPosition.y, scene.activeCamera.globalPosition.z), effect.setColor4("outlineColor", mesh.outlineColor, mesh.outlineColor.a), effect.setFloat2("stampOffset", mesh.stampU, mesh.stampV)
    };
    
    mat = new BABYLON.ShaderMaterial("emissive", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "emissiveColor"],
        defines: ["#define FLASH"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity), effect.setColor3("vFogColor", scene.fogColor), effect.setColor3("emissiveColor", mesh.emissiveColor || BABYLON.Color3.Black())
    };

    mat = new BABYLON.StandardMaterial("wireframe", scene);
    mat.wireframe = true;

    mat = new BABYLON.StandardMaterial("normalBackface", scene);
    mat.diffuseColor = new BABYLON.Color3(.5, .5, .5);
    mat.ambientColor = new BABYLON.Color3(.5, .5, .5);
    mat.specularColor = new BABYLON.Color3(0, 0, 0);
    mat.backFaceCulling = false;
    mat.twoSidedLighting = true;

    mat = new BABYLON.StandardMaterial("muzzleFlash", scene);
    mat.emissiveColor = BABYLON.Color3.White();

    mat = new BABYLON.StandardMaterial("ui", scene);
    mat.disableLighting = true;
    mat.emissiveColor = BABYLON.Color3.White();
    mat.fogEnabled = false;
};

function loadSounds(scene, onComplete) { //6th, loads sounds (who knew?)
    var options = {
        spatialSound: true,
        distanceModel: "exponential",
        rolloffFactor: 1
    };
    var loadsComplete = 0;

    function catComplete() {
        33 == ++loadsComplete && onComplete()
    };

    Sounds.eggk47 = {
        fire: new BABYLON.Sound("", "sound/eggk47/fire.mp3", scene, catComplete, options),
        dryFire: new BABYLON.Sound("", "sound/eggk47/dry fire.mp3", scene, catComplete, options),
        cycle: new BABYLON.Sound("", "sound/eggk47/full cycle.mp3", scene, catComplete, options),
        insertMag: new BABYLON.Sound("", "sound/eggk47/insert mag.mp3", scene, catComplete, options),
        removeMag: new BABYLON.Sound("", "sound/eggk47/remove mag.mp3", scene, catComplete, options)
    };
    Sounds.dozenGauge = {
        fire: new BABYLON.Sound("", "sound/dozenGauge/fire.mp3", scene, catComplete, options),
        open: new BABYLON.Sound("", "sound/dozenGauge/open.mp3", scene, catComplete, options),
        load: new BABYLON.Sound("", "sound/dozenGauge/load.mp3", scene, catComplete, options),
        close: new BABYLON.Sound("", "sound/dozenGauge/close.mp3", scene, catComplete, options)
    };
    Sounds.csg1 = {
        fire: new BABYLON.Sound("", "sound/csg1/fire.mp3", scene, catComplete, options),
        pullAction: new BABYLON.Sound("", "sound/csg1/pull action.mp3", scene, catComplete, options),
        releaseAction: new BABYLON.Sound("", "sound/csg1/release action.mp3", scene, catComplete, options)
    };
    Sounds.cluck9mm = {
        fire: new BABYLON.Sound("", "sound/cluck9mm/fire.mp3", scene, catComplete, options),
        removeMag: new BABYLON.Sound("", "sound/cluck9mm/remove mag.mp3", scene, catComplete, options),
        insertMag: new BABYLON.Sound("", "sound/cluck9mm/insert mag.mp3", scene, catComplete, options)
    };
    Sounds.rpegg = {
        fire: new BABYLON.Sound("", "sound/rpegg/rocketfire.mp3", scene, catComplete, options),
        fly: new BABYLON.Sound("", "sound/rpegg/rocketfly.mp3", scene, catComplete, options),
        explode: new BABYLON.Sound("", "sound/rpegg/rockethit.mp3", scene, catComplete, options),
        load: new BABYLON.Sound("", "sound/rpegg/rocketload.mp3", scene, catComplete, options),
        poof: new BABYLON.Sound("", "sound/rpegg/rocketpoof.mp3", scene, catComplete, options),
        denyFire: new BABYLON.Sound("", "sound/rpegg/rocketdeny.mp3", scene, catComplete, options)
    };
    Sounds.hammerClick = new BABYLON.Sound("", "sound/hammerClick.mp3", scene, catComplete);
    Sounds.ammo = new BABYLON.Sound("", "sound/ammo.mp3", scene, catComplete);
    Sounds.shellBurst = new BABYLON.Sound("", "sound/shellBurst.mp3", scene, catComplete, options);
    Sounds.hit = new BABYLON.Sound("", "sound/hit.mp3", scene, catComplete, options);
    Sounds.endRound = new BABYLON.Sound("", "sound/rooster.mp3", scene, catComplete);
    Sounds.grenade = {
        explode: new BABYLON.Sound("", "sound/grenade.mp3", scene, catComplete, options),
        beep: new BABYLON.Sound("", "sound/grenadeBeep.mp3", scene, catComplete, options),
        pin: new BABYLON.Sound("", "sound/grenadePin.mp3", scene, catComplete, options)
    };
    Sounds.death = [];
    for (var i = 1; i < 11; i++) {
        Sounds.death.push(new BABYLON.Sound("", "sound/death/scream" + i + ".mp3", scene, catComplete, options));
    };

    Sounds.rain = new BABYLON.Sound("", "sound/ambiance/rain.mp3", scene, catComplete, { loop: true, autoplay: false, volume: 0.5 });
    Sounds.thunder = new BABYLON.Sound("", "sound/ambiance/thunder.mp3", scene, catComplete);
};

function loadObjectMeshes (scene, onComplete) { //7th, loads basically all the things in the models/ folder (name from deobf leak)
    loadMeshes(scene, [
        "egg",
        "gun_eggk47",
        "gun_csg1",
        "gun_cluck9mm",
        "gun_dozenGauge",
        "gun_rpegg",
        "munitions",
        "muzzleFlash",
        "items",
        "reticle"
    ], null, onComplete);
};

//8th is defined below from the import

function onLoadingComplete() { //9th (callback of loadResources)
    console.log("onLoadingComplete");
    Collider = new ColliderConstructor(gameScene);
    loadMap(onMapComplete);
};

function loadMap(onComplete) { //10th, (name from deobf leak)
    function complete() {
        hideSpinner();
        onComplete();
    };

    showSpinner("Building Map", "Hold on!");
    
    createMapCells(function () {
        showSpinner("Building Map", "Turning on the lights...");
        generateLightmapAndSkybox(this, complete);
    });
};

var meshIndex, meshNames, createMapCellsCallback;

function createMapCells(callback) { //11th
    minMap = playOffline ? JSON.parse(localStorage.getItem("mapBackup")) : (console.log("MAP IDX: " + mapIdx), minMaps[mapIdx]);

    devlog("minMap:", minMap);

    if (minMap.sun) {
        gameScene.sunLight.direction = new BABYLON.Vector3(minMap.sun.direction.x, minMap.sun.direction.y, minMap.sun.direction.z);
    } else {
        gameScene.sunLight.direction = new BABYLON.Vector3(.2, 1, .1);
    };

    SPS = new BABYLON.SolidParticleSystem("SPS", gameScene, {
        updatable: true
    });
    SPS.computeParticleColor = false;
    SPS.computeParticleTexture = false;
    SPS.computeParticleRotation = false;
    SPS.recomputeNormals = false;

    meshIndex = buildMapData(function (str) { alert("The following map meshes were not found:\n\n" + str + "\nTry clearing your cache and reload the page!") });
    meshNames = Object.keys(minMap.data);

    //i hate this, but. le sigh... we cringe on.
    createMapCellsCallback = callback;

    var nextFunction = addMeshToMap.bind(this, 0);
    window.requestAnimationFrame(nextFunction);
};

//12th is defined below from the import

function addMeshToMap(keyIdx) { //13th, adds all the shapes to the map and stuff
    if (keyIdx == meshNames.length) return void createMapCellsCallback();
    var meshName = meshNames[keyIdx];
    var meshData = minMap.data[meshName];
    var meshIdx = meshIndex[meshName];
    var mesh = mapMeshes[meshIdx];
    var pct = Math.floor(keyIdx / meshNames.length * 100);
    //fakes making it look like something is happening quickly, i guess
    var msgs = ["Laying", "Cracking", "Making omelettes", "Random clucking", "Scratching", "Scrambling", "Roosting", "Beating", "Making bad yolks", "Thinking of egg puns", "Whipping", "Frying", "Poaching", "Doing something REALLY interesting", "Doing your homework, 'cause SOMEONE has to", "What was I doing? Oh, yeah; map!", "Making you wait, just for clucks", "Watching chicken videos"];
    var msg = msgs[Math.randomInt(0, msgs.length)];
    showSpinner("Building Map", msg + "... " + pct + "%");
    var fields = meshName.split(".");
    mesh.theme = fields[0];
    mesh.colliderType = fields[2];
    mesh.softness = fields[3];
    if ("SPECIAL" != mesh.theme) {
        var i = 0;
        var meshArr = Object.values(meshData);

        SPS.addShape(mesh, meshArr.length, {
            positionFunction: function (particle, idx, shapeIdx) {
                var rx = meshArr[i].rx || 0,
                    ry = meshArr[i].ry || 0,
                    rz = meshArr[i].rz || 0;
                particle.position.x = meshArr[i].x + .5, particle.position.y = meshArr[i].y + .5, particle.position.z = meshArr[i].z + .5, particle.rotation.x = rx * rotInc, particle.rotation.y = ry * rotInc, particle.rotation.z = rz * rotInc, particle.alive = false, i++
            }
        });
    };

    var nextFunction = addMeshToMap.bind(this, keyIdx + 1);
    window.requestAnimationFrame(nextFunction);
};

function generateLightmapAndSkybox(This, complete) { //14th, creates the lightmap (offloaded onto a worker) and skybox
    requestAnimationFrame(function (onComplete) {
        mapMesh = SPS.buildMesh();
        mapMesh.receiveShadows = true;
        console.log("Casting rays");
        var w = map.width + 1;
        var h = map.height + 1;
        var d = map.depth + 1;
        var lightMap = make3DArray(w, h, d, 1.5);
        var lightDir = gameScene.sunLight.direction.clone();

        lightDir.normalize();
        var lightRay = lightDir.clone();
        lightRay.scaleInPlace(1e3);

        var testStep = lightDir.clone();
        testStep.scaleInPlace(.5);

        iterateXYZ(map.width + 1, map.height + 1, map.depth + 1, null, function (lmx, lmy, lmz) {
            var rays = [],
                ray = new BABYLON.Ray(new BABYLON.Vector3(lmx, lmy, lmz), lightRay);
            rays.push(ray);
            var testPos = new BABYLON.Vector3(lmx, lmy, lmz);
            testPos.addInPlace(testStep), testPos.addInPlace(testStep);
            for (var cellsChecked = {}, hits = 0; !(testPos.x < -1 || testPos.x > map.width || testPos.y < -1 || testPos.y > map.height || testPos.z < -1 || testPos.z > map.depth || hits == rays.length);) {
                var cx = Math.floor(Math.clamp(testPos.x + 0, 0, map.width - 1));
                var cy = Math.floor(Math.clamp(testPos.y + 0, 0, map.height - 1));
                var cz = Math.floor(Math.clamp(testPos.z + 0, 0, map.depth - 1));
                var checkId = cx + 1e3 * cy + 1e4 * cz;

                if (!cellsChecked[checkId]) {
                    cellsChecked[checkId] = true;
                    var cell = map.data[cx][cy][cz];
                    if (cell && cell.idx) {
                        var cellMesh = mapMeshes[cell.idx];
                        if ("SPECIAL" != cellMesh.theme) {
                            for (var ri in cellMesh.rotation.x = cell.rx, cellMesh.rotation.y = cell.ry, cellMesh.rotation.z = cell.rz, cellMesh.position.x = cx + .5, cellMesh.position.y = cy + .5, cellMesh.position.z = cz + .5, cellMesh.computeWorldMatrix(), rays) {
                                var ray = rays[ri];
                                if (!ray.hit) {
                                    var pickInfo = ray.intersectsMesh(cellMesh, true);
                                    pickInfo.hit && (ray.hit = true, hits++);
                                };
                            };
                            cellMesh.position = BABYLON.Vector3.Zero();
                        };
                    };
                };
                testPos.addInPlace(testStep);
            };
            0 < hits && (lightMap[lmx][lmy][lmz] = .2);
        });

        console.log("Applying lightmap");

        var colors = mapMesh.getVerticesData(BABYLON.VertexBuffer.ColorKind);
        var positions = mapMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);

        //to perform tricky calculations (for the lightmap) in the background, i think (idk what a worker is lmaooo)
        function worker() {
            self.onmessage = function (e) {
                e = e.data;
                for (var samples, sum, i = 0; i < e.positions.length / 3; i++) {
                    var ix3 = 3 * i,
                        x = e.positions[ix3],
                        y = e.positions[ix3 + 1],
                        z = e.positions[ix3 + 2];
                    sum = samples = 0, iterateXYZ(Math.min(e.w - 1, x + .6), Math.min(e.h - 1, y + .6), Math.min(e.d - 1, z + .6), {
                        x: Math.max(0, x - .6),
                        y: Math.max(0, y - .6),
                        z: Math.max(0, z - .6)
                    }, sumItUp);
                    var l = Math.min(Math.max(sum / samples, .5), 1);
                    e.colors[4 * i] *= l, e.colors[4 * i + 1] *= l, e.colors[4 * i + 2] *= l, i % 1e3 == 0 && postMessage({
                        progress: Math.floor(i / (e.positions.length / 3) * 100)
                    });
                };

                function sumItUp(x, y, z) {
                    var cx = Math.round(x);
                    var cy = Math.round(y);
                    var cz = Math.round(z);
                    samples++, sum += e.lightMap[cx][cy][cz]
                };

                //(this code is copied!)
                function iterateXYZ(width, height, depth, options, callback) {
                    var opt = options || {};
                    opt.step = opt.step || 1, opt.x = opt.x || 0, opt.y = opt.y || 0, opt.z = opt.z || 0;
                    for (var x = opt.x; x < width; x += opt.step)
                        for (var y = opt.y; y < height; y += opt.step)
                            for (var z = opt.z; z < depth; z += opt.step) callback(x, y, z)
                };

                postMessage({ colors: e.colors });
            };
        };

        var code = worker.toString();
        code = code.substring(code.indexOf("{") + 1, code.lastIndexOf("}"));
        var worker, blob = new Blob([code], {
            type: "application/javascript"
        });

        worker = new Worker(URL.createObjectURL(blob));
        worker.postMessage({
            colors: colors,
            positions: positions,
            lightMap: lightMap,
            w: w,
            h: h,
            d: d
        });
        worker.onmessage = function (m) {
            if (m.data.hasOwnProperty("progress")) showSpinner("Building Map", "Turning on the lights... " + m.data.progress + "%");
            else {
                mapMesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, m.data.colors);
                mapMesh.material = gameScene.getMaterialByName("map");
                mapMesh.freezeWorldMatrix();
                if (!noSkybox) {
                    var skyboxName = minMap.skybox || "default";
                    skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {
                        size: 100
                    }, gameScene);
                    setSkybox(skyboxName);
                };
                onComplete()
            };
        };
    }.bind(This, complete));
};

function setSkybox(skyboxName) {
    skybox.infiniteDistance = true;
    skyboxMaterial = new BABYLON.StandardMaterial("skyBox", gameScene);
    skyboxMaterial.backFaceCulling = false, skyboxMaterial.fogEnabled = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("img/skyboxes/" + skyboxName + "/skybox", gameScene);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE, skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0), skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0), skybox.material = skyboxMaterial
};

function onMapComplete() { //15th,  (callback of loadMap at end of onLoadingComplete)
    document.getElementById("serverAndMapInfo").innerHTML = "Map: " + minMap.name + "<br>Server: " + servers[selectedServer].name;
    try {
        var output;

        scope = new Scope;
        hitIndicator = new HitIndicator;
        reticle = new Reticle;
        gameScene.getMeshByName("muzzleFlash").material = gameScene.getMaterialByName("muzzleFlash");
        gameScene.getMeshByName("bullet").material = gameScene.getMaterialByName("bullet");
        gameScene.getMeshByName("rocket").material = gameScene.getMaterialByName("standardInstanced");
        gameScene.getMeshByName("grenade").material = gameScene.getMaterialByName("emissive");
        gameScene.getMeshByName("ammo").material = gameScene.getMaterialByName("standardInstanced");
        gameScene.getMeshByName("grenadeItem").material = gameScene.getMaterialByName("standardInstanced");
        munitionsManager = new MunitionsManagerConstructor(gameScene);
        itemManager = new ItemManagerConstructor();
        bulletHoleManager = createParticleManager("particles.png", 50, 0, 0, gameScene);
        bulletHoleManager.fogEnabled = true;
        bulletHoleManager.addHole = function (f, x, y, z) {
            var s = this.getSprite();
            s.position.x = x, s.position.y = y, s.position.z = z, s.angle = 6.282 * Math.random(), s.cellIndex = f, s.startSize = .03
        };
        (explosionSmokeManager = createParticleManager("particles.png", 300, 1, 1, gameScene)).fogEnabled = true;
        explosionSmokeManager.noAlphaTest = true;
        (explosionFireManager = createParticleManager("particles.png", 300, 1, 1, gameScene)).fogEnabled = true;
        explosionFireManager.blendMode = BABYLON.Engine.ALPHA_ADD;
        (shellFragManager = createParticleManager("particles.png", 400, 3, 6, gameScene)).fogEnabled = true;
        yolkManager = createParticleManager("particles.png", 100, 2, 2, gameScene);
        yolkManager.fogEnabled = true;
        
        if (playOffline) {
            addPlayer({
                id: meId = 0,
                uniqueId: 0,
                name: "Test",
                classIdx: 0,
                team: 0,
                primaryWeaponItem: playerAccount.getPrimaryWeapon(),
                secondaryWeaponItem: playerAccount.getSecondaryWeapon(),
                shellColor: 0,
                hatItem: null,
                stampItem: null,
                score: 0,
                kills: 0,
                deaths: 0,
                streak: 0,
                totalKills: 0,
                totalDeaths: 0,
                bestGameStreak: 0,
                bestOverallStreak: 0,
                x: mapTest.x + .5,
                y: mapTest.y - .32,
                z: mapTest.z + .5,
                dx: 0,
                dy: 0,
                dz: 0,
                frame: 0,
                pitch: mapTest.pitch,
                yaw: mapTest.yaw,
                shield: 0,
                hp: 0,
                playing: false,
                weaponIdx: 0,
                controlKeys: 0,
                randomSeed: 0,
                upgradeProductId: void 0 !== playerAccount.upgradeProductId && null !== playerAccount.upgradeProductId ? playerAccount.upgradeProductId : 0
            });

            players[meId].hp = 100;
            doFirstPersonCamera();
            startRendering();
            addCanvasListeners();
        } else {
            mapOverview = true;
            ws.onmessage = LegacyShellOnMessage;

            (output = new Comm.Out(1)).packInt8(Comm.Code.clientReady);
            wsSend(output, "clientReady");
            (output = new Comm.Out(1)).packInt8(Comm.Code.ping);
            pingStartTime = Date.now();
            wsSend(output, "ping");
        };
    } catch (e) {
        console.log(e)
    };
};

function startRendering() { //16th, starts rendering and game loop
    hideDarkOverlay();
    document.getElementById("game").style.display = "block";
    document.getElementById("readouts").style.display = "block";
    document.getElementById("homeButton").style.display = "inline-block";
    document.getElementById("friendsButton").style.display = "inline-block";
    resize();
    captureKeys();
    mapOverview && doMapOverviewCamera();

    gameScene.registerBeforeRender(mainGameLoop);
    
    engine.runRenderLoop(function () { gameScene.render() });
};

LEGACYSHELLLOADING

// [LS] ######## Ingame ---------------------------------
//  ___ _  _  ___   _   __  __ ___ 
// |_ _| \| |/ __| /_\ |  \/  | __|
//  | || .` | (_ |/ _ \| |\/| | _| 
// |___|_|\_|\___/_/ \_\_|  |_|___|
                                
function mainGameLoop () { //17th, this is the final (in a way) stage of the sequence.
    (function () {
        var fps = engine.getFps();
        if (fpsTotal += fps, ++fpsSamples % 10 == 0) {
            fpsAverage = fpsTotal / fpsSamples;
            var fpsEl = document.getElementById("FPS");
            fpsEl.innerText = Math.floor(fps + .5);
            var barEl = document.getElementById("healthBar");
            var hpEl = document.getElementById("healthHp");
            var r = 5 - viewingPlayer.hp / 20;
            if (barEl.setAttribute("stroke-dashoffset", 6.2832 * r + "vh"), hpEl.innerText = Math.floor(viewingPlayer.hp), timedGame) {
                var clockEl = document.getElementById("gameClock"),
                    date = new Date(roundEndTime - Date.now() + 1e3);
                if (0 <= date) {
                    var minutes = date.getMinutes(),
                        seconds = date.getSeconds();
                    if (seconds != oldClockSeconds) {
                        var size = 2;
                        0 == minutes && seconds < 11 && (size = 2 + (11 - seconds) / 4), clockEl.style.fontSize = size + "em", clockEl.innerText = minutes + ":" + (seconds < 10 ? "0" : "") + seconds, oldClockSeconds = seconds
                    }
                } else clockEl.innerText = "0:00"
            }
        }
        var currentTimeStamp = performance.now();
        10 < pingSamples && (highestPing = Math.max(highestPing, ping));
        for (; lastTimeStamp < currentTimeStamp; ) {
            lastTimeStamp += TickStep;
            
            if (freezeFrame) {
                me.update(1);
                me.actor.update(1);
            } else {
                for (var i = 0; i < players.length; i++) {
                    var player = players[i];
                    if (player) {
                        player.chatLineCap = Math.min(player.chatLineCap + 1 / 120, 3);
                        if (player.playing) {
                            player.update(1);
                            player.actor.handsToWeaponSkeleton();
                            if (player.actor) {
                                player.actor.update(1);
                            }
                        }
                    }
                }
            }
            
            if (me) {
                me.stateBuffer[me.stateIdx] = {
                    delta: 1,
                    yaw: me.yaw,
                    fire: false,
                    jumping: me.jumping,
                    climbing: me.climbing,
                    x: me.x,
                    y: me.y,
                    z: me.z,
                    dx: me.dx,
                    dy: me.dy,
                    dz: me.dz,
                    controlKeys: me.controlKeys
                };
                
                if (me.stateIdx % FramesBetweenSyncs === 0 && ws.readyState === ws.OPEN && me.hp > 0 && !freezeFrame) {
                    serverSync();
                };
                
                hitIndicator.update(1);
                reticle.update(1);
                
                if (me.weapon && me.weapon.ammo.rounds === 0) {
                    var ammoElement = document.getElementById("ammo");
                    if (me.stateIdx % 20 === 0) {
                        ammoElement.style.color = "#f00";
                    } else if (me.stateIdx % 20 === 10) {
                        ammoElement.style.color = "#fff";
                    }
                }
                
                if (grenadePowerUp === 1 && grenadeThrowPower < 1) {
                    grenadeThrowPower = Math.min(grenadeThrowPower + 0.015, 1);
                    document.getElementById("grenadeThrowContainer").style.visibility = "visible";
                    document.getElementById("grenadeThrow").style.height = 100 * grenadeThrowPower + "%";
                }
            }
            
            if (!freezeFrame) {
                munitionsManager.update(1);
                itemManager.update(1);
                updateParticles(explosionSmokeManager, 1);
                updateParticles(explosionFireManager, 1);
                updateParticles(shellFragManager, 1);
                updateParticles(yolkManager, 1);
            };
            
            if (mapOverview) {
                mapOverviewAxis += 0.002;
                camera.position.x = Math.sin(mapOverviewAxis) * map.height + map.width / 2;
                camera.position.z = Math.cos(mapOverviewAxis) * map.height + map.depth / 2;
                camera.setTarget(new BABYLON.Vector3(map.width / 2, map.height / 4, map.depth / 2));
            };
        };
    }());
    if (me) {
        shadowLight.position.x = viewingPlayer.x;
        shadowLight.position.y = viewingPlayer.y + 2;
        shadowLight.position.z = viewingPlayer.z;
    };
};

function getTeamScores() {
    for (var teamScore = [0, 0, 0], i = 0; i < playerLimit; i++) {
        var player = players[i];
        player && (teamScore[player.team] += player.score)
    }
    var leadingTeam = 0;
    return teamScore[1] > teamScore[2] ? leadingTeam = 1 : teamScore[2] > teamScore[1] && (leadingTeam = 2), {
        score: teamScore,
        leader: leadingTeam
    }
};

function resetGame() {
    for (var i = 0; i < playerLimit; i++) {
        var player = players[i];
        if (player) {
            player.removeFromPlay();
            player.score = 0;
            player.kills = 0;
            player.deaths = 0;
            player.streak = 0;
            player.bestGameStreak = 0;
        };
    };
};

function randomName() {
    //69 is literally illegal!!!11
    var num;
    for (; 69 == (num = Math.randomInt(1, 99));); //todo, enable 69 as an option (this is just to spite them)
    return 0 == Math.randomInt(0, 2) ? name1stHalf[Math.randomInt(0, name1stHalf.length)] + name2ndHalf[Math.randomInt(0, name2ndHalf.length)] + num : name2ndHalf[Math.randomInt(0, name2ndHalf.length)] + name1stHalf[Math.randomInt(0, name1stHalf.length)] + num
};

// [LS] Restrictions

LEGACYSHELLSTRINGWIDTH

LEGACYSHELLCENSOR

// [LS] Player Management
function addPlayer(playerData) {
    devlog("addPlayer FUNCTION", playerData.id == meId, playerData.id, meId, playerData.nickname);
    playerData.id == meId && (viewingPlayerId = playerData.id);
    var player = new Player(playerData, gameScene);
    player.id == meId && (viewingPlayer = me = player, me.ws = ws, updateAmmoUi()), player.playing || player.actor.removeFromPlay(), players[playerData.id] = player, rebuildPlayerList()
};

function removePlayer(playerId) {
    var player = players[playerId];
    if (playerId != meId) {
        if (player) {
            player.actor.remove();
            delete players[playerId];
            rebuildPlayerList();
        };
    } else {
        console.log("Tried to remove ME");
    };
};

function mutePlayer(playerId, uniqueId) {
    var player = players[playerId];
    player && player.uniqueId == uniqueId && (player.muted ? (player.muted = false, player.name = player.oldName) : (player.muted = true, player.oldName = player.name, player.name = randomName()), player.actor.setupNameSprite(), rebuildPlayerList()), closeAlertDialog()
};

// [LS] ######## UI ---------------------------------
//  _   _ ___ 
// | | | |_ _|
// | |_| || | 
//  \___/|___|

// [LS] Main Menu
function showMainMenu() {
    engine && engine.stopRenderLoop();
    document.body.style.overflow = "visible";
    window.scrollY = 0;
    viewingPlayerId = meId = 0;
    if (inGame) {
        // document.getElementById("menuAdContainer").appendChild(document.getElementById("bannerAdContainer")), document.getElementById("inGameAd").style.display = "none;";
        me && (playerAccount.kills += kills, playerAccount.deaths += deaths, playerAccount.streak = Math.max(bestOverallStreak, playerAccount.streak), updatePlayerStatsDisplay()), closeAlertDialog(), interval.clearAll(), timeout.clearAll(), fetchTwitchStreams(), pingServers(), hideGameDom();
        // var oneSignalBell = document.getElementById("onesignal-bell-container");
        //oneSignalBell && (oneSignalBell.style.display = "inline-block"), 
        //this statement is so convoluted that i have no idea how this will be affected
        if (playerAccount.isLoggedIn && !playerAccount.isUpgraded() && document.getElementById("showBuyPassDialogButton").classList.remove("hideme"), document.getElementById("upgradeIndicator").classList.remove("ingame"), ws.close(Comm.Close.mainMenu), ws = null, releaseKeys(), 0 < gameStartTime) {
            var timePlayed = Date.now() - gameStartTime;
            // if (ga("send", "timing", "game", "play time", timePlayed), me && 0 < kills) {
            //     var ratio = Math.floor(kills / Math.max(kills + deaths, 1) * 100);
            // }
        };
        gameScene.dispose(), inGame = false, customizer = new Customizer(function () {
            document.getElementById("mainMenu").style.display = "block", showSmallAd()
        }), extern.customizer = customizer;
    } else document.getElementById("mainMenu").style.display = "block"
};

function showMainMenuConfirm() {
    openAlertDialog("Main Menu", "Leave game and return<br>to the main menu?", {
        label: "Yes",
        width: "4em",
        onclick: showMainMenu
    }, {
        label: "No",
        width: "4em",
        onclick: closeAlertDialog
    })
};

// [LS] Game Menu
function openGameMenu() {
    escPressed = false;
    document.pointerLockElement ? document.exitPointerLock() : showGameMenu();
};

function showGameMenu() {
    var helpOpen = "none" != document.getElementById("help").style.display,
        menuEl = document.getElementById("gameMenu");
    helpOpen || (document.getElementById("tipContainer").style.display = "block", document.getElementById("gameplayTip").innerHTML = getRandomGameplayTip()), hideSpinner(), hideDarkOverlay(), menuEl.style.display = "block", showCornerButtons(), removeCanvasListeners(), document.getElementById("grenadeThrowContainer").style.visibility = "hidden", document.getElementById("weaponBox").style.display = "none", document.getElementById("health").style.display = "none", document.getElementById("killTicker").style.display = "none", document.getElementById("inGameAd").style.display = "block", reticle.hide(), timeout.set(function () {
        // loadBannerAd()
    }, 1e3)
};

function hideGameMenu() {
    if (me) {
        document.getElementById("gameMenu").style.display = "none";
        document.getElementById("gameSummary").style.visibility = "hidden";
        document.getElementById("ffaFinal").style.display = "none";
        document.getElementById("teamFinal").style.display = "none";
        timedGame && betweenRounds || (document.getElementById("deathBox").style.display = "none", document.getElementById("weaponBox").style.display = "block", document.getElementById("health").style.display = "block", document.getElementById("killTicker").style.display = "block", document.getElementById("playerList").style.display = "block", chatting && chatInEl.focus(), doFirstPersonCamera(), reticle.show());
        hideMultisizeBannerAd();
        document.getElementById("gameAdContainer").style.display = "none";
        document.getElementById("cornerButtons").style.display = "none";
        addCanvasListeners();
    };
};

// [LS] Other Misc
function getLocText(stringId) {
    return language[stringId][currentLanguage];
};

function reloadPage() {
    window.location.reload()
};

function openJoinBox() {
    document.getElementById("customGame").style.display = "none";
    document.getElementById("joinGame").style.display = "block";
};

function closeServerList() { //most useful function
    closeAlertDialog();
};

function setTeamButton() {
    var teamButton = document.getElementById("teamButton");
    teamButton.className = 1 == myTeam ? (teamButton.innerText = "Join RED Team", "ssbutton red") : (teamButton.innerText = "Join BLUE Team", "ssbutton blue")
};

function rebuildPlayerList() { //by player list we mean the literal html element. pretty sure this is purely just for displaying the player list (the one on the left side)
    var playerIdxs = [];
    for (var i = 0; i < players.length; i++) {
        players[i] && playerIdxs.push(i);
    };

    if (gameType == GameType.teams) {
        var teams = getTeamScores();
        0 < teams.leader && (lastLeadingTeam = teams.leader), teams.score[lastLeadingTeam] += 1e5, playerIdxs.sort(function (a, b) {
            return players[b].score + teams.score[players[b].team] - (players[a].score + teams.score[players[a].team])
        })
    } else {
        playerIdxs.sort(function (a, b) {
            return players[b].score - players[a].score;
        });
    };

    var list = document.getElementById("playerList").children;
    for (i = 0; i < playerIdxs.length; i++) {
        var player = players[playerIdxs[i]];
        list[i].style.display = "block";

        //player name in the list
        list[i].children[0].innerText = player.name;

        list[i].addEventListener("click", function (playerId, uniqueId, username) {
            return function () {
                openAlertDialog(players[playerId].name, "", {
                    label: "Close",
                    onclick: closeAlertDialog
                });
                var b, container = document.createElement("div");
                container.style.textAlign = "center";

                //username element
                var usernameElement = document.createElement('div');
                usernameElement.innerHTML = `@${username || "Unknown"}<br>`;
                usernameElement.style.color = '#444';
                usernameElement.style.fontWeight = 'bold';
                container.appendChild(usernameElement);

                document.getElementById("alertMessage").appendChild(container);

                if (playerId != meId) {
                    //the text that says Select an action for this player:
                    container.innerHTML += `<br>${getLocText("ui_game_playeractions_header")}<br>`;
    
                    //mute button
                    b = document.createElement("button");
                    b.style.display = "inline-block";
                    if (players[playerId].muted) {
                        b.className = "ssbutton blue";
                        b.innerHTML = getLocText("ui_game_playeractions_unmute");
                    } else {
                        b.className = "ssbutton orange";
                        b.innerHTML = getLocText("ui_game_playeractions_mute");
                    };
                    b.style.width = "10em";
                    b.style.height = "2.5em";
                    b.style.margin = "0.5em";
                    b.onclick = function (playerId, uniqueId) {
                        return function () {
                            mutePlayer(playerId, uniqueId)
                        };
                    }(playerId, uniqueId);
                    container.appendChild(b);

                    if (isGameOwner) {
                        (b = document.createElement("button")).className = "ssbutton red";
                        b.style.display = "inline-block";
                        b.innerHTML = getLocText("ui_game_playeractions_boot");
                        b.style.width = "10em";
                        b.style.height = "2.5em";
                        b.style.margin = "0.5em";
                        b.onclick = function (playerId, uniqueId) {
                            return function () {
                                bootPlayer(playerId, uniqueId)
                            }
                        }(playerId, uniqueId);
                        container.appendChild(b);
                    };
                }
            };
        }(player.id, player.uniqueId, player.username), false);
        list[i].style.pointerEvents = "all";
        list[i].style.cursor = "pointer";
        player.upgradeProductId && player.upgradeProductId, list[i].children[1].innerText = player.score, player.id == meId ? (list[i].className = "thisPlayer", list[i].style.background = teamColors.meBackground[player.team]) : (list[i].className = "otherPlayer", list[i].style.background = teamColors.themBackground[player.team], list[i].style.color = teamColors.text[player.team]), player.upgradeProductId && 0 < player.upgradeProductId ? list[i].children[0].classList.add("upgradedPlayer") : list[i].children[0].classList.remove("upgradedPlayer")
    }
    for (; i < playerLimit;) list[i].style.display = "none", i++
};

function updateAmmoUi() {
    if (me) {
        var el = document.getElementById("weaponName");
        el.innerHTML = me.weapon.subClass.weaponName, (el = document.getElementById("ammo")).style.color = "#fff", el.innerHTML = me.weapon.ammo.rounds + "/" + Math.min(me.weapon.ammo.store, me.weapon.ammo.storeMax);
        for (var i = 1; i <= 3; i++) me.grenadeCount >= i ? document.getElementById("grenade" + i).src = "img/grenadeIcon.png?v=1" : document.getElementById("grenade" + i).src = "img/grenadeIconDark.png?v=1"
    };
};

function addKillText(byPlayer, killedPlayer) {
    var msgs = [" SCRAMBLED ", " BEAT ", " POACHED ", " WHIPPED ", " FRIED ", " CRACKED "],
        str = '<span style="color: ' + teamColors.text[byPlayer.team] + '">' + byPlayer.name + "</span>" + msgs[Math.randomInt(0, msgs.length)] + '<span style="color: ' + teamColors.text[killedPlayer.team] + '">' + killedPlayer.name + "</span>";
    4 < (killEl.innerHTML.match(/<br>/g) || []).length && (killEl.innerHTML = killEl.innerHTML.substr(killEl.innerHTML.search("<br>") + 4)), killEl.innerHTML += str + "<br>"
};

function updatePlayerStatsDisplay() {
    var ratio = Math.floor(playerAccount.kills / Math.max(playerAccount.deaths, 1) * 100) / 100;
    document.getElementById("playerStatValues").innerHTML = playerAccount.kills.toLocaleString() + "<br>" + playerAccount.deaths.toLocaleString() + "<br>" + ratio + "<br>" + playerAccount.streak.toLocaleString()
};

function updateCurrentBalance() {
    document.getElementById("currentBalanceContainer").style.display = "inline-block", document.getElementById("currentBalance").innerText = playerAccount.currentBalance
};

function setRespawnTime(sec) {
    respawnTime = Math.max(sec, respawnTime);
    var button = document.getElementById("goButton");
    button.className = "ssbutton grey";
    var label = document.getElementById("goButtonLabel");
    label.innerHTML = respawnTime;
    respawnInterval && interval.clear(respawnInterval);
    respawnInterval = interval.set(function () {
        label.innerHTML = respawnTime;
        if (respawnTime <= 0 && inGame) {
            respawnTime = -1;
            button.className = "ssbutton green";
            label.innerHTML = "▶ PLAY!&nbsp;";
            doMapOverviewCamera();
            interval.clear(respawnInterval);
        } else {
            respawnTime--;
        };
    }, 1000);
};

function showCornerButtons() {
    document.getElementById("cornerButtons").style.display = "block"
};

function hideGameDom() {
    document.getElementById("game").style.display = "none", document.getElementById("readouts").style.display = "none", document.getElementById("homeButton").style.display = "none", document.getElementById("friendsButton").style.display = "none"
};

function closeFeedback() {
    inGame && captureKeys(), document.getElementById("feedback").style.display = "none", document.body.appendChild(document.getElementById("feedback")), closeAlertDialog()
};

function onResourcesLoaded() {
    document.getElementById("mainMenu").style.display = "block";
    document.getElementById("nickname").disabled = false;
    showCornerButtons();
    resize();
    hideSpinner();
    customizer.startRendering();
    (consent = localStorage.getItem("consent")) && (consent = JSON.parse(consent));
    isFromEU && !consent && notify(document.getElementById("consent").innerHTML) //, aiptag.consented = consent && consent.ofAge && consent.targetedAds || !isFromEU, console.log("AIP consent: " + aiptag.consented)
};

// [LS] Resizing
function resize() {
    if (canvas) {
        canvas.style.width = "100%", canvas.style.height = "100%", canvas.className = "";
    };
    if (engine) engine.resize();
    if (inGame) {
        hitIndicator && hitIndicator.resize();
        reticle && reticle.resize();
    };

    // var scale = Math.min(1, window.innerHeight / 725);
    // var scaleStr = "scale(" + scale + ")";
    // var widthStr = 300 * scale + "px";
    // var heightStr = 250 * scale + "px";
    // document.getElementById("shellshock-io_300x250").style.transform = scaleStr;
    // for (var el = document.getElementById("bannerAdContainer"), i = 0; i < el.children.length; i++) {
    //     var chEl = el.children[i];
    //     chEl.style.width = widthStr, chEl.style.height = heightStr
    // }
};
window.onresize = function () { resize() };

// [LS] Menu in, out, idk, lmao

function menuIn(domName, callback) {
    document.getElementById(domName).style.display = "block", callback && callback()
};

function menuOut(domName) {
    document.getElementById(domName).style.display = "none"
};

function menuFlexIn(domName) {
    document.getElementById(domName).style.display = "flex"
};

// [LS] Stuff Related To Nuggets

function openBuyPassDialog() {
    if (playerAccount.isLoggedIn) {
        showDarkOverlay();
        document.getElementById("buyPassDialog").classList.toggle("hideme");
        document.exitPointerLock();
        window.onkeydown = null;
        window.onkeyup = null;
    };
};

function closeBuyPassDialog() {
    document.getElementById("buyPassDialog").classList.toggle("hideme"), hideDarkOverlay()
};

function tryShowNugget() {
    return null !== showNugget && !playerAccount.isUpgraded() && (playerAccount.isLoggedIn ? (document.getElementById("bigAd").style.display = "none", openBuyPassDialog(), void (showNugget = null)) : (promoteLogin(), false))
};

function showBoughtNuggetPopup() {
    setApplixirPopup(false), document.getElementById("gotNuggetPopup").classList.toggle("hideme");
};

function setupUpgradeUI() {
    var buyPassDialog = document.getElementById("showBuyPassDialogButton"),
        upgradeIndicator = document.getElementById("upgradeIndicator");
    playerAccount.isLoggedIn ? playerAccount.isUpgraded() ? (buyPassDialog.classList.add("hideme"), upgradeIndicator.style.display = "block", customizer.setExtraColorState(true)) : (inGame ? upgradeIndicator.classList.remove("ingame") : buyPassDialog.classList.remove("hideme"), upgradeIndicator.style.display = "none", customizer.setExtraColorState(false)) : (buyPassDialog.classList.add("hideme"), upgradeIndicator.style.display = "none", customizer.setExtraColorState(false)), adBlock && document.getElementById("buyNugget").remove()
};

function promoteLogin() {
    var str = 'Login to enable this feature and others, including:<ul style="text-align: left"><li>Stat tracking - kills, deaths, etc.<li>Custom shell colors<li>Hats and accessories<li>Weapon skins</ul>';
    inGame ? openAlertDialog("Feature Unavailable to Guests", str, {
        label: "OK",
        width: "6em",
        onclick: closeAlertDialog
    }) : openAlertDialog("Feature Unavailable to Guests", str, {
        label: "Login",
        width: "6em",
        onclick: openLoginDialog
    }, {
        label: "Close",
        width: "6em",
        onclick: closeAlertDialog
    })
};

// [LS] Alert Dialog (i hate the alert dialog)

function openAlertDialog(header, text, button1, button2, bar) {
    hideSpinner(), showDarkOverlay(), document.getElementById("alert").style.display = "block", document.getElementById("alertHeader").innerHTML = header, document.getElementById("alertMessage").innerHTML = text;
    var e = document.getElementById("alertButton1");
    (button1 ? (e.style.display = "inline-block", e.style.visibility = "visible", e.innerHTML = button1.label || "OK", e.style.width = button1.width || "8em", e.style.height = button1.height || "", e.onclick = button1.onclick || closeAlertDialog) : e.style.display = "none", e = document.getElementById("alertButton2"), button2 ? (e.style.display = "inline-block", e.style.visibility = "visible", e.innerHTML = button2.label || "Cancel", e.style.width = button2.width || "8em", e.style.height = button2.height || "", e.onclick = button2.onclick || closeAlertDialog) : e.style.display = "none", bar) ? function () {
        var el = document.getElementById("alertFooter");
        el.style.display = "block", alertBarInterval = interval.set(function () {
            el.innerText += "-", 10 < el.innerText.length && (el.innerText = "-")
        }, 200)
    }() : (document.getElementById("alertFooter").style.display = "none", interval.clear(alertBarInterval));
    document.exitPointerLock(), window.onkeydown = null, window.onkeyup = null
};

function closeAlertDialog() {
    document.getElementById("alert").style.display = "none", document.getElementById("alertFooter").style.display = "none", document.getElementById("nickname").disabled = false, hideDarkOverlay(), clearInterval(alertBarInterval)
};

// [LS] Spinner (i love the spinner)

function showSpinner(header, footer) {
    document.getElementById("spinner").style.display = "block";
    document.getElementById("spinnerHeader").innerText = header;
    document.getElementById("spinnerFooter").innerText = footer;
};

function hideSpinner() {
    document.getElementById("spinner").style.display = "none";
};

// [LS] Dark Overlay (i think it's just okay)

function showDarkOverlay() {
    closeAlertDialog(), document.getElementById("overlay").style.display = "block", hideBannerAd(), hideMultisizeBannerAd(), document.getElementById("showBuyPassDialogButton").classList.add("hideme")
};

function hideDarkOverlay() {
    document.getElementById("overlay").style.display = "none", showBannerAd(), inGame || !playerAccount.isLoggedIn || playerAccount.isUpgraded() || document.getElementById("showBuyPassDialogButton").classList.remove("hideme")
};

// [LS] Invite Codes

function inviteFriends() {
    gameCode = selectedServer.toString(36) + gameId.toString(36) + gameKey.toString(36);
    var url = parsedUrl.root + "#" + gameCode;
    openAlertDialog("Don't Go Alone!", "<p>Share this link with your friends so they can join you!</p><h3>" + (document.getElementById("friendCode").innerText = url) + "</h3><p></p>", {
        label: "Copy to clipboard",
        width: "12em",
        onclick: copyFriendCode
    }, {
        label: "Close",
        onclick: closeAlertDialog
    })
};

function copyFriendCode() {
    document.getElementById("friendCode").select();
    try {
        document.execCommand("copy")
    } catch (err) {
        console.log("Unable to copy to clipboard")
    }
    closeAlertDialog()
};

// [LS] Settings menu

function openSettingsMenu() {
    inGame && 1 == settings.enableChat && initChatIn(), hideBannerAd(), hideMultisizeBannerAd(), menuIn("settingsMenu")
};

function closeSettingsMenu() {
    menuOut("settingsMenu")
};

// [LS] Notifications

function notify(msg, timeout) {
    var e = document.getElementById("notification");
    e.style.opacity = 0, e.style.top = "-3.5em", e.style.display = "flex", document.getElementById("notificationMessage").innerHTML = msg;
    var anim = 0,
        animIn = setInterval(function () {
            anim++, e.style.opacity = anim / 8, e.style.top = anim / 2 - 3.5 + "em", 8 == anim && (clearInterval(animIn), timeout && setTimeout(function () {
                dismissNotification()
            }, timeout))
        }, 32)
};

function dismissNotification(callback) {
    var anim = 8,
        e = document.getElementById("notification"),
        animIn = setInterval(function () {
            e.style.opacity = anim / 8, e.style.top = anim / 2 - 3.5 + "em", 0 == --anim && (clearInterval(animIn), e.style.display = "none", callback && callback())
        }, 32)
};

// [LS] Chat UI
function initChatIn() {
    canvas.focus(), chatInEl.style.display = "block", chatInEl.value = "Press ENTER to chat", chatInEl.style.background = "transparent", chatInEl.blur(), chatting = false
};

function addChat(str, fromPlayer) {
    fromPlayer && (str = '<span style="color: ' + teamColors.text[fromPlayer.team] + '">' + fromPlayer.name + ": </span>" + str), 5 < (chatOutEl.innerHTML.match(/<br>/g) || []).length && (chatOutEl.innerHTML = chatOutEl.innerHTML.substr(chatOutEl.innerHTML.search("<br>") + 4)), str = '<div class="shadedPane" style="margin-top: 0.2em">' + str + "</div><br>", chatOutEl.innerHTML += str
};

// [LS] Summary
function showContinueDialog() {
    hideGameMenu();
    document.getElementById("gameClock").style.display = "none";
    openAlertDialog("OVER-EASY", "Continue to the next round?", {
        label: "<h3>▶ YES!&nbsp;</h3>",
        width: "8em",
        height: "2.5em",
        onclick: continueToSummary
    }, {
        label: "<h3>No</h3>",
        width: "4em",
        height: "2.5em",
        onclick: showMainMenuConfirm
    })
};
function continueToSummary() {
    closeAlertDialog();
    openGameMenu();
    showGameSummary();
    resetGame();
};
function showGameSummary() {
    document.getElementById("gameSummary").style.visibility = "visible";
    document.getElementById("playerList").style.display = "none";
};
function prepareGameSummary() {
    for (var playerIdxs = [ [], [], [] ], i = 0; i < playerLimit; i++) {
        players[i] && playerIdxs[players[i].team].push(i);
    };

    for (var team = 0; team < 3; team++) {
        teamSummaryEls[team].style.display = "none", playerIdxs[team].sort(function (a, b) {
            var diff = players[b].score - players[a].score;
            return 0 == diff && 0 == (diff = players[a].kills - players[b].kills) && (diff = players[a].deaths - players[b].deaths), diff
        });
        var rowsEl = teamSummaryEls[team];
        for (i = 0; i < playerIdxs[team].length; i++) {
            var player = players[playerIdxs[team][i]];
            if (player) {
                var row = rowsEl.children[i];
                row.style.display = "flex";
                if (player.id == meId) {
                    row.style.color = "#ff0"
                } else {
                    row.style.color = teamColors.text[team]
                };
                row.children[0].innerText = i + 1;
                row.children[1].innerText = player.name;
                row.children[2].innerText = player.score;
                row.children[3].innerText = player.kills;
                row.children[4].innerText = player.deaths;
                row.children[5].innerText = player.bestGameStreak;
            };
        };
        for (; i < rowsEl.children.length;) rowsEl.children[i].style.display = "none", i++
    };
    var teamScores = getTeamScores();
    if (gameType == GameType.teams) {
        var losingTeam = 1 == (teamScores.leader || lastLeadingTeam) ? 2 : 1;
        teamSummaryEls[losingTeam].parentNode.appendChild(teamSummaryEls[losingTeam]);
        for (team = 1; team < 3; team++) teamSummaryEls[team].style.display = "flex", document.getElementById("teamScore" + team).innerText = teamScores.score[team];
        document.getElementById("teamFinal").style.display = "flex", document.getElementById("ffaFinal").style.display = "none"
    } else {
        teamSummaryEls[0].style.display = "flex";
        document.getElementById("teamScore0").innerText = teamScores.score[0];
        document.getElementById("teamFinal").style.display = "none";
        document.getElementById("ffaFinal").style.display = "flex";
    }
};

// [LS] ######## Rendering ---------------------------------
//  ___ ___ _  _ ___  ___ ___ ___ _  _  ___ 
// | _ \ __| \| |   \| __| _ \_ _| \| |/ __|
// |   / _|| .` | |) | _||   /| || .` | (_ |
// |_|_\___|_|\_|___/|___|_|_\___|_|\_|\___|

function doMapOverviewCamera() {
    devlog("doMapOverviewCamera");
    camera.parent = null;
    camera.position = new BABYLON.Vector3(0, map.height + 1, 0);
    camera.lockedTarget = null;
    camera.setTarget(new BABYLON.Vector3(map.width / 2, map.height / 4, map.depth / 2));
    mapOverview = true;
};

function doFirstPersonCamera(player) {
    devlog("doFirstPersonCamera", player);
    camera.position = BABYLON.Vector3.Zero();
    camera.rotation = BABYLON.Vector3.Zero();
    camera.rotationQuaternion = BABYLON.Quaternion.Zero();
    camera.parent = player ? player.actor.eye : me.actor.eye, camera.lockedTarget = null, mapOverview = false;
};

function isMeshVisible(mesh, offset) {
    if (freezeFrame) return true;
    for (var oy = offset || mesh.getBoundingInfo().boundingBox.center.z, dx = mesh.position.x - camera.globalPosition.x, dy = mesh.position.y + oy - camera.globalPosition.y, dz = mesh.position.z - camera.globalPosition.z, distance = Math.length3(dx, dy, dz), dv = Math.normalize3({
        x: dx,
        y: dy,
        z: dz
    }, .9), x = camera.globalPosition.x, y = camera.globalPosition.y, z = camera.globalPosition.z, collisions = 0, i = 0; i < distance - .9 && (x += dv.x, y += dv.y, z += dv.z, !(x < 0 || x >= map.width || z < 0 || z >= map.depth || y < 0 || y >= map.height)); i += .9) {
        var cell = map.data[Math.floor(x)][Math.floor(y)][Math.floor(z)];
        if (cell.idx) {
            var m = mapMeshes[cell.idx];
            if ("full" == m.colliderType && !m.softness && 2 == ++collisions) return false
        };
    };
    return true;
};

function enableAutoDetail() {
    var opt = new BABYLON.SceneOptimizerOptions(40, 4e3);
    var shadowOpt = new BABYLON.SceneOptimization(0);
    shadowOpt.apply = disableShadows, opt.optimizations.push(shadowOpt);
    var scalingOpt = new BABYLON.SceneOptimization(1);
    scalingOpt.apply = lowerResolution, opt.optimizations.push(scalingOpt), inGame && (optimizer = BABYLON.SceneOptimizer.OptimizeAsync(gameScene, opt))
};

function disableShadows() {
    return gameScene.shadowsEnabled = false, mapMesh && inGame && (mapMesh.material = gameScene.getMaterialByName("mapNoShadow")), true
};

function enableShadows() {
    gameScene.shadowsEnabled = true;
    mapMesh && inGame && (mapMesh.material = gameScene.getMaterialByName("map"))
};

function lowerResolution() {
    return engine.setHardwareScalingLevel(2), adaptToNewResolution(), true
};

function increaseResolution() {
    engine.setHardwareScalingLevel(1);
    adaptToNewResolution();
};

function adaptToNewResolution() {
    reticle && reticle.resize(), hitIndicator && hitIndicator.resize(), scope && scope.crosshairs.isEnabled() && scope.show()
};

function onFullscreenChange() {
    engine.resize();
};

document.onfullscreenchange = onFullscreenChange;
document.onmsfullscreenchange = onFullscreenChange;
document.onmozfullscreenchange = onFullscreenChange;
document.onwebkitfullscreenchange = onFullscreenChange;

// [LS] ######## Requests ---------------------------------
//  ___ ___ ___  _   _ ___ ___ _____ ___ 
// | _ \ __/ _ \| | | | __/ __|_   _/ __|
// |   / _| (_) | |_| | _|\__ \ | | \__ \
// |_|_\___\__\_\\___/|___|___/ |_| |___/

function wsSend (output, CommCode, passedWs) {
    passedWs = passedWs || ws;
    if (passedWs && passedWs.send) {
        // if (Comm.Code[CommCode] !== Comm.Code.sync)
        devlog("WS SEND:", `${CommCode}:`, Comm.Code[CommCode], output);
        passedWs.send(output.buffer);
    };
};

function callApi(apiRequest, successCallback, errorCallback, closeCallback) {
    console.log(apiRequest.cmd + " called");
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify(apiRequest)), console.log("servicesWs opened, and " + apiRequest.cmd + " request sent")
    }, servicesWs.onmessage = function (e) {
        var response = null;
        try {
            response = JSON.parse(e.data)
        } catch (e) {
            return console.log("Invalid data returned from services API"), void errorCallback()
        }
        response.error ? (console.log(apiRequest.cmd + " error: " + JSON.stringify(response.error)), errorCallback(response)) : successCallback(response), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log(apiRequest.cmd + " servicesWs closed: " + e.code + " " + e.reason), closeCallback && closeCallback()
    }, servicesWs.onerror = function (e) {
        errorCallback()
    }
};

function getRequest(url, callback) {
    var req = new XMLHttpRequest;
    return !!req && ("function" != typeof callback && (callback = function () { }), req.onreadystatechange = function () {
        if (4 == req.readyState) return 200 === req.status ? callback(null, req.responseText) : callback(req.status, null)
    }, req.open("GET", url, true), req.send(null), req)
};

function sendFeedback() {
    for (var emailEl = document.getElementById("feedbackEmail"), descriptionEl = document.getElementById("feedbackComments"), glInfo = engine.getGlInfo(), caps = engine.getCaps(), pickedWeaponIds = [], c = 0; c < CharClass.length; c++) pickedWeaponIds.push([playerAccount.pickedWeapons[c][0].id, playerAccount.pickedWeapons[c][1].id]);
    var debugJSON = "";
    debugObject.uuid = uuid;
    try {
        debugJSON = JSON.stringify({
            debugObject: debugObject,
            debugArray: debugArray
        })
    } catch (e) {
        console.log(e)
    } ! function (command, data, success, fail) {
        try {
            var serviceWs = new WebSocket(servicesServer)
        } catch (e) {
            console.log(e), fail && fail(e)
        }
        serviceWs.onopen = function (e) {
            data.cmd = command, serviceWs.send(JSON.stringify(data)), console.log("services opened, and " + command + " request sent")
        }, serviceWs.onmessage = function (e) {
            var response = JSON.parse(e.data);
            response.error ? (console.log(command + " error: " + JSON.stringify(response.error)), fail && fail(response.error)) : (console.log(command + " success"), success && success(response)), serviceWs.close()
        }, serviceWs.onclose = function (e) {
            console.log(command + " service closed: " + e.code + " " + e.reason), success && success(e)
        }, serviceWs.onerror = function (e) {
            console.log(command + " error: " + JSON.stringify(e, ["message", "arguments", "type", "name"])), fail && fail(e)
        }
    }("feedback", {
        feedbackType: document.getElementById("feedbackTypeSelect").selectedIndex,
        gameVersion: version,
        userAgent: window.navigator.userAgent,
        nickname: nickname,
        comments: descriptionEl.value,
        email: emailEl.value,
        // firebaseId: playerAccount.firebaseId || null,
        fromEU: isFromEU,
        gameServer: servers[selectedServer].name || null,
        session: playerAccount.session || null,
        ping: 0 < pingSamples ? Math.floor(pingTotal / pingSamples) : null,
        highestPing: highestPing || null,
        fps: 0 < fpsSamples ? Math.ceil(fpsTotal / fpsSamples) : null,
        gameType: gameType || null,
        privateGame: privateGame || null,
        localKills: kills || 0,
        localDeaths: deaths || 0,
        localStreak: bestOverallStreak || 0,
        url: parsedUrl.root,
        referrer: document.referrer,
        gameCode: gameCode || null,
        screenSize: screen.width + "x" + screen.height,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        innerSize: window.innerWidth + "x" + window.innerHeight,
        glVendor: glInfo.vendor,
        renderer: glInfo.renderer,
        glVersion: glInfo.version,
        maxTextureSize: caps.maxTextureSize,
        fov: camera ? camera.fov : null, //why tf it sends this? hack detection?
        controls: localStorage.getItem("controlConfig"),
        ofAge: consent ? consent.ofAge : null,
        targetedAds: consent ? consent.targetedAds : null,
        volume: settings.volume,
        mouseSensitivity: settings.mouseSensitivity,
        mouseInvert: settings.mouseInvert,
        holdToAim: settings.holdToAim,
        enableChat: settings.enableChat,
        autoDetail: settings.autoDetail,
        shadowsEnabled: settings.shadowsEnabled,
        highRes: settings.highRes,
        selectedClass: playerAccount.classIdx,
        selectedColor: playerAccount.colorIdx,
        hat: !playerAccount.hatItem ? null : playerAccount.hatItem.id,
        stamp: !playerAccount.stampItem ? null : playerAccount.stampItem.id,
        weapons: "[[0,0],[0,0],[0,0]]",
        timesPlayed: null,
        // xsollaToken: globalXsollaToken, //money!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        current_balance: playerAccount.currentBalance,
        // log: console.logArray(), // note from ls devs: this requires bwd's modified console function which is bad!
        debug: debugJSON
    }, function (res) {
        console.log(res), setTimeout(function () {
            notify("Your feedback has been received.<br>Thank you!", 3e3)
            // notify("we also just stole all ur fucking information because we whores!")
        }, 1e3);
    }, function (err) {
        console.log(err)
    });
    closeFeedback();
    emailEl.value = "";
    descriptionEl.value = "";
};

function requestRespawn() {
    canvas.requestPointerLock();
    var output = new Comm.Out(1);
    output.packInt8(Comm.Code.requestRespawn);
    wsSend(output, "requestRespawn");
    console.log("respawn() requests respawn from server");
    document.getElementById("help").style.display = "none";
};

function checkBalance() {
    console.log("checkBalance called");
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify({
            cmd: "checkBalance",
            session: playerAccount.session
        })), console.log("servicesWs opened, and checkBalance request sent")
    }, servicesWs.onmessage = function (e) {
        checkBalanceData = JSON.parse(e.data), checkBalanceData.error ? console.log("checkBalance Error: " + JSON.stringify(checkBalanceData.error)) : playerAccount.currentBalance != checkBalanceData.current_balance && (playerAccount.currentBalance = checkBalanceData.current_balance, updateCurrentBalance()), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log("servicesWs closed: " + e.code + " " + e.reason)
    }, servicesWs.onerror = function (e) {
        statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
    }
};

function checkUpgrade() {
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    var beforeStatus = playerAccount.isUpgraded();
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify({
            cmd: "getUpgrade",
            session: playerAccount.session
        })), console.log("servicesWs opened, and getUpgrade request sent")
    }, servicesWs.onmessage = function (e) {
        getUpgradeData = JSON.parse(e.data);
        devlog(getUpgradeData);
        getUpgradeData.error ? console.log("getUpgrade Error: " + JSON.stringify(getUpgradeData.error)) : (playerAccount.setUpgrade(getUpgradeData), setupUpgradeUI(), playerAccount.isUpgraded() && false === beforeStatus && loadBannerAd()), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log("servicesWs closed: " + e.code + " " + e.reason)
    }, servicesWs.onerror = function (e) {
        statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
    }
};

function serverSync() {
    if (me) {
        var output = new Comm.Out(3 + 5 * FramesBetweenSyncs);
        output.packInt8U(Comm.Code.sync);
        output.packInt8U(me.stateIdx);
        output.packInt8U(me.shotsQueued);
        var startIdx = Math.mod(me.stateIdx - FramesBetweenSyncs, stateBufferSize)
        for (startIdx, i = 0; i < FramesBetweenSyncs; i++) {
            var idx = Math.mod(startIdx + i, stateBufferSize);
            output.packInt8U(me.stateBuffer[idx].controlKeys);
            output.packRadU(me.stateBuffer[idx].yaw);
            output.packRad(me.stateBuffer[idx].pitch);
        };
        wsSend(output, "sync");
        me.shotsQueued = 0
    }
};

function switchTeam() {
    closeAlertDialog();
    var output = new Comm.Out(1);
    output.packInt8U(Comm.Code.switchTeam);
    wsSend(output, "switchTeam");
};

function bootPlayer(playerId, uniqueId) {
    if (isGameOwner && players[playerId] && players[playerId].uniqueId == uniqueId) {
        var output = new Comm.Out(4);
        output.packInt8U(Comm.Code.bootPlayer);
        output.packInt8U(playerId);
        output.packInt16(players[playerId].uniqueId);
        wsSend(output, "bootPlayer");
    }
    closeAlertDialog()
};

function pingServers(autoSelect, callback) {
    var serverSelected = false,
        serversPinged = 0;
    var protocol = "ws://";
    "https:" === location.protocol && (protocol = "wss://");
    console.log("Pinging servers", protocol);
    for (var i = 0; i < servers.length; i++) servers[i].ping = 0,
        function (serverIdx) {
            var startTime, server = servers[serverIdx],
                pinger = new WebSocket(protocol + server.address);
            console.log("Connecting to " + server.name), pinger.binaryType = "arraybuffer";
            var timeout = setTimeout(function () {
                console.log(server.name + " timed out"), server.ping = 1e3, pinged(), pinger.close()
            }, 1e3);
            pinger.onopen = function (e) {
                console.log("Pinging " + server.name);
                var output = new Comm.Out(1);
                output.packInt8(Comm.Code.ping);
                wsSend(output, "ping", pinger);
                startTime = Date.now();
            }, pinger.onmessage = function (e) {
                clearTimeout(timeout);
                var pingTime = Date.now() - startTime;
                server.ping = pingTime, pinger.close(), autoSelect && !serverSelected && (serverSelected = true, selectServer(serverIdx)), pinged(), console.log(server.name + ": " + pingTime)
            }, pinger.onerror = function (e) {
                clearTimeout(timeout), server.ping = 1e3, pinged()
            }
        }(i);

    function pinged() {
        ++serversPinged == servers.length && callback && callback()
    }
};

// function buyChickenNuggetProduct() {
//     isGettingNugget = false;
//     callApi({
//         cmd: "buyProduct",
//         token: servicesToken,
//         sku: "chicken_nugget_pass"
//     }, showBoughtNuggetPopup, function (response) {
//         openAlertDialog("Uh Oh!", "Something broke. Try reloading the game.", null, {
//             label: "OK",
//             width: "4em",
//             onclick: closeAlertDialog
//         })
//     }), servicesToken = null
// };

function fetchTwitchStreams() {
    var streamsEl = document.getElementById("twitchStreams");
    streamsEl.innerHTML = "", console.log(url);
    var url = parsedUrl.root;
    getRequest(url + "twitchStreams.json?" + Date.now(), function (err, res) {
        if (!err) {
            var twitchStreams = JSON.parse(res),
                keys = Object.keys(twitchStreams);
            keys.sort(function (a, b) {
                return twitchStreams[b].viewers - twitchStreams[a].viewers
            }), keys.forEach(function (k) {
                var stream = twitchStreams[k],
                    container = document.createElement("div");
                container.className = "twitchRow clickable", container.onclick = function (name) {
                    return function () {
                        window.open("https://twitch.tv/" + name, "_blank")
                    }
                }(stream.name);
                var avatar = document.createElement("img");
                avatar.className = "twitchAvatar", avatar.src = "img/twitchAvatars/" + stream.avatar;
                var name = document.createElement("div");
                name.className = "twitchName", name.innerText = stream.name;
                var viewers = document.createElement("div");
                viewers.className = "twitchViewers", viewers.innerText = stream.viewers + " viewer", 1 < stream.viewers && (viewers.innerText += "s"), container.appendChild(avatar), container.appendChild(name), container.appendChild(viewers), streamsEl.appendChild(container)
            })
        }
    })
};

// [LS] ######## Particles ---------------------------------
//  ___  _   ___ _____ ___ ___ _    ___ ___ 
// | _ \/_\ | _ \_   _|_ _/ __| |  | __/ __|
// |  _/ _ \|   / | |  | | (__| |__| _|\__ \
// |_|/_/ \_\_|_\ |_| |___\___|____|___|___/

function createParticleManager(filename, number, firstFrame, lastFrame, scene) {
    for (var manager = new BABYLON.SpriteManager("", "img/" + filename + "?" + version, number, 128, scene), i = 0; i < number; i++) {
        new BABYLON.Sprite("", manager).isVisible = false
    }
    return manager.nextIdx = 0, manager.getSprite = function () {
        var s = this.sprites[this.nextIdx];
        return s.cellIndex = Math.randomInt(firstFrame, lastFrame), s.isVisible = true, s.easing = Ease.linear, s.startSize = -1, s.endSize = -1, s.gravity = 0, s.dx = 0, s.dy = 0, s.dz = 0, s.float = 0, s.anim = 0, s.slow = 0, s.angle = 0, s.rotate = 0, s.stopped = false, s.animColors = null, s.collide = false, s.color.copyFrom(color4White), this.nextIdx = ++this.nextIdx % this.sprites.length, s
    }, manager
};

function addExplosionSprite(manager, animLength, x, y, z, dx, dy, dz, size, gravity) {
    var s = manager.getSprite();
    return s.animLength = animLength, s.easing = Ease.inOutQuad, s.position.x = x, s.position.y = y, s.position.z = z, s.size = size, s.dx = dx, s.dy = dy, s.dz = dz, s.slow = .7, s.angle = Math.random() * Math.PI2, s.rotate = .04 * Math.random() - .02, s.animColors = manager == explosionFireManager ? fireColors : smokeColors, s
};

function addExplosion(x, y, z, damage, radius) {
    for (var i = 0; i < Math.floor(damage / 4); i++) {
        var animLength = 80 * Math.random() + 80,
            size = 1 * Math.random() + .5,
            se = .5 * (.9 - size),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - 1) * se + .1,
            dz = (2 * Math.random() - 1) * se,
            s = addExplosionSprite(explosionSmokeManager, animLength, x, y, z, dx, dy, dz, size);
        s.float = .015 * Math.random() + .001, s.collide = true, (s = addExplosionSprite(explosionFireManager, .075 * animLength, x, y, z, 1.5 * dx, 1.5 * dy, 1.5 * dz, size)).collide = true
    }
    if (me) {
        var d = Math.length3(me.x - x, me.y - y, me.z - z);
        if (d < (radius *= 1.5)) {
            var shakeFactor = Math.max(0, (radius - d) / radius);
            shake = Math.min(7, shake + 6 * shakeFactor)
        };
    };
};

function lerp(colors, p, ref) {
    for (var i = colors.length - 2; 0 <= i; i--)
        if (p >= colors[i].pos) return void BABYLON.Color4.LerpToRef(colors[i].color, colors[i + 1].color, (p - colors[i].pos) * (1 / (colors[i + 1].pos - colors[i].pos)), ref)
};

function shellFragBurst(player, count, theSize, theAnimLength) {
    for (var i = 0; i < count; i++) {
        var animLength = Math.random() * theAnimLength + .5 * theAnimLength,
            size = i / (.5 * count) * theSize + .5 * theSize,
            se = .08 / (size + 1),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - .5) * se,
            dz = (2 * Math.random() - 1) * se,
            s = shellFragManager.getSprite();
        s.animLength = animLength, s.easing = Ease.inQuad, s.position.x = player.actor.mesh.position.x, s.position.y = player.actor.mesh.position.y + .3, s.position.z = player.actor.mesh.position.z, s.startSize = size, s.endSize = 0, s.gravity = .003, s.dx = dx, s.dy = dy, s.dz = dz, s.angle = Math.random() * Math.PI2, s.rotate = .2 * Math.random() - .1, s.collide = true, s.color.r = player.actor.bodyMesh.colorMult.r, s.color.g = player.actor.bodyMesh.colorMult.g, s.color.b = player.actor.bodyMesh.colorMult.b
    }
};

function yolkBurst(player) {
    for (var i = 0; i < 10; i++) {
        var animLength = 80 * Math.random() + 80,
            size = i / 5 * .2 + .2,
            se = .05 / (size + 1),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - .25) * se * 1.5,
            dz = (2 * Math.random() - 1) * se,
            s = yolkManager.getSprite();
        s.animLength = animLength, s.easing = Ease.inQuad, s.position.x = player.actor.mesh.position.x, s.position.y = player.actor.mesh.position.y + .3, s.position.z = player.actor.mesh.position.z, s.startSize = size, s.endSize = 0, s.gravity = .005, s.dx = dx, s.dy = dy, s.dz = dz, s.slow = .9, s.angle = Math.random() * Math.PI2, s.rotate = .2 * Math.random() - .1, s.collide = true
    }
};

function updateParticles(manager, delta) {
    for (var i = 0; i < manager.sprites.length; i++) {
        var s = manager.sprites[i];
        if (s.isVisible) {
            var anim = s.easing(s.anim);
            if (0 <= s.endSize && (s.size = s.startSize + anim * (s.endSize - s.startSize)), s.animColors && lerp(s.animColors, anim, s.color), !s.stopped) {
                s.position.x += s.dx, s.position.y += s.dy + s.float, s.position.z += s.dz, s.rotate && (s.angle += s.rotate);
                var res = false;
                s.collide && (tv1.set(s.position.x, s.position.y, s.position.z), res = Collider.pointCollidesWithMap(tv1, true)), res ? (s.stopped = true, s.position.x -= s.dx, s.position.y -= s.dy, s.position.z -= s.dz) : s.gravity && (s.dy -= s.gravity), s.slow && (s.dx *= s.slow, s.dy *= s.slow, s.dz *= s.slow)
            }
            s.anim += delta / s.animLength, 1 <= s.anim && (s.isVisible = false)
        }
    }
};

// [LS] ######## Settings ---------------------------------
//  ___ ___ _____ _____ ___ _  _  ___ ___ 
// / __| __|_   _|_   _|_ _| \| |/ __/ __|
// \__ \ _|  | |   | |  | || .` | (_ \__ \
// |___/___| |_|   |_| |___|_|\_|\___|___/


function loadSettings() {
    settings.volume = getStoredNumber("volume", 1);
    settings.mouseSensitivity = Math.max(Math.min(11, getStoredNumber("mouseSensitivity", 5)), 0);
    settings.mouseInvert = getStoredNumber("mouseInvert", 1);
    settings.holdToAim = getStoredBool("holdToAim", true);
    settings.enableChat = getStoredBool("enableChat", true); //TODO: chat is enabled by default, this is not original behaviour!
    settings.autoDetail = getStoredBool("autoDetail", true);
    settings.shadowsEnabled = getStoredBool("shadowsEnabled", true);
    settings.highRes = getStoredBool("highRes", true);

    var storedControlMap = JSON.parse(localStorage.getItem("controlConfig"));
    for (var sk in storedControlMap) Object.keys(inputToControlMap).forEach(function (ik) {
        inputToControlMap[ik] == storedControlMap[sk] && delete inputToControlMap[ik]
    }), inputToControlMap[sk] = storedControlMap[sk];
    for (var p in inputToControlMap) {
        var ps = "" + p;
        inputToControlMap.hasOwnProperty(ps) && ps != ps.toLocaleUpperCase() && (delete inputToControlMap[ps], inputToControlMap[ps.toLocaleUpperCase()] = inputToControlMap[p])
    } ! function () {
        for (var k in inputToControlMap) {
            var el = settingsKeyCells[inputToControlMap[k]];
            el && (el.innerText = ("" + k).toLocaleUpperCase())
        }
        document.getElementById("volume").value = settings.volume, document.getElementById("mouseSensitivity").value = settings.mouseSensitivity, document.getElementById("mouseInvert").checked = -1 == settings.mouseInvert, document.getElementById("holdToAim").checked = settings.holdToAim, document.getElementById("enableChat").checked = settings.enableChat, document.getElementById("autoDetail").checked = settings.autoDetail, document.getElementById("shadowsEnabled").checked = settings.shadowsEnabled, document.getElementById("highRes").checked = settings.highRes, setDetailSettingsVisibility(settings.autoDetail)
    }()
};

function getStoredNumber(name, def) {
    var num = localStorage.getItem(name);
    return num ? Number(num) : def
};

function getStoredBool(name, def) {
    var str = localStorage.getItem(name);
    return str ? "true" == str : def
};

function getStoredString(name, def) {
    var str = localStorage.getItem(name);
    return str || def
};

function selectServer(i) {
    selectedServer = i;
    localStorage.setItem("selectedServer", i);
    document.getElementById("serverName").innerText = "Server: " + servers[selectedServer].name;
};

function setDetailSettingsVisibility(invisible) {
    var vis = invisible ? "hidden" : "visible";
    document.getElementById("extraDetails").style.visibility = vis, !invisible && inGame ? (settings.shadowsEnabled = gameScene.shadowsEnabled, settings.highRes = 1 == engine.getHardwareScalingLevel(), document.getElementById("shadowsEnabled").checked = settings.shadowsEnabled, document.getElementById("highRes").checked = settings.highRes, localStorage.setItem("shadowsEnabled", settings.shadowsEnabled ? "true" : "false"), localStorage.setItem("highRes", settings.highRes ? "true" : "false")) : inGame && (enableShadows(), increaseResolution())
};


// [LS] ######## Inputs ---------------------------------
//  ___ _  _ ___ _   _ _____ ___ 
// |_ _| \| | _ \ | | |_   _/ __|
//  | || .` |  _/ |_| | | | \__ \
// |___|_|\_|_|  \___/  |_| |___/


// [LS] Canvas Listeners
function addCanvasListeners() {
    console.log("Event listeners added");
    canvas.style.pointerEvents = "all";
    canvas.addEventListener("mousedown", onCanvasMouseDown, false);
    canvas.addEventListener("mouseup", onCanvasMouseUp, false);
    canvas.addEventListener("mousemove", onCanvasMouseMove);
    canvas.addEventListener("wheel", onCanvasMouseWheel);
};

function removeCanvasListeners() {
    console.log("Event listeners removed");
    canvas.style.pointerEvents = "none";
    canvas.removeEventListener("mousedown", onCanvasMouseDown);
    canvas.removeEventListener("mouseup", onCanvasMouseUp);
    canvas.removeEventListener("mousemove", onCanvasMouseMove);
    canvas.removeEventListener("wheel", onCanvasMouseWheel);
};

function onCanvasMouseDown(event) {
    if (unfocused) {
        unfocused = false;
        canvas.requestPointerLock();
    };
    inputDown("MOUSE " + event.button), 1 == event.button && event.preventDefault()
};

function onCanvasMouseUp(event) {
    inputUp("MOUSE " + event.button)
};

function onCanvasMouseMove(event) {
    if (document.pointerLockElement && me && 0 < me.hp) {
        var mult = 5e-4 * settings.mouseSensitivity + .001;
        me.actor.scope && (mult *= .3);
        var mx = event.movementX;
        lastMouseMovement.x && Math.sign(mx) != Math.sign(lastMouseMovement.x) && (mx = 0), lastMouseMovement.x = mx;
        var my = event.movementY;
        lastMouseMovement.y && Math.sign(my) != Math.sign(lastMouseMovement.y) && (my = 0), lastMouseMovement.y = my, me.yaw = Math.radAdd(me.yaw, mx * mult), me.pitch = Math.clamp(me.pitch + my * settings.mouseInvert * mult, -1.5, 1.5)
    }
};

function onCanvasMouseWheel(event) {
    0 < event.wheelDelta ? (inputDown("WHEEL UP"), inputUp("WHEEL UP")) : (inputDown("WHEEL DOWN"), inputUp("WHEEL DOWN"))
};

window.addEventListener("contextmenu", function (e) {
    e.preventDefault()
}, false);

function captureKeys() {
    lastKey = null;
    document.onkeydown = onKeyDown;
    document.onkeyup = onKeyUp;
};

function releaseKeys() {
    document.onkeydown = null, document.onkeyup = null
};

function inputDown(code) {
    me.playing && (document.pointerLockElement || unfocused) && function (control) {
        switch (control) {
            case "up":
            case "down":
            case "left":
            case "right":
                var bit = CONTROL[control];
                me.controlKeys |= bit;
                me.stateBuffer[me.stateIdx].controlKeys = me.controlKeys;
                break;
            case "jump":
                if (0 < me.lastTouchedGround && Date.now() > me.lastTouchedGround + 100 && me.jump()) {
                    // var output = new Comm.Out(1);
                    // output.packInt8(Comm.Code.jump);
                    // wsSend(output, "jump");
                    var bit = CONTROL[control];
                    me.controlKeys |= bit;
                    me.stateBuffer[me.stateIdx].controlKeys = me.controlKeys;
                };
                break;
            case "fire":
                document.pointerLockElement && me && me.pullTrigger();
                break;
            case "grenade":
                document.pointerLockElement && me && !grenadePowerUp && me.canSwapOrReload() && 0 < me.grenadeCount && (grenadePowerUp = true, grenadeThrowPower = -.15);
                break;
            case "scope":
                settings.holdToAim ? me.actor.scopeIn() : me.actor.scope ? me.actor.scopeOut() : me.actor.scopeIn();
                break;
            case "reload":
                me.reload();
                break;
            case "weapon":
                me.swapWeapon(0 == me.weaponIdx ? 1 : 0);
                break;
            case "unfocus":
                unfocused = !unfocused;
                if (unfocused) {
                    document.exitPointerLock();
                } else {
                    canvas.requestPointerLock();
                };
                break;
        }
    }(inputToControlMap[code])
};

function inputUp(code, control) {
    me.playing && (document.pointerLockElement || unfocused) && function (control) {
        switch (control) {
            case "fire":
                me.weapon && me.releaseTrigger();
                break;
            case "scope":
                settings.holdToAim && me.actor.scopeOut();
                break;
            case "grenade":
                document.pointerLockElement && me && grenadePowerUp && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden", grenadePowerUp = false, me.throwGrenade(grenadeThrowPower));
                break;
            case "up":
            case "down":
            case "left":
            case "right":
            case "jump":
                var bit = CONTROL[control];
                me.controlKeys ^= me.controlKeys & bit
        }
    }(control || inputToControlMap[code])
};

function onKeyDown(e) {
    var key = (e = e || window.event).key;
    if (key != lastKey)
        if (lastKey = key, grenadePowerUp || 0 != me.controlKeys || "Enter" != key || !settings.enableChat) {
            var k = ("" + key).toLocaleUpperCase();
            if (" " == k && (k = "SPACE", e.preventDefault()), debug) {
                if ("`" == k) return void

                    function () {
                        if (debugWindow) {
                            for (var i = 0; i < playerLimit; i++) {
                                var p = players[i];
                                if (p) {
                                    var player = {
                                        name: p.name,
                                        hp: p.hp,
                                        playing: p.playing,
                                        posX: p.x,
                                        posY: p.y,
                                        posZ: p.z,
                                        actorX: p.actor.mesh.position.x,
                                        actorY: p.actor.mesh.position.y,
                                        actorZ: p.actor.mesh.position.z,
                                        transformEnabled: p.actor.mesh.isEnabled(),
                                        transformVisible: p.actor.mesh.isVisible,
                                        transformFrozen: p.actor.mesh.isWorldMatrixFrozen,
                                        shellEnabled: p.actor.bodyMesh.isEnabled(),
                                        shellVisible: p.actor.bodyMesh.isVisible,
                                        shellFrozen: p.actor.bodyMesh.isWorldMatrixFrozen,
                                        weaponEnabled: p.weapon.actor.gunMesh.isEnabled(),
                                        weaponVisible: p.weapon.actor.gunMesh.isVisible
                                    };
                                    debugWindow.document.write(JSON.stringify(player) + "\n")
                                }
                            }
                            debugWindow.document.write("<hr>")
                        } else (debugWindow = window.open("", "", "name=Debug")).document.write("<pre>")
                    }();
                if ("\\" == k) {
                    freezeFrame = true;
                    for (var i = 0; i < gameScene.particleSystems.length; i++) gameScene.particlesPaused = true;
                    for (i = 0; i < playerLimit; i++) players[i] && players[i].actor && (players[i].actor.mesh.setVisible(true), players[i].actor.showNameSprite(), players[i].actor.positionNameSprite());
                    ws.close()
                }
            }
            inputDown(k)
        } else if (me.chatLineCap > 0) {
            releaseKeys();
            chatInEl.style.background = "rgba(0, 0, 0, 0.5)";
            chatInEl.value = "";
            chatInEl.focus();
            chatting = !(lastKey = null);
        };
};

function onKeyUp(e) {
    var key = (e = e || window.event).key;
    key == lastKey && (lastKey = null);
    var k = ("" + key).toLocaleUpperCase();
    " " == k && (k = "SPACE", e.preventDefault()), inputUp(k)
};

// [LS] Input Settings

function setControl(el) {
    ! function (el) {
        var els = document.getElementsByClassName("box defined");
        Array.prototype.slice.call(els).forEach(function (otherEl) {
            otherEl != el && otherEl.innerText == el.innerText && (delete inputToControlMap[otherEl.innerText], otherEl.className = "box undefined", otherEl.innerText = getLocText("ui_settings_undefined"))
        })
    }(el), delete inputToControlMap[el.oldText], inputToControlMap[el.innerText] = el.id, controlEl = null, window.onkeydown = null, window.onkeyup = null, localStorage.setItem("controlConfig", JSON.stringify(inputToControlMap))
};

function configKey(e) {
    var el = e.target;
    e = e || window.event, el == controlEl ? (1 == e.button && window.event.preventDefault(), el.className = "box defined", null != e.wheelDelta ? 0 < e.wheelDeltaY ? el.innerText = "WHEEL UP" : e.wheelDeltaY < 0 && (el.innerText = "WHEEL DOWN") : el.innerText = "MOUSE " + e.button, setControl(el)) : (controlEl && (controlEl.className = "box defined", controlEl.innerText = controlEl.oldText), el.oldText = el.innerText, el.className = "box active", el.innerText = getLocText("ui_settings_bindinput"), (controlEl = el).focus(), window.onkeydown = function (e) {
        var key = (e = e || window.event).key;
        if ("Escape" != key && "Tab" != key && "Enter" != key) return " " == key && (key = "space", e.preventDefault()), el.className = "box defined", el.innerText = key.toLocaleUpperCase(), setControl(el), e.stopPropagation(), false;
        el.className = "box defined", el.innerText = el.oldText, controlEl = null
    }, window.onkeyup = function (e) {
        return e.stopPropagation(), false
    })
};


// [LS] ######## PlayerAccount ---------------------------------
//  ___ _      ___   _____ ___    _   ___ ___ ___  _   _ _  _ _____ 
// | _ \ |    /_\ \ / / __| _ \  /_\ / __/ __/ _ \| | | | \| |_   _|
// |  _/ |__ / _ \ V /| _||   / / _ \ (_| (_| (_) | |_| | .` | | |  
// |_| |____/_/ \_\_| |___|_|_\/_/ \_\___\___\___/ \___/|_|\_| |_|  

class PlayerAccountConstructor { //converted to class just because all these wannabe classes piss me off
    constructor () {
        this.loggedOut();
    };
    loggedOut () {
        this.session = null, this.kills = 0, this.deaths = 0, this.streak = 0, this.currentBalance = 0, this.classIdx = 0, this.inventory = [], this.pickedWeapons = [], this.stampItem = null, this.hatItem = null, this.colorIdx = 0, this.isLoggedIn = false, this.killMultiplier = 1, this.hideAds = false, this.upgradeExpiryDate = null, this.upgradeIsExpired = false, this.maybeSchoolEmail = false;
        for (var cIdx = 0; cIdx < CharClass.length; cIdx++) {
            var defaultPicks = [catalog.forClass[cIdx].primaryWeapons[0], catalog.forClass[cIdx].secondaryWeapons[0]];
            this.pickedWeapons.push(defaultPicks)
        }
    };
    setClass (classIdx) {
        this.classIdx = classIdx
    };
    pickWeapon (slot, weaponItem) {
        var foundInList = catalog.findItemInListById(weaponItem, catalog.forClass[this.classIdx].forWeaponSlot[slot]);
        false === foundInList && (weaponItem = catalog.forClass[this.classIdx].forWeaponSlot[slot][0]), this.pickedWeapons[this.classIdx][slot] = weaponItem
    };
    getPickedWeaponInSlot (slot) {
        return this.pickedWeapons[this.classIdx][slot]
    };
    getPrimaryWeapon () {
        return this.getPickedWeaponInSlot(Slot.Primary)
    };
    getSecondaryWeapon () {
        return this.getPickedWeaponInSlot(Slot.Secondary)
    };
    isUpgraded () {
        return void 0 !== this.upgradeProductId && null !== this.upgradeProductId && false === this.upgradeIsExpired
    };
    isItemOwned (item) {
        for (var i = 0; i < this.inventory.length; i++)
            if (this.inventory[i] && this.inventory[i].id === item.id) return true;
        return false
    };
    getEquippedItems () {
        var equippedItems = [this.getPrimaryWeapon(), this.getSecondaryWeapon()];
        return null !== this.hatItem && equippedItems.push(this.hatItem), null !== this.stampItem && equippedItems.push(this.stampItem), equippedItems
    };
    isItemEquipped (item) {
        if (null === item) return false;
        var foundItem = catalog.findItemInListById(item.id, this.getEquippedItems());
        return null !== foundItem
    };
    loggedIn (accountData) {
        devlog("this.loggedIn", accountData);
        var hasValue = function (a) {
            return null != a && 0 !== a
        };
        this.username = accountData.username;
        this.account_id = String(accountData.account_id);
        this.adminRoles = accountData.adminRoles;
        this.session = accountData.session;
        this.kills = accountData.kills;
        this.deaths = accountData.deaths;
        this.streak = accountData.streak;
        this.currentBalance = accountData.currentBalance;
        this.ownedItemIds = accountData.ownedItemIds;
        this.upgradeProductId = accountData.upgradeProductId;
        this.killMultiplier = hasValue(accountData.upgradeMultiplier) ? accountData.upgradeMultiplier : 1;
        this.hideAds = !!hasValue(accountData.upgradeAdFree) && accountData.upgradeAdFree;
        this.upgradeExpiryDate = hasValue(accountData.upgradeExpiryDate) ? accountData.upgradeExpiryDate : null;
        this.upgradeIsExpired = hasValue(accountData.upgradeExpiryDate) ? accountData.upgradeIsExpired : null;
        this.maybeSchoolEmail = accountData.maybeSchoolEmail;
        var version = void 0 === accountData.version || null === accountData.version ? 1 : accountData.version;
        localStorage.setItem("LegacyShellAuthToken", accountData.authToken);
        localStorage.setItem("LegacyShellPreviousUsername", accountData.username);

        if (1 <= version) {
            if (void 0 !== accountData.loadout && null !== accountData.loadout) {
                void 0 !== accountData.loadout.classIdx && null !== accountData.loadout.classIdx && this.setClass(accountData.loadout.classIdx);
                for (var outer = this, trySetPickedWeapon = function (weaponId, classIdx, slot) {
                    var weaponItem = catalog.forClass[classIdx].forWeaponSlot[slot][0];
                    hasValue(weaponId) && (weaponItem = catalog.findItemById(weaponId)), outer.pickedWeapons[classIdx][slot] = weaponItem
                }, c = 0; c < CharClass.length; c++) trySetPickedWeapon(accountData.loadout.primaryId[c], c, Slot.Primary), trySetPickedWeapon(accountData.loadout.secondaryId[c], c, Slot.Secondary);
                if (hasValue(accountData.loadout.hatId)) {
                    var hatItem = catalog.findItemById(accountData.loadout.hatId);
                    this.hatItem = hatItem
                }
                if (hasValue(accountData.loadout.stampId)) {
                    var stampItem = catalog.findItemById(accountData.loadout.stampId);
                    this.stampItem = stampItem
                }
                hasValue(accountData.loadout.colorIdx) && (this.colorIdx = accountData.loadout.colorIdx, 7 <= this.colorIdx && false === this.isUpgraded() && (this.colorIdx = 0))
            }
            if (hasValue(accountData.ownedItemIds))
                for (var i = 0; i < accountData.ownedItemIds.length; i++) {
                    var item = catalog.findItemById(accountData.ownedItemIds[i]);
                    this.inventory.push(item)
                }
        }
        this.isLoggedIn = true
    };
    setUpgrade (getUpgradeData) {
        this.upgradeProductId = getUpgradeData.upgradeProductId;
        this.multiplier = getUpgradeData.multiplier;
        this.hideAds = getUpgradeData.hideAds;
        this.upgradeIsExpired = getUpgradeData.isExpired;
        7 <= this.colorIdx && false === this.isUpgraded() && (this.colorIdx = 0);
    };
    syncToServer () {
        try {
            var servicesWs = new WebSocket(servicesServer)
        } catch (e) {
            console.log(e)
        }
        var updateHatId = void 0 !== playerAccount.hatItem && null !== playerAccount.hatItem ? playerAccount.hatItem.id : null,
            updateStampId = void 0 !== playerAccount.stampItem && null !== playerAccount.stampItem ? playerAccount.stampItem.id : null,
            loadout = {
                cmd: "saveEquip",
                session: this.session,
                class_idx: this.classIdx,
                soldier_primary_item_id: this.pickedWeapons[CharClass.Soldier][Slot.Primary].id,
                soldier_secondary_item_id: this.pickedWeapons[CharClass.Soldier][Slot.Secondary].id,    
                scrambler_primary_item_id: this.pickedWeapons[CharClass.Scrambler][Slot.Primary].id,
                scrambler_secondary_item_id: this.pickedWeapons[CharClass.Scrambler][Slot.Secondary].id,
                ranger_primary_item_id: this.pickedWeapons[CharClass.Ranger][Slot.Primary].id,
                ranger_secondary_item_id: this.pickedWeapons[CharClass.Ranger][Slot.Secondary].id,
                eggsploder_primary_item_id: this.pickedWeapons[CharClass.Eggsploder][Slot.Primary].id,
                eggsploder_secondary_item_id: this.pickedWeapons[CharClass.Eggsploder][Slot.Secondary].id,
                hat_id: updateHatId,
                stamp_id: updateStampId,
                color: this.colorIdx,
                save: "undefined" == typeof checkStatus || checkStatus()
            },
            json = JSON.stringify(loadout);
        servicesWs.onopen = function (e) {
            servicesWs.send(json), console.log("servicesWs opened, and saveEquip request sent")
        }, servicesWs.onmessage = function (e) {
            responseData = JSON.parse(e.data), responseData.error ? console.log("SyncToServer Error: " + JSON.stringify(responseData.error)) : console.log("SyncToServer completed successfully"), servicesWs.close()
        }, servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason)
        }, servicesWs.onerror = function (e) {
            console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
        }
    };
};

playerAccount = new PlayerAccountConstructor();

// [LS] ######## Signing In ---------------------------------
//  ___ ___ ___ _  _ ___ _  _  ___   ___ _  _ 
// / __|_ _/ __| \| |_ _| \| |/ __| |_ _| \| |
// \__ \| | (_ | .` || || .` | (_ |  | || .` |
// |___/___\___|_|\_|___|_|\_|\___| |___|_|\_|


function loggedIn(accountDataResponse) {
    devlog("function loggedIn", accountDataResponse)
    var numPurchases;
    if (accountDataResponse.error) {
        statsEl.innerHTML = "Database error. Please send us a bug report!";
        console.log("accountDataResponse Error: " + JSON.stringify(accountDataResponse.error));
    } else {
        playerAccount.loggedIn(accountDataResponse);
        updatePlayerStatsDisplay();
        updateCurrentBalance();
        waitForSetupAndAuthComplete();
        numPurchases = void 0 === playerAccount.inventory || null === playerAccount.inventory ? 0 : playerAccount.inventory.length;
    };
    console.log("logged in");
    // statsEl.style.display = "none";
    document.getElementById("login").style.display = "none";
    document.getElementById("logout").style.display = "block";
    document.getElementById("user-greeting").style.display = "block";
    document.getElementById("user-greeting").innerText = "Welcome back, @" + playerAccount.username;
    document.getElementById("playerStats").style.display = "flex";
    customizer = new Customizer, extern.customizer = customizer, authAttemptComplete = true
    // if (!playerAccount.isLoggedIn && !loggingIn) {
    //     if (loggingIn = true, user.getIdToken(true).then(function (idToken) {
    //         (statsEl = document.getElementById("statsMessage")).innerHTML = "Retrieving your stats...", statsEl.style.display = "block", console.log("Using services server: " + servicesServer);
    //         try {
    //             var authWs = new WebSocket(servicesServer)
    //         } catch (e) {
    //             console.log(e)
    //         }
    //         showSpinner("Retrieving Account", "I KNOW you're in here somewhere..."), authWs.onopen = function (e) {
    //             var authData = {
    //                 cmd: "auth",
    //                 uid: user.uid,
    //                 token: idToken
    //             };
    //             "undefined" != typeof modifyAuthData && modifyAuthData(authData), authWs.send(JSON.stringify(authData)), console.log("authWs opened, and auth request sent")
    //         }, authWs.onmessage = function (e) {
    // }, authWs.onclose = function (e) {
    //     console.log("authWs closed: " + e.code + " " + e.reason), loggingIn = false
    // }, authWs.onerror = function (e) {
    //     statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("authWS Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"])), loggingIn = false
    // }
    //     }).catch(function (error) {
    //         console.log(error), loggingIn = false
    //     }), document.getElementById("login").style.display = "none", document.getElementById("logout").style.display = "block", user.photoURL) {
    //         var url = user.photoURL,
    //             pd = user.providerData[0];
    //         "facebook.com" == pd.providerId && (url = "https://graph.facebook.com/" + pd.uid + "/picture"), document.getElementById("profilePic").src = url, document.getElementById("profilePic").style.display = "block"
    //     }
    // }
};

function loginFail(dueToOffline) {
    if (!dueToOffline) {
        delete localStorage.LegacyShellAuthToken;
        delete localStorage.LegacyShellPreviousUsername;
    };
    devlog("loginFail");
    document.getElementById("login").style.display = "block";
    customizer = new Customizer;
    extern.customizer = customizer;
    authAttemptComplete = true;
    document.getElementById("logout").style.display = "none";
    document.getElementById("user-greeting").style.display = "none";
    document.getElementById("currentBalanceContainer").style.display = "none";
    document.getElementById("currentBalance").innerText = "0";
    purchasingEnabled = false;
    waitForSetupAndAuthComplete();
    //thanks, no thanks :P
    // console.log("Sending anon tags to OneSignal..."), unbloated3({
    //     has_account: false,
    //     maybe_school: false,
    //     is_chromebook: detectChromebook()
    // })
};

function openLoginDialog() {
    openAlertDialog(
        "Login",
        `<div id="LS-login-container">
            <form id="LS-loginForm">
                <label for="LS-username">Username:</label><br>
                <input type="text" id="LS-username" name="username" required pattern="[A-Za-z0-9_\\-]{3,20}" title="Username must be 3-20 characters long and can only include letters, numbers, underscores, and hyphens."><br>
                <label for="LS-password">Password:</label><br>
                <input type="password" id="LS-password" name="password" required pattern=".{8,}" title="Password must be at least 8 characters long."><br>
            </form>
            <div id="LS-login-error" style="color:red;display:none;">Error text.</div>
            <div style="text-align: center;">
                <p style="font-size: 0.9em;">
                    No account?
                    <button class="ssbutton purple" style="width: 8em; margin-top: 10px; margin-left: 10px;" onclick="extern.openRegisterDialog()">Register</button>
                </p>
                <p style="font-size: 0.8em; color: #555; max-width: 20em; margin: 0 auto; word-wrap: break-word;">
                    Note: These servers are unofficial and do not work with real Shell Shockers account details.
                </p>
            </div>
        </div>`,
        {
            label: "Login",
            width: "8em",
            onclick: clickedLogin
        },
        {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        }
    );
};

function openRegisterDialog() {
    openAlertDialog(
        "Register",
        `<div id="LS-register-container">
            <form id="LS-registerForm">
                <label for="LS-register-username">Username:</label><br>
                <input type="text" id="LS-register-username" name="username" required pattern="[A-Za-z0-9_\\-]{3,20}" title="Username must be 3-20 characters long and can only include letters, numbers, underscores, and hyphens."><br>
                <label for="LS-register-password">Password:</label><br>
                <input type="password" id="LS-register-password" name="password" required pattern=".{8,}" title="Password must be at least 8 characters long."><br>
            </form>
            <div id="LS-register-error" style="color:red;display:none;">Error text.</div>
            <div style="text-align: center;">
                <p style="font-size: 0.9em;">
                    Already have an account?
                    <button class="ssbutton purple" style="width: 8em; margin-top: 10px; margin-left: 10px;" onclick="extern.openLoginDialog()">Login</button>
                </p>
                <p style="font-size: 0.8em; color: #555; max-width: 20em; margin: 0 auto; word-wrap: break-word;">
                    Note: These servers are unofficial. Please use a unique username and password.
                </p>
            </div>
        </div>`,
        {
            label: "Create",
            width: "8em",
            onclick: clickedRegister
        },
        {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        }
    );
};

async function clickedLogin() {
    var username = document.getElementById("LS-username").value;
    var password = document.getElementById("LS-password").value;

    showSpinner("Retrieving Account", "I KNOW you're in here somewhere...");

    if (username.length < 3 || password.length < 2) {
        hideSpinner();
        document.getElementById("LS-login-error").style.display = "block";
        document.getElementById("LS-login-error").textContent = "Invalid username or password.";
    } else {
        try {
            let result = await validateLogin(username, sha256(password));
            hideSpinner();
            devlog(result)
            if (result.error) {
                document.getElementById("LS-login-error").style.display = "block";
                document.getElementById("LS-login-error").textContent = result.error;
            } else if (result.session) {
                loggedIn(result);
                closeAlertDialog();
            };
        } catch (error) {
            hideSpinner();
            console.error("Login failed:", error);
            document.getElementById("LS-login-error").style.display = "block";
            document.getElementById("LS-login-error").textContent = "Request error.";
        };
    }
};

async function clickedRegister() {
    var username = document.getElementById("LS-register-username").value;
    var password = document.getElementById("LS-register-password").value;

    showSpinner("Creating Account", "Get set, ready, GO!");

    try {
        if (username.length < 3 || !/^[A-Za-z0-9?!._-]+$/.test(username)) {
            hideSpinner();
            document.getElementById("LS-register-error").textContent = "Invalid username. Only letters, numbers, ?!._- are allowed.";
            document.getElementById("LS-register-error").style.display = "block";
            return false;
        } else if (!(/^(?=.*[A-Za-z])(?=.*\d).{8,}$/).test(password)) {
            hideSpinner();
            document.getElementById("LS-register-error").style.display = "block";
            document.getElementById("LS-register-error").textContent = "Password is too insecure.\nAt least 8 characters, 1 letter and 1 number are required."
        } else {
            let result = await validateRegister(username, sha256(password));
            hideSpinner();
            devlog(result);

            if (result.error) {
                document.getElementById("LS-register-error").style.display = "block";
                document.getElementById("LS-register-error").textContent = result.error;
            } else if (result.session) {
                loggedIn(result);
                closeAlertDialog();
            };
        };
    } catch (error) {
        hideSpinner();
        console.error("Register failed:", error);
        document.getElementById("LS-register-error").style.display = "block";
        document.getElementById("LS-register-error").textContent = "Request error.";
    };
};

function waitForSetupAndAuthComplete() {
    if (waitIteration >= 200) {
        openAlertDialog("", '<div id="setupAndAuthTimedOut">Uh oh, there was a problem. Try reloading the page.</div>', {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        })
    } else {
        if (null != customizer && true === customizer.isReady && authAttemptComplete && houseAdsLoaded) {
            customizer.setupItems();
            customizer.dressUpEgg();
            setupUpgradeUI();
            pingServers(true, function () {
                var showDate;
                onResourcesLoaded();
                isRunning = true;
                (function () {
                    var searchParams = new URLSearchParams(document.location.search);
                    if (false === searchParams.has("showItem")) return false;
                    var showItemId = parseInt(searchParams.get("showItem"));
                    return false !== (Number.isInteger(showItemId) && null !== catalog.findItemById(showItemId) && false === linkItemShown) && (linkItemShown = openItemInCustomizer(showItemId))
                }()) || tryShowTaggedItems() || tryShowNugget() || true;
            });
        } else {
            waitIteration++;
            setTimeout(waitForSetupAndAuthComplete, 100);
        };
    };
};

// [LS] Login Request Stuff

function validateLogin(username, hashedPassword) {
    return new Promise((resolve, reject) => {
        devlog(username, hashedPassword);
        devlog("validateLogin called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        }

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateLogin",
                username: username,
                password: hashedPassword,
            }));
            console.log("servicesWs opened, and validateLogin request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            }
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

function validateLoginViaAuthToken(username, authToken) {
    return new Promise((resolve, reject) => {
        devlog(username, authToken);
        devlog("validateLogin called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        }

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateLoginViaAuthToken",
                username: username,
                authToken: authToken,
            }));
            console.log("servicesWs opened, and validateLoginViaAuthToken request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            };
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

function validateRegister(username, hashedPassword) {
    return new Promise((resolve, reject) => {
        devlog(username, hashedPassword);
        devlog("validateRegister called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        };

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateRegister",
                username: username,
                password: hashedPassword,
            }));
            console.log("servicesWs opened, and validateRegister request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            }
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

// [LS] ######## Extern ---------------------------------
//  _____  _______ ___ ___ _  _ 
// | __\ \/ /_   _| __| _ \ \| |
// | _| >  <  | | | _||   / .` |
// |___/_/\_\ |_| |___|_|_\_|\_|

window.extern = function () {
    return {
        openLoginDialog: openLoginDialog,
        openRegisterDialog: openRegisterDialog,
        globalThis: globalThis,
        this_1: this,
        Items: Items,
        logout: function (callback) {
            // firebase.auth().signOut().then(function () {
            // }, function (err) {
            //     console.log(err)
            // })
            document.getElementById("login").style.display = "block";
            document.getElementById("logout").style.display = "none";
            document.getElementById("user-greeting").style.display = "none";
            document.getElementById("profilePic").style.display = "none";
            document.getElementById("playerStats").style.display = "none";
            document.getElementById("statsMessage").style.display = "none";
            document.getElementById("currentBalanceContainer").style.display = "none";
            document.getElementById("currentBalance").innerText = "0";
            playerAccount.loggedOut();
            setupUpgradeUI();
            user = null;
            delete localStorage.LegacyShellAuthToken;
            delete localStorage.LegacyShellPreviousUsername;
            customizer.dressUpEgg();
        },
        play: play,
        closeCreateGameDialog: function () {
            document.getElementById("createGameDialog").style.display = "none", hideDarkOverlay()
        },
        openServerList: function () {
            openAlertDialog("Servers", "", {
                label: "Close",
                width: "6em",
                onclick: closeServerList
            });
            for (var serverItem = document.getElementById("serverItem"), list = document.createElement("form"), barColors = ["lime", "yellow", "orange", "red"], i = 0; i < servers.length; i++) {
                var server = serverItem.cloneNode(true);
                server.style.display = "block";
                var border, pingColor, checkEl = server.children[0].children[0],
                    nameEl = server.children[0].children[1],
                    barEl = (server.children[0].children[2], server.children[0].children[3]),
                    offlineEl = server.children[0].children[4],
                    msEl = server.children[0].children[5];
                nameEl.innerText = servers[i].name, checkEl.value = i, servers[i].ping ? (border = Math.min(5.4, Math.max(0, (servers[i].ping - 50) / 65)) + .1, pingColor = Math.min(3, Math.floor(servers[i].ping / 100)), barEl.style.display = "block", offlineEl.style.display = "none", barEl.style.backgroundColor = barColors[pingColor], barEl.style.borderRight = border + "em solid var(--egg-brown)", msEl.innerText = servers[i].ping + "ms") : (barEl.style.display = "none", offlineEl.style.display = "block"), list.appendChild(server)
            }
            document.getElementById("alertMessage").appendChild(list), list.children[selectedServer].children[0].children[0].checked = true, list.addEventListener("change", function (e) {
                selectServer(e.target.value)
            })
        },
        openCustomizerFromMainMenu: openCustomizerFromMainMenu,
        openCustomizerInGame: function () {
            hideGameDom(), engine.stopRenderLoop(), customizer.open(), customizer.startRendering()
        },
        showFeedbackForm: function () {
            inGame && releaseKeys(), ga("send", "event", "feedback opened"), openAlertDialog("Feedback", "", {
                label: "Send",
                width: "6em",
                onclick: sendFeedback
            }, {
                label: "Cancel",
                width: "6em",
                onclick: closeFeedback
            }), document.getElementById("alertButton1").style.visibility = "hidden", document.getElementById("alertMessage").appendChild(document.getElementById("feedback")), document.getElementById("feedback").style.display = "block"
        },
        feedbackChanged: function (e) {
            var fd = document.getElementById("feedbackComments"),
                fe = document.getElementById("feedbackEmail");
            feedbackValidateTimeout && clearTimeout(feedbackValidateTimeout), feedbackValidateTimeout = setTimeout(function () {
                "" != fd.value && "" != fe.value ? document.getElementById("alertButton1").style.visibility = "visible" : document.getElementById("alertButton1").style.visibility = "hidden"
            }, 200)
        },
        selectGameType: function (i) {
            gameType = i, localStorage.setItem("gameType", i)
        },
        openJoinBox: openJoinBox,
        closeJoinBox: function () {
            document.getElementById("customGame").style.display = "block", document.getElementById("joinGame").style.display = "none", document.getElementById("joinCode").value = "", history.replaceState(null, null, location.pathname)
        },
        openCreateBox: function () {
            document.getElementById("customGame").style.display = "none", document.getElementById("createGame").style.display = "block"
        },
        closeCreateBox: function () {
            document.getElementById("customGame").style.display = "block", document.getElementById("createGame").style.display = "none"
        },
        showChangelog: function () {
            openAlertDialog("Version " + version, document.getElementById("changelog").innerHTML, {
                label: "OK"
            });
        },
        showConfig: function () {
            openAlertDialog("LegacyShell Config", document.getElementById("config").innerHTML, {
                label: "OK"
            });
        },
        respawn: function () {
            if (playOffline) return me.playing = true, void canvas.requestPointerLock();
            console.log("Respawn pressed - respawnTime: " + respawnTime);
            if (null == respawnTime || respawnTime < 0) {
                interval.clearAll();
                timeout.clearAll();
                requestRespawn();
            };
        },
        copyFriendCode: copyFriendCode,
        dismissNotification: dismissNotification,
        closeSettingsMenu: closeSettingsMenu,
        setVolume: function (el) {
            settings.volume = el.value, localStorage.setItem("volume", settings.volume), BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume), 0 == settings.volume ? BABYLON.Engine.audioEngine.audioContext.suspend() : BABYLON.Engine.audioEngine.audioContext.resume()
        },
        setMusicVolue: function (el) {
            settings.musicVolume = el.value, localStorage.setItem("musicVolume", settings.musicVolume), Music.menu && Music.menu.setVolume(el.value), Music.game && Music.game.setVolume(el.value)
        },
        setMouseSensitivity: function (el) {
            settings.mouseSensitivity = el.value, localStorage.setItem("mouseSensitivity", settings.mouseSensitivity)
        },
        setCheckOption: function (el) {
            var val = el.checked;
            switch (el.id) {
                case "mouseInvert":
                    val = el.checked ? -1 : 1;
                    break;
                case "autoDetail":
                    el.checked ? enableAutoDetail() : (optimizer.stop(), optimizer.dispose(), optimizer = null), setDetailSettingsVisibility(el.checked);
                    break;
                case "shadowsEnabled":
                    el.checked ? enableShadows() : disableShadows();
                    break;
                case "highRes":
                    el.checked ? increaseResolution() : lowerResolution();
                    break;
                case "enableChat":
                    el.checked ? (document.getElementById("enableChat").checked = true, settings.enableChat = true, localStorage.setItem("enableChat", true), chatInEl.value = "Press ENTER to chat", inGame && (chatOutEl.style.display = "block", chatInEl.style.display = "block")) : (settings.enableChat = false, localStorage.setItem("enableChat", false), inGame && (chatOutEl.style.display = "none", chatInEl.style.display = "none"))
            }
            settings[el.id] = val, localStorage.setItem(el.id, val)
        },
        openPrivacyOptions: function () {
            // closeSettingsMenu(), openAlertDialog("Privacy Options", document.getElementById("privacyOptions").innerHTML, {
            //     label: "OK"
            // });
            // var ofAgeCheck = document.getElementById("ofAgeCheck"),
            //     targetedAdsCheck = document.getElementById("targetedAdsCheck");
            // targetedAdsCheck.checked = consent ? (ofAgeCheck.checked = consent.ofAge, consent.targetedAds) : (consent = {
            //     ofAge: false,
            //     targetedAds: false
            // }, ofAgeCheck.checked = false), consent.ofAge || (targetedAdsCheck.disabled = true, document.getElementById("targetedAdsText").style.opacity = .25)
        },
        switchTeamDialog: function () {
            openAlertDialog("", 1 == me.team ? 'Switch to team<h1 class="redTeam">RED?</h1>Your score will be reset!' : 'Switch to team<h1 class="blueTeam">BLUE?</h1>Your score will be reset!', {
                label: "Yes",
                width: "5em",
                onclick: switchTeam
            }, {
                label: "No",
                width: "5em",
                onclick: closeAlertDialog
            })
        },
        showMainMenuConfirm: showMainMenuConfirm,
        inviteFriends: inviteFriends,
        openSettingsMenu: openSettingsMenu,
        toggleFullscreen: function () {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) (f = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen) && f.call(document);
            else {
                var f, e = document.body;
                (f = e.requestFullscreen || e.webkitRequestFullscreen || e.mozRequestFullScreen || e.msRequestFullscreen) && (f.call(e), ga("send", "event", "fullscreen"))
            }
        },
        hideBigAd: hideBigAd,
        clickedBigAd: function () {
            ga("send", "event", {
                eventCategory: "Big ad",
                eventAction: "click",
                eventLabel: houseAds.big[bigAdIdx].label
            }), houseAds.big[bigAdIdx].linksToNugget && (showNugget = true, hideBigAd(), tryShowNugget())
        },
        doConsent: function () {
            dismissNotification(function () {
                notify(document.getElementById("doConsent").innerHTML)
            })//, ga("send", "event", "privacy", "age gate", "agree"), consent = {
                // ofAge: true,
                // targetedAds: true
            //}, document.getElementById("login").style.display = "block", aiptag.consented = true, localStorage.setItem("consent", JSON.stringify(consent))
        },
        dontConsent: function () {
            dismissNotification(function () {
                notify(document.getElementById("dontConsent").innerHTML)
            })//, ga("send", "event", "privacy", "age gate", "disagree"), consent = {
            //     ofAge: false,
            //     targetedAds: false
            // }, aiptag.consented = false, localStorage.setItem("consent", JSON.stringify(consent))
        },
        setOfAge: function (e) {
            // var targetedAdsCheck = document.getElementById("targetedAdsCheck"),
            //     targetedAdsText = document.getElementById("targetedAdsText");
            // consent.ofAge = e.checked, ga("send", "event", "privacy", "of age", e.checked ? "yes" : "no"), e.checked ? (targetedAdsCheck.disabled = false, targetedAdsText.style.opacity = 1, document.getElementById("login").style.display = "block") : (consent.targetedAds = false, targetedAdsCheck.checked = false, targetedAdsCheck.disabled = true, targetedAdsText.style.opacity = .25, aiptag.consented = false, document.getElementById("login").style.display = "none"), localStorage.setItem("consent", JSON.stringify(consent))
        },
        setTargetedAds: function (e) {
            //consent.targetedAds = e.checked, aiptag.consented = e.checked, ga("send", "event", "privacy", "targetedAds", e.checked ? "yes" : "no"), localStorage.setItem("consent", JSON.stringify(consent))
        },
        configKey: configKey,
        onChatKeyDown: function (e) {
            var key = (e = e || window.event).key;
            chatInEl.value = fixStringWidth(chatInEl.value, maxChatWidth);
            switch ( key) {
                case "Enter":
                    var text = chatInEl.value.trim();
                    if ("" != text && text.indexOf("<") < 0) {
                        var output = new Comm.Out(2 + 2 * text.length);
                        output.packInt8(Comm.Code.chat);
                        output.packString(text);
                        wsSend(output, "chat");
                        addChat(text, me);
                        me.chatLineCap--;
                    };
                case "Tab":
                    initChatIn(), e.preventDefault(), e.stopPropagation(), captureKeys()
            }
        },
        clickedHouseAd: function () {
            ga("send", "event", {
                eventCategory: "House banner ad",
                eventAction: "click",
                eventLabel: houseAds.small[smallAdIdx].label
            }), houseAds.small[smallAdIdx].link && window.open(houseAds.small[smallAdIdx].link, "_window"), houseAds.small[smallAdIdx].linksToTaggedItems && (showTaggedItems = houseAds.small[smallAdIdx].linksToTaggedItems, tryShowTaggedItems()), houseAds.small[smallAdIdx].linksToItemId && openItemInCustomizer(houseAds.small[smallAdIdx].linksToItemId), houseAds.small[smallAdIdx].linksToNugget && (showNugget = true, tryShowNugget())
        },
        buyItem: function (itemId) {
            console.log("buyItem called for item ID: " + itemId);
            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            servicesWs.onopen = function (e) {
                var buyData = {
                    cmd: "buy",
                    session: playerAccount.session,
                    item_id: itemId,
                    save: "undefined" == typeof checkStatus || checkStatus()
                };
                servicesWs.send(JSON.stringify(buyData))
            }, servicesWs.onmessage = function (e) {
                switch (purchaseResult = JSON.parse(e.data), console.log("purchase response: " + purchaseResult.result), purchaseResult.result) {
                    case "SUCCESS":
                        if (void 0 !== purchaseResult.item_id && null !== purchaseResult) {
                            var boughtItem = catalog.findItemById(purchaseResult.item_id);
                            playerAccount.inventory.push(boughtItem);
                            devlog("nice", boughtItem, purchaseResult);
                        };
                        playerAccount.currentBalance = purchaseResult.current_balance;
                        updateCurrentBalance();
                        // customizer.clearItemLocks();
                        try {
                            customizer.boughtItem();
                        } catch (error) {
                            devlog("bruh it happened", error);
                        }
                        customizer.physicalUnlockBack(); //idk. there is same gay error.
                        break;
                    case "INSUFFICIENT_FUNDS":
                        openAlertDialog("Need More Eggs!", "You need more eggs", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ALREADY_OWNED":
                        openAlertDialog("Already Owned", "You already have this. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "PLAYER_NOT_FOUND":
                        openAlertDialog("Uh Oh", "There was a problem. Try logging in again.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ITEM_NOT_FOUND":
                        openAlertDialog("Uh Oh", "There was a problem. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ERROR":
                    default:
                        console.log("buyItem error: " + purchaseResult.error), openAlertDialog("Uh Oh", "There was a problem. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null)
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            }
        },
        buyEggs: function () {
            // purchasingEnabled ? XPayStationWidget.open() : getXsollaToken(true, null)
        },
        Customizer,
        playerAccount,
        openRedeemCodeDialog: function () {
            showDarkOverlay(), document.getElementById("redeemCodeDialog").style.display = "inline-block";
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.value = "";
            redeemCodeInput.disabled = false;
            document.getElementById("enterRedeemCode").style.display = "inline-block";
            document.getElementById("redeemCodeResult").style.display = "none";
            document.getElementById("previewCodeResult").style.display = "none";
            document.exitPointerLock(), window.onkeydown = null, window.onkeyup = null
        },
        closeRedeemCodeDialog: function () {
            document.getElementById("redeemCodeDialog").style.display = "none", hideDarkOverlay()
        },
        redeemCode: function () {
            document.getElementById("previewCodeResult").style.display = "none";

            const previewCodeResult = document.getElementById("previewCodeResult");
            if (previewCodeResult) {
                const itemList = previewCodeResult.querySelector("#showItemList");
                if (itemList) {
                    itemList.innerHTML = '';
                };
            };

            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.disbled = true;
            var code = redeemCodeInput.value;
            console.log("redeem code called", code);
            code && 0 != code.length && (servicesWs.onopen = function (e) {
                servicesWs.send(JSON.stringify({
                    cmd: "redeem",
                    session: playerAccount.session,
                    code: code
                }))
            }, servicesWs.onmessage = function (e) {
                // devlog("SIR! SIR! DO NOT REDEEM! SIR!");
                let redeemResult = JSON.parse(e.data);
                devlog(redeemResult);

                if (redeemResult.error) console.log("redeemCode Error: " + JSON.stringify(redeemResult.error));
                else {
                    console.log("redeemCode response: " + redeemResult.result);
                    var redeemCodeResultText = document.getElementById("redeemCodeResultText"),
                        redeemCodeSuccessButton = document.getElementById("redeemCodeCompleteButton");
                    switch (document.getElementById("enterRedeemCode").style.display = "none", document.getElementById("redeemCodeResult").style.display = "inline-block", redeemResult.result) {
                        case "SUCCESS":
                            redeemCodeResultText.innerHTML = "<h1>CODE CRACKED!!</h1>", 0 < redeemResult.eggs_given && void 0 !== redeemResult.eggs_given && null !== redeemResult.eggs_given && 0 < redeemResult.eggs_given && (redeemCodeResultText.innerHTML += '<div style="margin-top: 1em; margin-bottom: 2em; text-align: center;"><img src="img/egg_icon.png" style="width: 2em;" /><h2>+ ' + redeemResult.eggs_given + " </h2></div>", checkBalance());
                            var items = [];
                            if (redeemResult.item_ids)
                                for (var i = 0; i < redeemResult.item_ids.length; i++) {
                                    var redeemedItem = catalog.findItemById(redeemResult.item_ids[i]);
                                    playerAccount.isItemOwned(redeemedItem) || playerAccount.inventory.push(redeemedItem), items.push(redeemedItem)
                                }
                            if (customizer.setupItems(), 0 < items.length) {
                                var itemList = createShowItemListHTML(items.length);
                                redeemCodeResultText.innerHTML += itemList.innerHTML, renderItemsInShowItemList(items)
                            }
                            redeemCodeSuccessButton.style = "ssbutton green";
                            break;
                        case "CODE_PREV_REDEEMED":
                            redeemCodeResultText.innerText = "That code has already been used!", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "CODE_NOT_FOUND":
                            redeemCodeResultText.innerText = "Invalid code", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "ERROR":
                            console.log("error: " + redeemResult.error), redeemCodeResultText.innerText = "Uh oh, there was problem", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        default:
                            redeemCodeResultText.innerText = "Uh oh, there was problem. Try logging in again.", redeemCodeSuccessButton.style = "ssbutton red"
                    }
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            })
        },
        //this code is really, really, really shit. im sorry. the original function was already super convoluted.
        previewCode: function () {
            console.log("preview code called");
            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.disbled = true;
            var code = redeemCodeInput.value;
            code && 0 != code.length && (servicesWs.onopen = function (e) {
                servicesWs.send(JSON.stringify({
                    cmd: "preview",
                    session: playerAccount.session,
                    code: code
                }))
            }, servicesWs.onmessage = function (e) {
                // devlog("SIR! SIR! DO NOT REDEEM! SIR!");
                let previewResult = JSON.parse(e.data);
                devlog(previewResult);
                
                if (previewResult.error) console.log("previewCode Error: " + JSON.stringify(previewResult.error));
                else {
                    console.log("previewCode response: " + previewResult.result);
                    
                    let previewOrRedeem = previewResult.result == "SUCCESS" ? "previewCode" : "redeemCode";

                    var previewCodeResultText = document.getElementById(previewOrRedeem+"ResultText");
                    var previewCodeSuccessButton = document.getElementById(previewOrRedeem+"CompleteButton");
                    document.getElementById("enterRedeemCode").style.display = "none";
                    document.getElementById(previewOrRedeem+"Result").style.display = "inline-block";

                    switch (previewResult.result) {
                        case "SUCCESS":
                            previewCodeResultText.innerHTML = "<h1>Do you want to crack this code?</h1>", 0 < previewResult.eggs_given && void 0 !== previewResult.eggs_given && null !== previewResult.eggs_given && 0 < previewResult.eggs_given && (previewCodeResultText.innerHTML += '<div style="margin-top: 1em; margin-bottom: 2em; text-align: center;"><img src="img/egg_icon.png" style="width: 2em;" /><h2>+ ' + previewResult.eggs_given + " </h2></div>", checkBalance());
                            var usesRemaining = document.getElementById("usesCount");
                            if (usesRemaining) {
                                usesRemaining.textContent = previewResult.uses || 0;
                            };
                            var items = [];
                            if (previewResult.item_ids)
                                for (var i = 0; i < previewResult.item_ids.length; i++) {
                                    var redeemedItem = catalog.findItemById(previewResult.item_ids[i]);
                                    playerAccount.isItemOwned(redeemedItem) || playerAccount.inventory.push(redeemedItem), items.push(redeemedItem)
                                }
                            if (customizer.setupItems(), 0 < items.length) {
                                var itemList = createShowItemListHTML(items.length);
                                previewCodeResultText.innerHTML += itemList.innerHTML, renderItemsInShowItemList(items)
                            }
                            previewCodeSuccessButton.style = "ssbutton green";
                            break;
                        case "CODE_PREV_REDEEMED":
                            previewCodeResultText.innerText = "That code has already been used!", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "CODE_NOT_FOUND":
                            previewCodeResultText.innerText = "Invalid code", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "ERROR":
                            console.log("error: " + previewResult.error), previewCodeResultText.innerText = "Uh oh, there was problem", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        default:
                            previewCodeResultText.innerText = "Uh oh, there was problem. Try logging in again.", previewCodeSuccessButton.style = "ssbutton red"
                    }
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            })
        },
        openItemInCustomizer: openItemInCustomizer,
        openTaggedItemsInCustomizer: openTaggedItemsInCustomizer,
        closeGiveRewardDialog: function () {
            document.getElementById("giveRewardDialog").style.display = "none", hideDarkOverlay()
        },
        openBuyPassDialog: openBuyPassDialog,
        closeBuyPassDialog: closeBuyPassDialog,
        setApplixirPopup: setApplixirPopup,
        showBoughtNuggetPopup: showBoughtNuggetPopup,
        buyPass: function () {
        },
        openChickenNugget: function () {
            const nuggetFrame = document.getElementById("nuggetGame_Frame");
            const buyPassDialog = document.getElementById("buyPassDialog");
            const nuggetInstruction = document.getElementById("nuggetGame_Instruction");
            const nuggetDone = document.getElementById("nuggetGame_Done");
            const gotNuggetOK = document.getElementById("gotNuggetOK");

            nuggetFrame.src = "app_nugget/index.html";
            buyPassDialog.classList.add("hideme");
            nuggetInstruction.classList.remove("hideme");
            nuggetDone.classList.add("hideme");
            gotNuggetOK.classList.add("invisible");

            callApi({
                cmd: "token",
                session: playerAccount.session
            }, handleTokenSuccess, handleTokenError);
        
            function handleTokenSuccess(response) {
                console.log("token: " + JSON.stringify(response.token));
                isGettingNugget = true;
                servicesToken = response.token;
                setApplixirPopup(true);
                showBoughtNuggetPopup();
            };
        
            function handleTokenError(response) {
                console.log("error getting token");
                openAlertDialog(
                    "Uh Oh!",
                    response.error || "Something broke. Try reloading the game.",
                    null,
                    {
                        label: "OK",
                        width: "4em",
                        onclick: function () {
                            closeAlertDialog();
                            buyPassDialog.classList.toggle("hideme");
                        }
                    }
                );
            }
        },
        finishChickenNuggetGame: function () {
            document.getElementById("nuggetGame_Instruction").classList.toggle("hideme"), document.getElementById("nuggetGame_Done").classList.toggle("hideme"), document.getElementById("gotNuggetOK").classList.toggle("invisible")
        },
        closeChickenNugget: function () {
            document.getElementById("nuggetGame_Frame").src = "about:blank", checkUpgrade();
            var adElement = document.getElementById("shellshock-io_multisize");
            adElement.style.display = "none", document.getElementById("gameAdContainer").appendChild(adElement), document.getElementById("gotNuggetPopup").classList.toggle("hideme"), hideDarkOverlay()
        },
        enterSpectatorMode: function () {
            me && (document.getElementById("spectate").style.display = "block", document.getElementById("gameMenu").style.display = "none", document.getElementById("gameSummary").style.visibility = "hidden", document.getElementById("ffaFinal").style.display = "none", document.getElementById("teamFinal").style.display = "none", timedGame && betweenRounds || (document.getElementById("deathBox").style.display = "none", document.getElementById("health").style.display = "block", document.getElementById("killTicker").style.display = "block", document.getElementById("playerList").style.display = "block", chatting && chatInEl.focus()), hideMultisizeBannerAd(), document.getElementById("gameAdContainer").style.display = "none", player = function () {
                for (var i = 0; i < playerLimit; i++)
                    if (i != meId && players[i] && players[i].playing) return players[i]
            }(), player.id != meId && (viewingPlayer.actor.hands.setRenderingGroupId(0), viewingPlayer.weapon.actor.gunMesh.setRenderingGroupId(0), viewingPlayer.actor.hat && viewingPlayer.actor.hat.setEnabled(true)), player.actor.hands.setRenderingGroupId(1), player.weapon.actor.gunMesh.setRenderingGroupId(1), player.actor.hat && player.actor.hat.setEnabled(false), player.actor.hideNameSprite(), viewingPlayerId = (viewingPlayer = player).id, doFirstPersonCamera(player), document.getElementById("spectatingName").innerText = player.name);
            var player
        },
        spectatorSelect: function () { },
        clearSettings: function () {
            // programming genius
            localStorage.removeItem("volume");
            localStorage.removeItem("mouseSensitivity");
            localStorage.removeItem("mouseInvert");
            localStorage.removeItem("holdToAim");
            localStorage.removeItem("enableChat");
            localStorage.removeItem("autoDetail");
            localStorage.removeItem("shadowsEnabled");
            localStorage.removeItem("highRes");
            localStorage.removeItem("controlConfig");
            loadSettings();
        },
        applixirAdStatusHandler: function (status) {
            switch (console.log("Applixir status: " + status), status) {
                case "ad-started":
                case "fb-started":
                    applixirAdWatched = false;
                    break;
                case "ad-watched":
                case "fb-watched":
                case "network-error":
                case "cors-error":
                case "ads-unavailable":
                    applixirAdWatched = true;
                    break;
                case "sys-closing":
                    true === applixirAdWatched ? buyChickenNuggetProduct() : setApplixirPopup(false), applixirAdWatched = false;
                    break;
                case "ad-blocker":
                    setApplixirPopup(false), openAlertDialog("Ad Blocker Detected", "No ads - No nugget", null, {
                        label: "Fine",
                        width: "4em",
                        onclick: function () {
                            closeAlertDialog()
                        }
                    })
            }
        }
    }
}();

console.log(`
    _                                      __                      
    /                                    /    )   /           /   /
   /       __    __    __    __          \\       /__    __   /   / 
  /      /___) /   ) /   ) /   ' /   /    \\     /   ) /___) /   /  
_/____/_(___ _(___/_(___(_(___ _(___/_(____/___/___/_(___ _/___/___
                 /                 /                               
             (_ /              (_ /                                
           LegacyShell Starting! (Version ${VERSION})
`);

devlog("DEV LOGS ENABLED!");