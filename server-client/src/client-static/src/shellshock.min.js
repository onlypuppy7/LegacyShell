//     _                                      __
//     /                                    /    )   /           /   /
//    /       __    __    __    __          \       /__    __   /   /
//   /      /___) /   ) /   ) /   ' /   /    \     /   ) /___) /   /
// _/____/_(___ _(___/_(___(_(___ _(___/_(____/___/___/_(___ _/___/___
//                  /                 /
//              (_ /              (_ /
// LegacyShell Team 2024, Blue Wizard Digital 2019

// [LS] ######## LegacyShell Specific ---------------------------------
//  _    ___ ___   _   _____   _____ _  _ ___ _    _
// | |  | __/ __| /_\ / __\ \ / / __| || | __| |  | |
// | |__| _| (_ |/ _ \ (__ \ V /\__ \ __ | _|| |__| |__
// |____|___\___/_/ \_\___| |_| |___/_||_|___|____|____|
const VERSION = `LEGACYSHELLVERSION`;
const devmode = LEGACYSHELLDEVMODE;
const permissions = LEGACYSHELLPERMSCONFIG;

LEGACYSHELLISCLIENTSERVER

// [LS] ######## LegacyShell Plugins (Before) ---------------------------------
//     ____  __    __  _____________   _______         ____  ________________  ____  ______
//    / __ \/ /   / / / / ____/  _/ | / / ___/   _    / __ )/ ____/ ____/ __ \/ __ \/ ____/
//   / /_/ / /   / / / / / __ / //  |/ /\__ \   (_)  / __  / __/ / /_  / / / / /_/ / __/   
//  / ____/ /___/ /_/ / /_/ // // /|  /___/ /  _    / /_/ / /___/ __/ / /_/ / _, _/ /___   
// /_/   /_____/\____/\____/___/_/ |_//____/  (_)  /_____/_____/_/    \____/_/ |_/_____/   

LEGACYSHELLPLUGINMANAGER

LEGACYSHELLPLUGINSBEFORE

devlog("emitting startup");
plugins.emit('startUp', { });

// [LS] ######## BABYLONSTART ---------------------------------
//  ___   _   _____   ___    ___  _  _
// | _ ) /_\ | _ ) \ / / |  / _ \| \| |
// | _ \/ _ \| _ \\ V /| |_| (_) | .` |
// |___/_/ \_\___/ |_| |____\___/|_|\_|
LEGACYSHELLBABYLON

BABYLON.Effect.ShadersStore.standardVertexShader = LEGACYSHELLSTANDARDVERTEXSHADER;
BABYLON.Effect.ShadersStore.standardPixelShader = LEGACYSHELLSTANDARDPIXELSHADER;

// [LS] ######## Items ---------------------------------
//  ___ _____ ___ __  __ ___
// |_ _|_   _| __|  \/  / __|
//  | |  | | | _|| |\/| \__ \
// |___| |_| |___|_|  |_|___/
var Items = [
    ...LEGACYSHELLITEMS
];


// [LS] ######## Maps ---------------------------------
//  __  __   _   ___  ___
// |  \/  | /_\ | _ \/ __|
// | |\/| |/ _ \|  _/\__ \
// |_|  |_/_/ \_\_|  |___/
minMaps = LEGACYSHELLMINMAPS;


// [LS] ######## Bullshit ---------------------------------
//  ___ _   _ _    _    ___ _  _ ___ _____
// | _ ) | | | |  | |  / __| || |_ _|_   _|
// | _ \ |_| | |__| |__\__ \ __ || |  | |
// |___/\___/|____|____|___/_||_|___| |_|

//Q: What is "bullshit"?
//A: Defining of these small, weird, misc dicts/lists/funcs.

LEGACYSHELLCONSTANTS

LEGACYSHELLPICKUPS

LEGACYSHELLGAMETYPES


// [LS] ######## Apollo ---------------------------------
//
//     e Y8b                        888 888           
//    d8b Y8b    888 88e   e88 88e  888 888  e88 88e  
//   d888b Y8b   888 888b d888 888b 888 888 d888 888b 
//  d888888888b  888 888P Y888 888P 888 888 Y888 888P 
// d8888888b Y8b 888 88"   "88 88"  888 888  "88 88"  
//               888                                  
//               888                                  

LEGACYSHELLAPOLLO


var interval = new IntervalManagerConstructor();
var timeout = new TimeoutManagerConstructor();

var fancyShadows = false;
var enableBulletHoles = false;
var disableBulletSmoke = false;

var skybox;
var skyboxMaterial;

var engine;
var camera;
var customizer;
var itemRenderer;
var stampTexture;
var canvas;
var shadowGen;
var engineCaps;
var ws;
var selectedServer;
var meId;
var isGameOwner;
var viewingPlayerId;
var myTeam;
var nickname;
var gameStartTime;
var pingTotal;
var pingSamples;
var fpsTotal;
var fpsSamples;
var gameId;
var gameKey;
var mapIdx;
var gameType;
var gameOptions;
var privateGame;
var currentMapPool = [];
/*var firebaseUi,*/;
var user;
var timesPlayed;
var chatInEl;
var chatOutEl;
var killEl;
var statsEl;
var purchasingEnabled;
var lastVer;
var globalXsollaToken;
var joinType;
var inputToControlMap;
var optimizer;
var inGame = false;
var playOffline = false;
var mapTest = {};
var settings = {};
var nameTestCanvas = document.createElement("canvas");
var freezeFrame = false;
var highestPing = 0;
var playerAccount = {};
var testing = false;
var teamSummaryEls = [];
var loggingIn = false;
var noSkybox = false;
var linkItemShown = false;
var showTaggedItems = null;
var showNugget = null;
var authAttemptComplete = false;
var checkedForReward = false;
var isRunning = false;
var autoInvite = false;
var servicesToken = null;
var isGettingNugget = false;
var adBlock = false; //pretty sure off is better, although idk
var playerLimit = 18;
var myPingLevel = getPingLevel(0);

var alertBarInterval, joinResult = null;

var shake;
var controlEl;
var feedbackValidateTimeout;
var settingsKeyNames = ["up", "down", "left", "right", "jump", "fire", "scope", "reload", "weapon", "grenade", "unfocus"];
var settingsKeyCells = {};
var lastMouseMovement = {};

var reward = null;
var debugArray = [];
var debugObject = {};
var consent = void 0;

var bigAdIdx;
var smallAdIdx;
var aipPrerollPlayer;
var houseAds;
var adTest = false;
var houseAdsLoaded = false;
var applixirAdWatched = false;

if ("undefined" == typeof window) var fs = require("fs");
var bigAdTimeout;

var tv1 = new BABYLON.Vector3;
var tv2 = new BABYLON.Vector3;

var bulletHoleManager;
var explosionSmokeManager;
var explosionFireManager;
var shellFragManager;

var rainParticleSystem;
var rainSound;
var wetMaterial;

var respawnTime;
var uiCamera;
var grenadePowerUp;
var chatting;
var mapOverview;
var scope;
var reticle;
var hitIndicator;
var lastTimeStamp;
var fpsAverage;
var escPressed;
var kills;
var deaths;
var bestOverallStreak;

var timedGame;
var roundLength;
var roundEndTime;
var roundRestartTime;
var betweenRounds;

var respawnInterval;
var oldClockSeconds;
var gameScene;
var shadowLight;
var me;
var viewingPlayer;
var grenadeThrowPower;
var players;
var nameTexture;
var nameSprites;
var mapMesh;
var gameCode;
var munitionsManager;
var itemManager;
var Sounds = {};
var Music = {};
var mapOverviewAxis = 0;

var SPS;
var chatParser = document.createElement("DIV");
var prevCmd = [];
var pingStartTime;
var rotInc = Math.PI / 2;
var debugWindow;
var lastKey = null;

var previousChats = [];
var previousChatsIdx = -1;
var currentChat = "";

var lastLeadingTeam = 1;

var waitIteration = 0;

//tbh idk when this is used, if at all :joe_shrug:
String.prototype.format = String.prototype.f = function () {
    for (var s = this, i = arguments.length; i--;) s = s.replace(new RegExp("\\{" + i + "\\}", "gm"), arguments[i]);
    return s;
};

// [LS] ######## Permissions ---------------------------------


LEGACYSHELLPERMISSIONS
var perm = new PermissionsConstructor();

// [LS] ######## Comms ---------------------------------
//   ___ ___  __  __ __  __ ___
//  / __/ _ \|  \/  |  \/  / __|
// | (_| (_) | |\/| | |\/| \__ \
//  \___\___/|_|  |_|_|  |_|___/

LEGACYSHELLCOMM

function doThunderStrike() {
    var idx = 0;
    var fpsinterval = 1e3 / fps;

    function setDynamics(percent) {
        gameScene.fogColor = new BABYLON.Color4(1, 1, 1, 1); //white
        gameScene.fogDensity = Math.max(.5 - percent, 0);
        mapMesh.overlayAlpha = Math.max(.5 - percent, 0);
        skyboxMaterial.alpha = percent;
    };

    var stormInterval = interval.set(function() {
        idx++;
        setDynamics(Math.sin(idx / 6));

        if (idx == 10) playSoundIndependent2D("thunder");

        if (idx > 14) {
            interval.clear(stormInterval);
            idx = 0;
            var stormInterval2 = interval.set(function() {
                var percent = idx/50;
                skyboxMaterial.alpha = 1 - percent;

                var fogColor = 1 - Math.min(percent * 10, 1);
                gameScene.fogColor = new BABYLON.Color4(fogColor, fogColor, fogColor, 1);
                gameScene.fogDensity = .25 * percent;

                var overlayColor = 1 - Math.min(percent * 2, 1);
                gameScene.overlayColor = new BABYLON.Color4(overlayColor, overlayColor, overlayColor, 1);
                gameScene.overlayAlpha = 1 - percent;

                // devlog(gameScene.fogDensity, "percent", percent, "fogColor", fogColor, "overlayColor", overlayColor, "overlayAlpha", gameScene.overlayAlpha);

                if (idx >= 50) {
                    interval.clear(stormInterval2);
                };
                idx++;
            }, fpsinterval);
        };
    }, fpsinterval);

    skybox.rotation.y = Math.PI2 * 2 * Math.random();
};

//receiving msgs
const LegacyShellOnMessage = async function (msg) {
    var input = new Comm.In(msg.data);
    while (input.isMoreDataAvailable()) {
        var cmd = input.unPackInt8U();
        if (cmd !== Comm.Code.sync && cmd !== Comm.Code.syncData && cmd !== Comm.Code.ping) devlog("received cmd: ", Comm.Convert(cmd), msg);
        switch (cmd) {
            case Comm.Code.updateRoomParams:
                var roomParams = input.unPackString();
                var roomParamsObj = JSON.parse(roomParams);
                devlog("updateRoomParams", roomParamsObj);

                if (roomParamsObj.cheatsEnabled) {
                    document.getElementById("cheatsEnabled").style.display = "block";
                } else {
                    document.getElementById("cheatsEnabled").style.display = "none";
                };

                // if (roomParamsObj.time !== gameOptions.time) {
                // };

                switch (roomParamsObj.time) {
                    case "night":
                        skyboxMaterial.alpha = 0.1;
                        
                        gameScene.fogColor = new BABYLON.Color4(0, 0, 0, 1);
                        gameScene.fogDensity = .065;
                        
                        mapMesh.overlayAlpha = 0.5;
                        mapMesh.overlayColor = {r: 0, g: 0, b: 0};
                        mapMesh.renderOverlay = true;
                        break;
                    default:
                        skyboxMaterial.alpha = 1;

                        setFog();

                        mapMesh.overlayAlpha = 0;
                        mapMesh.renderOverlay = false;
                        break;
                };
                
                // if (roomParamsObj.weather.rainEnabled !== gameOptions.weather.rainEnabled) {
                // };

                if (roomParamsObj.weather.rainEnabled) {
                    rainParticleSystem.start();
                    if (!rainSound) rainSound = playSoundIndependent2D("rain", {vol: 0.75, loop: true});
                    mapMesh.material = wetMaterial;
                    me.weapons[0].actor.gunMesh.material = wetMaterial;
                    me.weapons[1].actor.gunMesh.material = wetMaterial;
                    me.actor.hands.material = wetMaterial;
                } else {
                    rainParticleSystem.stop();
                    if (rainSound) {
                        rainSound.stop();
                        rainSound = null;
                    };
                    var materialName = gameScene.shadowsEnabled ? "map" : "mapNoShadows";
                    mapMesh.material = gameScene.getMaterialByName(materialName);
                    me.weapons[0].actor.gunMesh.material = gameScene.getMaterialByName("standard");
                    me.weapons[1].actor.gunMesh.material = gameScene.getMaterialByName("standard");
                    me.actor.hands.material = gameScene.getMaterialByName("standard");
                };

                // if (roomParamsObj.weather.stormEnabled !== gameOptions.weather.stormEnabled) {
                // };
                if (roomParamsObj.weather.stormEnabled) {
                    setSkybox("thunderstorm");
                    skyboxMaterial.alpha = 0;

                    mapMesh.overlayAlpha = 0.5;
                    mapMesh.overlayColor = {r: 0, g: 0, b: 0};
                    
                    gameScene.fogColor = new BABYLON.Color4(0, 0, 0, 1);
                    gameScene.fogDensity = .25;
                } else {
                    var skyboxName = minMap.skybox || "default";
                    setSkybox(skyboxName);
                    setFog();
                };

                Object.assign(gameOptions, roomParamsObj);
                break;
            case Comm.Code.heal:
                var playerId = input.unPackInt8U();
                var hp = input.unPackInt8U();
                var player = players[playerId];

                player && player.setHp(hp, playerId);

                if (playerId == meId) {
                    triggerHealAnimation();
                };
                break;
            case Comm.Code.pause:
                var playerId = input.unPackInt8U();

                var player = players[playerId];
                player && player.removeFromPlay();
                break;
            case Comm.Code.roundEnd: //round has ended
                console.log("END ROUND");
                prepareGameSummary();
                betweenRounds = true;
                document.getElementById("help").style.display = "none";
                document.getElementById("tipContainer").style.display = "block";
                document.getElementById("goButton").className = "ssbutton grey";
                document.getElementById("goButtonLabel").innerText = "Wait...";
                //Sounds.endRound.play();
                playSoundIndependent2D("endRound");
                timeout.set(showContinueDialog, 3e3);
                setRespawnTime(NextRoundTimeout);
                break;
            case Comm.Code.roundStart: //round has started
                console.log("START ROUND");
                betweenRounds = false;
                document.getElementById("gameClock").style.display = "block";
                document.getElementById("gameClock").style.fontSize = "2em";
                document.getElementById("bestStreak").style.display = "none";
                roundEndTime = Date.now() + (roundLength * 1e3);
                break;
            case Comm.Code.roundUpdate:
                roundLength = input.unPackInt16U(); //length of the round (in seconds)
                roundEndTime = input.unPackInt32U(); //time to end the round (in ms)
                roundRestartTime = input.unPackInt32U(); //time to wait before next round starts (in ms)

                console.log("roundLength", roundLength, "roundEndTime", roundEndTime, "roundRestartTime", roundRestartTime);

                if (roundLength > 0) {
                    timedGame = true;
                    if (roundEndTime > 0) { //if roundEndTime is 0, then the game is over and we are waiting for the next game to start
                        document.getElementById("gameClock").style.display = "block";
                        document.getElementById("bestStreak").style.display = "none";
                        roundEndTime += Date.now();
                    } else if (roundRestartTime > 0) { //if roundEndTime is 0, then the game is over and we are waiting for the next game to start
                        document.getElementById("gameClock").style.display = "none";
                        document.getElementById("goButton").className = "ssbutton grey";
                        document.getElementById("goButtonLabel").innerText = "Wait...";
                        document.getElementById("playerList").style.display = "none";
                        setRespawnTime(Math.floor(roundRestartTime / 1000));
                    } else { //if roundEndTime is 0, then the game is over and we are waiting for the next game to start (wait for roundStart commcode)
                        respawnTime = -1;
                    };
                } else {
                    if (timedGame) {
                        console.log("timedGame disabled");
                    } else {
                        respawnTime = -1;
                    };
                    timedGame = false;
                    document.getElementById("gameClock").style.display = "none";
                    document.getElementById("gameClock").style.fontSize = "2em";
                    document.getElementById("bestStreak").style.display = "block";
                };
                break;
            case Comm.Code.clientReady:
                console.log("Comm.Code.clientReady received");
                openGameMenu();
                startRendering();
                if (autoInvite) {
                    inviteFriends();
                };
                break;
            case Comm.Code.doThunderStrike:
                doThunderStrike();
                break;
            case Comm.Code.addPlayer:
                var id = input.unPackInt8U();
                var uniqueId = input.unPackInt32U();
                var name = input.unPackString();
                var classIdx = input.unPackInt8U();
                var username = input.unPackString();

                devlog("addPlayer", id, uniqueId, name, classIdx);

                17 < id && devlog("playerId out of bounds: " + id + ", " + name);
                var playerData = {
                    id: id,
                    uniqueId: uniqueId,
                    name: name,
                    classIdx: classIdx,
                    username: username,
                    adminRoles: input.unPackInt8U(),
                    team: input.unPackInt8U(),
                    primaryWeaponItem: catalog.findItemBy8BitItemId(ItemType.Primary, classIdx, input.unPackInt8U()),
                    secondaryWeaponItem: catalog.findItemBy8BitItemId(ItemType.Secondary, classIdx, input.unPackInt8U()),
                    shellColor: input.unPackInt8U(),
                    hatItem: catalog.findItemBy8BitItemId(ItemType.Hat, classIdx, input.unPackInt8U()),
                    stampItem: catalog.findItemBy8BitItemId(ItemType.Stamp, classIdx, input.unPackInt8U()),
                    x: input.unPackFloat(),
                    y: input.unPackFloat(),
                    z: input.unPackFloat(),
                    dx: input.unPackFloat(),
                    dy: input.unPackFloat(),
                    dz: input.unPackFloat(),
                    yaw: input.unPackRadU(),
                    pitch: input.unPackRad(),
                    score: input.unPackInt32U(),
                    kills: input.unPackInt16U(),
                    deaths: input.unPackInt16U(),
                    streak: input.unPackInt16U(),
                    totalKills: input.unPackInt32U(),
                    totalDeaths: input.unPackInt32U(),
                    bestGameStreak: input.unPackInt16U(),
                    bestOverallStreak: input.unPackInt16U(),
                    shield: input.unPackInt8U(),
                    hp: input.unPackInt8U(),
                    playing: input.unPackInt8U(),
                    weaponIdx: input.unPackInt8U(),
                    controlKeys: input.unPackInt8U(),
                    randomSeed: input.unPackInt16U(),
                    upgradeProductId: input.unPackInt8U()
                };
                if (!players[playerData.id]) {
                    if (meId === playerData.id) {
                        //do nothing for the me player
                    } else {
                        playerData.name = playerData.name.replace(/<|>/g, "");
                        if (playerData.name.length === 0) {
                            playerData.name = "Anonymous";
                        } else {
                            playerData.name = fixStringWidth(playerData.name);
                            if (censor.detect(playerData.name)) {
                                playerData.name = randomName();
                            };
                        };
                    };
                    addPlayer(playerData);
                };
                break;
            case Comm.Code.removePlayer:
                var playerId = input.unPackInt8U();
                removePlayer(playerId);
                break;
            case Comm.Code.spawnItem:
                var id = input.unPackInt16U();
                var kind = input.unPackInt8U();
                var x = input.unPackInt16() / 2;
                var y = input.unPackInt16() / 10;
                var z = input.unPackInt16() / 2;
                itemManager.spawnItem(id, kind, x, y, z);
                break;
            case Comm.Code.collectItem:
                var playerId = input.unPackInt8U();
                var kind = input.unPackInt8U();
                var applyToWeaponIdx = input.unPackInt8U();
                var id = input.unPackInt16U();

                itemManager.collectItem(kind, id);
                playerId == meId && me.collectItem(kind, applyToWeaponIdx);
                break;
            case Comm.Code.die:
                var killedPlayerName;
                var byPlayerName;

                var killedId = input.unPackInt8U();
                var byId = input.unPackInt8U();
                var rs = input.unPackInt8U();

                var killedPlayer = players[killedId];
                var byPlayer = players[byId];

                if (killedPlayer) {
                    killedPlayerName = killedPlayer.name;
                    var pos = new BABYLON.Vector3(killedPlayer.x, killedPlayer.y + (0.32 * killedPlayer.scale), killedPlayer.z);
                    playSoundIndependent("shellBurst", {pos, rate: killedPlayer.actor.playbackRate});
                    //killedPlayer.actor.deathSound.setPosition(pos);
                    //killedPlayer.actor.deathSound.setPlaybackRate(killedPlayer.actor.playbackRate);
                    //killedPlayer.actor.deathSound.play();

                    //TODO: dynamic? no Care? works for now...
                    var soundIdx = Math.randomInt(0, 11);
                    //Sounds.death[soundIdx].setPosition(pos);
                    //Sounds.death[soundIdx].setPlaybackRate(killedPlayer.actor.playbackRate);
                    //Sounds.death[soundIdx].play();
                    //playSoundIndependent("death.scream."+soundIdx, {pos, rate: killedPlayer.actor.playbackRate});
                    playSoundIndependent("death.scream", {pos, rate: killedPlayer.actor.playbackRate});

                    shellFragBurst(killedPlayer, 80, .2, 40);
                    yolkBurst(killedPlayer);
                    killedPlayer.die();
                    killedPlayer.actor.mesh.position.x = killedPlayer.x;
                    killedPlayer.actor.mesh.position.y = killedPlayer.y;
                    killedPlayer.actor.mesh.position.z = killedPlayer.z;
                } else killedPlayerName = "N/A";

                if (byPlayer) {
                    if (byPlayerName = byPlayer.name, !byPlayer.isDead()) {
                        byPlayer.scoreKill();
                        if (byId == meId) {
                            var el = document.getElementById("bestStreak");
                            el.innerText = "BEST STREAK: " + byPlayer.bestOverallStreak
                        }
                        byId == meId && (kills++, bestOverallStreak = Math.max(bestOverallStreak, byPlayer.streak))
                    }
                } else byPlayerName = "N/A";
                if (killedId != meId) {
                    if (byId == meId) {
                        var killBox = document.getElementById("killBox");
                        killBox.style.display = "block", document.getElementById("KILLED_NAME").innerText = killedPlayerName;
                        var streakEl = document.getElementById("KILL_STREAK");
                        1 < me.streak ? streakEl.innerText = me.streak + "-KILL STREAK" : streakEl.innerText = "";
                        var scale = 1.5,
                            scaleInterval = interval.set(function () {
                                killBox.style.transform = "scale(" + scale + "," + scale + ")", (scale -= .05) <= 1 && (scale = 1, interval.clear(scaleInterval))
                            }, 33);
                        timeout.set(function () {
                            inGame && (killBox.style.display = "none")
                        }, 4e3)
                    }
                } else {
                    camera.parent = null, camera.position = new BABYLON.Vector3(viewingPlayer.actor.mesh.position.x, viewingPlayer.actor.mesh.position.y + .2, viewingPlayer.actor.mesh.position.z), byPlayer && (camera.lockedTarget = byPlayer.actor.bodyMesh), document.getElementById("KILLED_BY_NAME").innerText = byPlayerName;
                    var deathBox = document.getElementById("deathBox");
                    deathBox.style.display = "block";
                    var scale = 2,
                        scaleInterval = interval.set(function () {
                            deathBox.style.transform = "scale(" + scale + "," + scale + ")", (scale -= .05) <= 1 && inGame && (interval.clear(scaleInterval), scale = 1)
                        }, 33);
                    deaths++, setRespawnTime(rs), removeCanvasListeners(), timeout.set(function () {
                        inGame && (deathBox.style.display = "none", viewingPlayerId == meId && openGameMenu())
                    }, 3e3)
                }
                byPlayer && killedPlayer && addKillText(byPlayer, killedPlayer), rebuildPlayerList();
                break;
            case Comm.Code.chat:
                var chatType = input.unPackInt8U();
                var playerId = input.unPackInt8U();
                var text = input.unPackString();
                var player = players[playerId];

                devlog(playerId, chatType, text);
                var serverMsg = playerId > 250;

                if (serverMsg || !player.muted) {
                    chatParser.innerHTML = text;
                    text = chatParser.textContent.trim();
                    if ((player || serverMsg) && 0 < text.length && !censor.detect(text, settings.enable18Chat) && text.indexOf("<") < 0) {
                        addChat(text, player, chatType);
                    };
                };
                break;
            case Comm.Code.jump:
                var id = input.unPackInt8U(),
                    player = players[id];
                if (!player) break;
                player.jump();
                break;
            case Comm.Code.syncData:
                var id = input.unPackInt8U();
                var hp = input.unPackFloat();

                var player = players[id];

                if (player) {
                    player.setHp(hp, id);
                    // console.log("syncData", id, hp);
                };

                break;
            case Comm.Code.sync:
                var id = input.unPackInt8U();
                var stateIdx = input.unPackInt8U();
                var x = input.unPackFloat();
                var y = input.unPackFloat();
                var z = input.unPackFloat();
                var dx = input.unPackFloat();
                var dy = input.unPackFloat();
                var dz = input.unPackFloat();
                var climbing = input.unPackInt8U();
                var pingLevelInt = input.unPackInt8U();
                var player = players[id];

                //discarded so that it doesnt mess up the next packets.
                if (!player) {
                    for (var i = 0; i < FramesBetweenSyncs; i++) {
                        input.unPackInt8U();
                        input.unPackRadU();
                        input.unPackRad();
                    };
                    break
                };

                plugins.emit('inGameSync1', { id, stateIdx, x, y, z, dx, dy, dz, climbing, pingLevelInt });

                var oldx = player.x;
                var oldy = player.y;
                var oldz = player.z;
                var olddx = player.dx;
                var olddy = player.dy;
                var olddz = player.dz;
                var oldYaw = player.yaw;
                var oldPitch = player.pitch;
                var wasJumping = player.jumping;
                var wasClimbing = player.climbing;
                var oldPingLevelInt = player?.pingLevel?.int || 0;
                player.pingLevel = PingIndicators[pingLevelInt];

                // devlog(player.id, "ping level: old", oldPingLevelInt, "new", pingLevelInt)

                if (id == meId) {
                    for (var i = 0; i < FramesBetweenSyncs; i++) {
                        //discarded so that it doesnt mess up the next packets.
                        input.unPackInt8U();
                        input.unPackRadU();
                        input.unPackRad();
                    };
                    var i = stateIdx;
                    var state = player.stateBuffer[i];

                    // devlog("received stateidx:", i, player.stateIdx);

                    if (Math.abs(player.x - x) > minimumForCorrection) player.x = x;
                    if (Math.abs(player.y - y) > minimumForCorrection) player.y = y;
                    if (Math.abs(player.z - z) > minimumForCorrection) player.z = z;

                    player.dx = state.dx;
                    player.dy = state.dy;
                    player.dz = state.dz;
                    player.climbing = state.climbing;
                    player.jumping = state.jumping;

                    let oldKeys = me.controlKeys;

                    //this code is weird...
                    let is = [];

                    //what this does is it tries to catch up? i think?
                    while (i !== player.stateIdx) {
                        i = (i + 1) % stateBufferSize;

                        // is.push(i);

                        state = player.stateBuffer[i];
                        player.controlKeys = state.controlKeys;
                        player.yaw = state.yaw;
                        state.jump && player.jump();
                        player.update(state.delta, true);
                        player.stateBuffer[i].x = player.x;
                        player.stateBuffer[i].y = player.y;
                        player.stateBuffer[i].z = player.z;
                        player.stateBuffer[i].dx = player.dx;
                        player.stateBuffer[i].dy = player.dy;
                        player.stateBuffer[i].dz = player.dz;
                        player.stateBuffer[i].jumping = player.jumping;
                    };

                    // devlog(is);

                    var dist = Math.length3(player.x - oldx, player.y - oldy, player.z - oldz);
                    if (dist < .2) {
                        if (.02 < dist) {
                            player.corrections = FramesBetweenSyncs;
                            player.corrected.dx = player.x - oldx;
                            player.corrected.dy = player.y - oldy;
                            player.corrected.dz = player.z - oldz;
                        };
                        player.x = oldx;
                        player.y = oldy;
                        player.z = oldz;
                        player.dx = olddx;
                        player.dy = olddy;
                        player.dz = olddz;
                    } else {
                        player.corrections = 0
                    };

                    player.jumping = wasJumping;
                    player.climbing = wasClimbing;
                    if (wasJumping) {
                        player.corrected.dy = 0;
                        player.y = oldy;
                        player.dy = olddy;
                    };

                    player.yaw = oldYaw;
                    player.pitch = oldPitch;
                    player.controlKeys = oldKeys;

                    await plugins.emit('inGameSync2', { id, stateIdx, x, y, z, dx, dy, dz, climbing, pingLevelInt, dist, player });
                } else {
                    // devlog("other player, received:", stateIdx, player.stateIdx);

                    // player.stateIdx = stateIdx;

                    player.stateIdx = 0 // ??????

                    // let is = [];

                    for (var i = 0; i < FramesBetweenSyncs; i++) {
                        let idx = i; //Math.mod(player.stateIdx + i, stateBufferSize);

                        player.stateBuffer[idx].controlKeys = input.unPackInt8U();
                        player.stateBuffer[idx].yaw = input.unPackRadU();
                        player.stateBuffer[idx].pitch = input.unPackRad();

                        // is.push([i, idx, player.stateBuffer[idx].controlKeys, player.stateBuffer[idx].yaw, player.stateBuffer[idx].pitch])
                    };

                    // devlog(is);

                    player.x = x;
                    if (!player.jumping) {
                        player.y = y;
                    };
                    player.z = z;

                    player.dx = dx;
                    player.dy = dy;
                    player.dz = dz;

                    player.climbing = climbing;

                    await plugins.emit('inGameSync3', { id, stateIdx, x, y, z, dx, dy, dz, climbing, pingLevelInt, player });
                };

                if (pingLevelInt !== oldPingLevelInt) rebuildPlayerList();
                // devlog("(end sync)", player.name, id, player.stateIdx);
                break;
            case Comm.Code.fire:
                var id = input.unPackInt8U();

                tv1.x = input.unPackFloat();
                tv1.y = input.unPackFloat();
                tv1.z = input.unPackFloat();
                tv2.x = input.unPackFloat();
                tv2.y = input.unPackFloat();
                tv2.z = input.unPackFloat();

                var seed = input.unPackInt8U();

                var player = players[id];
                if (!player) break;
                if (id != meId) player.weapon.actor.fire();

                Math.seed = seed;
                player.weapon.fireMunitions(tv1, tv2);
                break;
            case Comm.Code.throwGrenade:
                var id = input.unPackInt8U(),
                    x = input.unPackFloat(),
                    y = input.unPackFloat(),
                    z = input.unPackFloat(),
                    dx = input.unPackFloat(),
                    dy = input.unPackFloat(),
                    dz = input.unPackFloat(),
                    player = players[id];
                if (!player) break;
                player.grenadeCount--;
                if (id != meId) {
                    player.actor.head.rotation.x = player.pitch;
                    player.actor.mesh.rotation.y = player.yaw;
                } else updateAmmoUi();

                player.actor.throwGrenade();
                munitionsManager.throwGrenade(player, {
                    x: x,
                    y: y,
                    z: z
                }, {
                    x: dx,
                    y: dy,
                    z: dz
                });
                break;
            case Comm.Code.reload:
                var id = input.unPackInt8U();
                if (id == meId) {
                    var rounds = input.unPackInt8U();
                    var store = input.unPackInt8U();
                    var roundsToReload = input.unPackInt8U();

                    // devlog("reloading me", me.weapon.ammo.rounds, me.weapon.ammo.store, rounds, store, roundsToReload);

                    me.weapon.ammo.rounds = rounds;
                    me.weapon.ammo.store  = store;
                    me.roundsToReload  = roundsToReload;

                    updateAmmoUi();
                } else {
                    players[id] && players[id].reload();
                };
                break;
            case Comm.Code.swapWeapon:
                var id = input.unPackInt8U(),
                    weaponIdx = input.unPackInt8U();
                players[id] && players[id].swapWeapon(weaponIdx);
                break;
            case Comm.Code.hitMe:
                var hp = input.unPackInt8U();
                var dx = input.unPackFloat();
                var dz = input.unPackFloat();
                me.hp = hp;
                me.actor.hit();
                hitIndicator.hit(dx, dz);
                break;
            case Comm.Code.hitThem:
                var id = input.unPackInt8U();
                var hp = input.unPackInt8U();
                var player = players[id];
                if (!player) break;
                player.hp = hp;
                player.actor.hit();
                0 < hp && shellFragBurst(player, 30, .07, 20);
                break;
            case Comm.Code.respawn:
                var id = input.unPackInt8U();
                var x = input.unPackFloat();
                var y = input.unPackFloat();
                var z = input.unPackFloat();
                var yaw = input.unPackRadU();
                var pitch = input.unPackRad();
                var player = players[id];

                if (player) {
                    player.respawn({x, y, z, yaw, pitch});
                    if (id == meId) console.log("Comm.Code.respawn received from server for this player")
                };
                break;
            case Comm.Code.changeCharacter:
                var id = input.unPackInt8U();
                var classIdx = input.unPackInt8U();
                var primaryWeaponIdx = input.unPackInt8U();
                var secondaryWeaponIdx = input.unPackInt8U();
                var shellColor = input.unPackInt8U();
                var hatIdx = input.unPackInt8U();
                var stampIdx = input.unPackInt8U();
                var primaryWeaponItem = catalog.findItemBy8BitItemId(ItemType.Primary, classIdx, primaryWeaponIdx);
                var secondaryWeaponItem = catalog.findItemBy8BitItemId(ItemType.Secondary, classIdx, secondaryWeaponIdx);
                var hatItem = catalog.findItemBy8BitItemId(ItemType.Hat, classIdx, hatIdx);
                var stampItem = catalog.findItemBy8BitItemId(ItemType.Stamp, classIdx, stampIdx);
                var player = players[id];

                devlog({classIdx, primaryWeaponItem, secondaryWeaponItem, shellColor, hatIdx, hatItem, stampIdx, stampItem})

                player && player.changeCharacter(classIdx, primaryWeaponItem, secondaryWeaponItem, shellColor, hatItem, stampItem);
                break;
            case Comm.Code.switchTeam:
                var id = input.unPackInt8U();
                var toTeam = input.unPackInt8U();
                var player = players[id];

                if (player) {
                    if (id == meId) {
                        myTeam = toTeam;
                        setTeamButton();
                    };
                    player.switchTeam(toTeam);
                };
                break;
            case Comm.Code.switchTeamFail:
                openAlertDialog(getLocText("ui_game_fairteams_header"), getLocText("ui_game_fairteams_text"), {
                    label: "OK",
                    width: "8em"
                });
                break;
            case Comm.Code.ping:
                ping = Date.now() - pingStartTime, pingTotal += ping, pingSamples++;
                var el = document.getElementById("ping");

                myPingLevel = getPingLevel(ping);
                el.style.color = myPingLevel.color;

                el.innerText = ping + "ms";
                setTimeout(function () {
                    var output = new Comm.Out(2);
                    output.packInt8U(Comm.Code.ping);
                    // console.log(myPingLevel, myPingLevel?.int || 0)
                    output.packInt8U(myPingLevel?.int || 0);
                    pingStartTime = Date.now();
                    if (ws) {
                        wsSend(output, "ping");
                    };
                }, 1e3); //every second
                break;
            case Comm.Code.notification:
                notify(input.unPackString(), 1e3 * input.unPackInt8U());
                break;
            case Comm.Code.gameLocked:
                notify(getLocText("ui_game_locked"), 1e4);
                break;
            case Comm.Code.updateBalance:
                var newBalance = input.unPackInt32U();
                console.log("updating balance from server: " + newBalance);
                playerAccount.currentBalance = newBalance;
                updateCurrentBalance();
                break;
            case Comm.Code.expireUpgrade:
                console.log("upgrade has expired");
                checkUpgrade();
                break;
            case Comm.Code.setGameOwner:
                var id = input.unPackInt8U();
                var player = players[id];

                players.forEach((player)=>{
                    player.isGameOwner = player.id === id;
                });
                isGameOwner = id === meId;
                rebuildPlayerList();
                break;
            case Comm.Code.warp:
                var joinGameId = input.unPackString();
                // devlog("received warp: "+joinGameId);

                const joinGameWithFocus = () => {
                    joinGame(joinGameId);
                    window.removeEventListener('focus', joinGameWithFocus);
                };

                if (document.hasFocus()) {
                    joinGame(joinGameId);
                } else {
                    window.addEventListener('focus', joinGameWithFocus);
                };
                break;
            case Comm.Code.setModifiers:
                var id = input.unPackInt8U();
                var player = players[id];

                var modifiers = {
                    //unsigned
                    scale: input.unPackInt8U() / 10,
                    //signed
                    regenModifier: input.unPackInt8() / 10,
                    speedModifier: input.unPackInt8() / 10,
                    gravityModifier: input.unPackInt8() / 10,
                    damageModifier: input.unPackInt8() / 10,
                    resistanceModifier: input.unPackInt8() / 10,
                    jumpBoostModifier: input.unPackInt8() / 10,
                };

                if (player) {
                    player.changeModifiers(modifiers);
                };
                break;
            default:
                console.log("Comm.Code error: " + cmd + "/" + String.fromCharCode(cmd) + " - previous cmd: " + JSON.stringify(prevCmd))
        };
        prevCmd.push(cmd), 4 < prevCmd.length && prevCmd.shift();
    };
};

// [LS] ######## Catalog ---------------------------------
//   ___   _ _____ _   _    ___   ___
//  / __| /_\_   _/_\ | |  / _ \ / __|
// | (__ / _ \| |/ _ \| |_| (_) | (_ |
//  \___/_/ \_\_/_/ \_\____\___/ \___|

LEGACYSHELLCATALOG

var catalog = new CatalogConstructor(Items);

// [LS] Customizer CONSTRUCTOR
function Customizer(callback) {
    this.isReady = false, this.camX = 0, this.camY = .4, this.camRadius = 3.4, this.rotY = 0, this.rotX = 0, this.jump = 0, this.turnCountdown = 60, this.selectedItem = 0, this.buyingItem = null, this.currentPickedItem = null, this.currentRenderFunc = null, this.currentHighlightFunc = null, this.currentSelectByIndexFunc = null, this.currentSelectByItemFunc = null, this.setupScene(), this.setupItems(), this.setupWeaponStats();
    var outer = this;
    loadResources(this.scene, function () {
        outer.onResourcesLoaded(), outer.isReady = true, callback && callback()
    });
};
Customizer.prototype.onResourcesLoaded = function () {
    var outer = this;
    console.log("customizer created, starting renderering"), this.startRendering();
    try {
        var meshName = playerAccount.getPrimaryWeapon().item_data.meshName;
        this.avatar = new function (c) {
            this.scene = outer.scene;
            this.id = -1;
            this.name = "";
            this.x = 0;
            this.y = 0;
            this.z = 0, this.hp = 100, this.hatItem = playerAccount.hatItem, this.stampItem = playerAccount.stampItem, this.shellColor = playerAccount.colorIdx, this.actor = new PlayerActor(this), this.actor.mesh.rotation.y = outer.rotY, this.weapon = new classes[c].weapon(this, meshName), this.weapon.actor.equip()
        }(playerAccount.classIdx), console.log("avatar created: " + this.avatar);
        var lastNow = Date.now();
        this.scene.registerBeforeRender(function () {
            var now = Date.now(),
                delta = now - lastNow;
            lastNow = now, delta /= 17, outer.update(delta)
        })
    } catch (e) {
        console.log(e)
    }
};
Customizer.prototype.startRendering = function () {
    var outer = this;
    engine.runRenderLoop(function () {
        outer.scene.render()
    })
};
Customizer.prototype.update = function (delta) {
    if (this.avatar.actor.handsToWeaponSkeleton(), this.camera.target.x += (this.camX - this.camera.target.x) / 5, this.camera.target.y += (this.camY - this.camera.target.y) / 5, this.camera.radius += (this.camRadius - this.camera.radius) / 5, this.avatar.actor.head.rotation.x += (this.rotX - this.avatar.actor.head.rotation.x) / 5, this.avatar.actor.mesh.rotation.y += (this.rotY - this.avatar.actor.mesh.rotation.y) / 5, this.avatar.actor.mesh.rotation.x = .5 * this.avatar.actor.head.rotation.x, this.avatar.actor.mesh.position.x = .1 * -this.avatar.actor.mesh.rotation.y, this.avatar.actor.mesh.position.y += delta * this.jump, this.jump -= .002 * delta, this.avatar.actor.mesh.position.y = Math.max(0, this.avatar.actor.mesh.position.y + this.jump * delta), this.turnCountdown -= delta, this.turnCountdown <= 0) {
        var rx = .6 * Math.random() - .4,
            ry = 2 * Math.random() - 1 + .5 * this.camX,
            d = Math.length2(rx - this.rotX, ry - this.rotY);
        this.rotX = rx, this.rotY = ry, this.jump = Math.min(.01, d / 100), this.turnCountdown = 90 * Math.random() + 30
    }
};
Customizer.prototype.open = function () {
    menuIn("customizationMenu"), document.getElementById("customizeButton").style.display = "none", document.getElementById("customizerBackButton").style.display = "inline", document.getElementById("customizerClassSelectorContainer").appendChild(document.getElementById("classSelector")), document.getElementById("redeemCodeButton").style.display = playerAccount.session ? "inline" : "none", this.camX = .39, this.camY = .3, this.camRadius = 3.4, this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.initHatButton(), this.initStampButton()
};
Customizer.prototype.openToItem = function (item) {
    switch (item.item_type_id) {
        case ItemType.Primary:
            this.openWeaponSelectorToItem(Slot.Primary, item);
            break;
        case ItemType.Secondary:
            this.openWeaponSelectorToItem(Slot.Secondary, item);
            break;
        case ItemType.Hat:
            this.openHatSelectorToItem(item);
            break;
        case ItemType.Stamp:
            this.openStampSelectorToItem(item)
    }
    this.currentSelectByItemFunc(item), item.poseEgg()
};
Customizer.prototype.openToTaggedItems = function (tag) {
    var taggedItems = catalog.getTaggedItems(tag);
    this.openItemSelector("Items: " + tag, taggedItems, null, null, false, false)
};
Customizer.prototype.close = function () {
    playerAccount.syncToServer();
    menuOut("customizationMenu"), document.getElementById("customizerBackButton").style.display = "none", document.getElementById("redeemCodeButton").style.display = "none", document.getElementById("customizeButton").style.display = "inline", document.getElementById("mainMenuClassSelectorContainer").appendChild(document.getElementById("classSelector")), inGame ? (engine.stopRenderLoop(), startRendering(), me.changeCharacter(playerAccount.classIdx, playerAccount.getPrimaryWeapon(), playerAccount.getSecondaryWeapon(), playerAccount.colorIdx, playerAccount.hatItem, playerAccount.stampItem, 0, 0), chatting && chatInEl.focus(), showBannerAdWithPlaceholder("multisizeBannerAdPlaceholder"), loadBannerAd()) : menuIn("mainMenu", function () {
        showBannerAd(), loadBannerAd()
    }), this.camX = 0, this.camY = .4, this.camRadius = 3.4
};
Customizer.prototype.updatePageArrows = function () {
    document.getElementById("itemPageLeft").style.visibility = 0 < this.page ? "visible" : "hidden", document.getElementById("itemPageRight").style.visibility = this.page < this.numItems / this.pageSize - 1 ? "visible" : "hidden";
    var str = "Page " + (this.page + 1) + "/" + Math.ceil(this.numItems / this.pageSize);
    document.getElementById("itemPageCount").innerText = str
};
Customizer.prototype.flipPage = function (dir) {
    this.page += dir, this.currentRenderFunc(), this.updatePageArrows()
};
Customizer.prototype.iteratePage = function (callbackPerItem) {
    for (var start = this.page * this.pageSize, end = Math.min(start + this.pageSize, this.numItems), i = start, b = 0; i < end; i++, b++) callbackPerItem(i, b)
};
Customizer.prototype.renderEmptyButton = function () {
    var i = document.getElementById("noItemImg");
    document.getElementById("item0").getContext("2d").drawImage(i, 0, 0)
};
Customizer.prototype.clearItemButtons = function () {
    for (var i = 0; i < this.pageSize; i++) {
        document.getElementById("item" + i).getContext("2d").clearRect(0, 0, 256, 256)
    }
    this.clearItemLocks()
};
Customizer.prototype.clearItemLocks = function () {
    for (var i = 0; i < this.pageSize; i++) this.setItemLocked(i, false, 0), this.setItemRequiresPhysicalUnlock(i, false)
};
Customizer.prototype.clearHighlight = function () {
    for (var i = 0; i < this.pageSize; i++) document.getElementById("item" + i).className = "itemButton"
};
Customizer.prototype.highlightSelectedIndex = function (listIndex) {
    var start = this.page * this.pageSize,
        end = start + this.pageSize;
    start <= listIndex && listIndex < end && (pageIndex = listIndex % this.pageSize, document.getElementById("item" + pageIndex).className = "itemButtonSelected")
};
Customizer.prototype.isItemPickable = function (item) {
    var requiresPhysicalPurchase = this.doesItemRequirePhysicalUnlock(item);
    return 0 === item.price && !requiresPhysicalPurchase || playerAccount.inventory.includes(item)
};
Customizer.prototype.doesItemRequirePhysicalUnlock = function (item) {
    return void 0 !== item.item_data.unlock && null !== item.item_data.unlock && "physical" === item.item_data.unlock
};
Customizer.prototype.setItemLocked = function (displayIdx, locked, price) {
    document.getElementById("lockedItem" + displayIdx).style.visibility = locked ? "visible" : "hidden", document.getElementById("lockedItemCost" + displayIdx).innerText = price
};
Customizer.prototype.setItemRequiresPhysicalUnlock = function (displayIdx, requiresPhysicalPurchase) {
    document.getElementById("lockedItemPhysical" + displayIdx).style.visibility = requiresPhysicalPurchase ? "visible" : "hidden"
};
Customizer.prototype.boughtItem = function () {
    this.currentPickedItem = this.buyingItem;
    this.currentPickedItem.pick();
    this.currentPickedItem.poseEgg();
    this.buyingItem = null;
    this.currentRenderFunc(this.currentPickedItem);
    menuOut("buyItem");
    menuFlexIn("itemSelectorGrid");
    menuIn("itemSelectorBackButton");
};
Customizer.prototype.buyItemBack = function () {
    null !== this.currentPickedItem ? this.currentPickedItem.poseEgg() : this.buyingItem.takeOffItem(), this.buyingItem = null, this.currentHighlightFunc(), menuOut("buyItem"), menuOut("getMoreEggsLoozer"), menuFlexIn("itemSelectorGrid"), menuIn("itemSelectorBackButton")
};
Customizer.prototype.physicalUnlockBack = function () {
    this.buyItemBack(), menuOut("physicalUnlock")
};
Customizer.prototype.pickColor = function (idx) {
    if (this.avatar && (playerAccount.isUpgraded() || !(7 < idx))) {
        playerAccount.colorIdx = idx;
        for (var ci = 0; ci < shellColors.length; ci++) {
            var colorSelector = document.getElementById("color" + ci);
            ci === playerAccount.colorIdx ? colorSelector.classList.add("selectedColor") : colorSelector.classList.remove("selectedColor")
        }
        this.avatar.actor.setShellColor(playerAccount.colorIdx)
    }
};
Customizer.prototype.pickNextClass = function (dir) {
    var classIdx = Math.mod(playerAccount.classIdx + dir, CharClass.length);
    this.pickClass(classIdx)
};
Customizer.prototype.pickClass = function (classIdx) {
    playerAccount.setClass(classIdx);
    var primaryWeaponItem = playerAccount.getPrimaryWeapon();
    this.poseWithWeapon(primaryWeaponItem), this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.updateWeaponStatsUI()
};
Customizer.prototype.updateWeaponStatsUI = function () {
    if (this.avatar)
        for (var key in document.getElementById("className").innerText = classes[playerAccount.classIdx].name, document.getElementById("classWeapon").innerText = this.avatar.weapon.subClass.weaponName, weaponStats) {
            var pct = (this.avatar.weapon.subClass[key] + weaponStats[key].min) / (weaponStats[key].max - Math.abs(weaponStats[key].min));
            pct = 5.6 - 5.5 * pct, document.getElementById(weaponStats[key].name).style.borderRight = pct + "em solid var(--egg-brown)"
        }
};
Customizer.prototype.dressUpEgg = function () {
    null != playerAccount && void 0 !== this.avatar && null !== this.avatar && (this.pickClass(playerAccount.classIdx), this.poseWithWeapon(playerAccount.getPrimaryWeapon()), this.poseWithHat(playerAccount.hatItem), this.poseWithStamp(playerAccount.stampItem), this.pickColor(playerAccount.colorIdx))
};
Customizer.prototype.initWeaponButton = function (slot) {
    var currentPickedWeaponItem = playerAccount.getPickedWeaponInSlot(slot),
        canvasId = slot === Slot.Primary ? "primarySelectorButton" : "secondarySelectorButton",
        c = document.getElementById(canvasId);
        devlog(currentPickedWeaponItem);
    itemRenderer.renderToCanvas(currentPickedWeaponItem.item_data.meshName, c, this.weaponCam[slot])
};
Customizer.prototype.openWeaponSelector = function (slot) {
    this.openWeaponSelectorToItem(slot, playerAccount.getPickedWeaponInSlot(slot))
};
Customizer.prototype.openWeaponSelectorToItem = function (slot, weaponItem) {
    var weaponList = catalog.forClass[playerAccount.classIdx].forWeaponSlot[slot],
        title = slot === Slot.Primary ? "Primary Weapons" : "Secondary Weapons";
    this.openItemSelector(title, weaponList, weaponItem, false, true)
};
Customizer.prototype.poseWithWeapon = function (weaponItem) {
    this.avatar && (this.avatar.weapon && this.avatar.weapon.actor.dispose(), this.avatar.weapon = weaponItem.instantiateNew(this.avatar), this.avatar.weapon.actor.equip(), this.initWeaponButton(0), this.initWeaponButton(1))
};
Customizer.prototype.initHatButton = function () {
    var c = document.getElementById("hatSelectorButton");
    if (null !== playerAccount.hatItem) itemRenderer.renderToCanvas(playerAccount.hatItem.item_data.meshName, c, this.hatCam);
    else {
        var i = document.getElementById("noHatImg"),
            ctx = c.getContext("2d");
        ctx.clearRect(0, 0, 256, 256), ctx.drawImage(i, 0, 0)
    }
};
Customizer.prototype.openHatSelector = function () {
    this.openHatSelectorToItem(playerAccount.hatItem)
};
Customizer.prototype.openHatSelectorToItem = function (hatItem) {
    this.openItemSelector("Hats", catalog.hats, hatItem, true, true)
};
Customizer.prototype.poseWithHat = function (hatItem) {
    null === hatItem ? this.avatar.actor.removeHat() : this.avatar.actor.wearHat(hatItem)
};
Customizer.prototype.initStampButton = function () {
    var c = document.getElementById("stampSelectorButton");
    if (null !== playerAccount.stampItem) itemRenderer.renderStampToCanvas(playerAccount.stampItem, c);
    else {
        var i = document.getElementById("noStampImg"),
            ctx = c.getContext("2d");
        ctx.clearRect(0, 0, 256, 256), ctx.drawImage(i, 0, 0)
    }
};
Customizer.prototype.openStampSelector = function () {
    this.openStampSelectorToItem(playerAccount.stampItem)
};
Customizer.prototype.openStampSelectorToItem = function (stampItem) {
    this.openItemSelector("Stamps", catalog.stamps, stampItem, true, true)
};
Customizer.prototype.poseWithStamp = function (stampItem) {
    null === stampItem ? this.avatar.actor.removeStamp() : this.avatar.actor.applyStamp(stampItem)
};
Customizer.prototype.openItemSelector = function (title, itemList, item, firstItemBlank, highlightSelected) {
    if (playerAccount.isLoggedIn) {
        this.camX = .6, this.camY = .35, this.pageSize = 9;
        var uiItems = this.filterItemsForUI(itemList),
            blankFirstItemShim = true === firstItemBlank ? 1 : 0;
        this.numItems = uiItems.length + blankFirstItemShim;
        var itemIdx = 0;
        null !== item && null === (itemIdx = this.getItemIndex(item, uiItems)) && (itemIdx = 0), highlightSelected && playerAccount.isItemEquipped(item) && (this.currentPickedItem = item), this.page = Math.floor(itemIdx / this.pageSize), this.currentRenderFunc = this.encloseRenderPageFunc(uiItems, firstItemBlank, highlightSelected), this.currentHighlightFunc = this.encloseHighlightFunc(uiItems, firstItemBlank, highlightSelected), this.currentSelectByIndexFunc = this.encloseSelectByIndexFunc(uiItems, firstItemBlank, highlightSelected), this.currentSelectByItemFunc = this.encloseSelectByItemFunc(uiItems, firstItemBlank, highlightSelected), this.currentRenderFunc(), this.currentHighlightFunc(), this.updatePageArrows(), document.getElementById("itemSelectorHeader").innerText = title, menuOut("customizationMenu"), menuIn("itemSelectorMenu")
    } else promoteLogin()
};
Customizer.prototype.encloseRenderPageFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function () {
        outer.clearItemButtons(), outer.iteratePage(function (i, b) {
            if (true === firstItemBlank && 0 === i) outer.renderEmptyButton(), outer.setItemLocked(0, false, 0), outer.setItemRequiresPhysicalUnlock(0, false);
            else {
                var renderingItem = itemList[true === firstItemBlank ? i - 1 : i],
                    canvas = document.getElementById("item" + b);
                renderingItem.renderToCanvas(canvas);
                var locked = !outer.isItemPickable(renderingItem),
                    requiresPhysicalUnlock = outer.doesItemRequirePhysicalUnlock(renderingItem);
                outer.setItemRequiresPhysicalUnlock(b, locked && requiresPhysicalUnlock), outer.setItemLocked(b, locked && !requiresPhysicalUnlock, renderingItem.price)
            }
        }), outer.currentHighlightFunc()
    }
};
Customizer.prototype.encloseHighlightFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function () {
        outer.clearHighlight(), false !== highlightSelected && outer.iteratePage(function (i, b) {
            if (true === firstItemBlank && 0 === i) null === outer.currentPickedItem && outer.highlightSelectedIndex(0);
            else {
                var item = itemList[true === firstItemBlank ? i - 1 : i];
                null !== outer.currentPickedItem && item.id === outer.currentPickedItem.id && outer.highlightSelectedIndex(i)
            }
        })
    }
};
Customizer.prototype.encloseSelectByIndexFunc = function (itemList, firstItemBlank, highlightSelected) {
    var outer = this;
    return function (displayIndex) {
        var listIndex = displayIndex;
        true === firstItemBlank && listIndex--;
        var noItem = true === firstItemBlank && 0 === displayIndex,
            item = noItem ? null : itemList[listIndex];
        true === noItem || outer.isItemPickable(item) ? (true === highlightSelected && outer.highlightSelectedIndex(displayIndex), true === noItem ? (outer.currentPickedItem.takeOffItem(), outer.currentPickedItem = null) : (item.pick(), item.poseEgg())) : (console.log("here, item: " + item.id), item.select(), item.poseEgg(), this.buyingItem = item, outer.itemSelected(item))
    }
};
Customizer.prototype.encloseSelectByItemFunc = function (itemList, firstItemBlank) {
    return function (item) {
        var itemIdx = this.getItemIndex(item, itemList);
        true === firstItemBlank && itemIdx++, this.currentSelectByIndexFunc(itemIdx)
    }
};
Customizer.prototype.itemSelected = function (item) {
    (menuOut("itemSelectorGrid"), menuOut("itemSelectorBackButton"), this.doesItemRequirePhysicalUnlock(item)) ? (menuFlexIn("physicalUnlock"), document.getElementById("physicalUnlockText").innerText = void 0 !== item.item_data.physicalUnlockText ? item.item_data.physicalUnlockText : "Buy a REAL THING to unlock this item!", document.getElementById("physicalUnlockButton").onclick = function () {
        return customizer.openPhysicalItemStoreDialog(), false
    }) : playerAccount.currentBalance >= item.price ? (menuFlexIn("buyItem"), document.getElementById("buyItemText").innerText = item.price, document.getElementById("buyItemButton").onclick = function () {
        return extern.buyItem(item.id), false
    }) : (menuFlexIn("getMoreEggsLoozer"), document.getElementById("moreEggsPrice").innerText = item.price)
};
Customizer.prototype.getItemIndex = function (item, itemList) {
    if (null === item) return null;
    for (var i = 0; i < itemList.length; i++)
        if (item.id === itemList[i].id) return i;
    return null
};
Customizer.prototype.selectItem = function (pageIndex) {
    listIndex = pageIndex + this.page * this.pageSize, listIndex < this.numItems && (this.clearHighlight(), this.currentSelectByIndexFunc(listIndex))
};
Customizer.prototype.closeItemSelector = function () {
    menuOut("itemSelectorMenu");
    var primaryWeapon = playerAccount.getPickedWeaponInSlot(Slot.Primary);
    this.poseWithWeapon(primaryWeapon), this.initWeaponButton(Slot.Primary), this.initWeaponButton(Slot.Secondary), this.initHatButton(), this.initStampButton(), this.open()
};
Customizer.prototype.filterItemsForUI = function (itemList) {
    for (var uiItems = [], i = 0; i < itemList.length; i++) true === itemList[i].showInUI && uiItems.push(itemList[i]);
    return uiItems
};
Customizer.prototype.setupItems = function () {
    this.extendStampItems(), this.extendHatItems();
    for (var cIdx = 0; cIdx < CharClass.length; cIdx++) this.extendWeaponItems(cIdx, Slot.Primary), this.extendWeaponItems(cIdx, Slot.Secondary)
};
Customizer.prototype.extendItems = function (itemList, renderItemToCanvasFunc, poseEggWithItemFunc, selectItemFunc, takeOffItemFunc, pickItemFunc) {
    for (var i = 0; i < itemList.length; i++) {
        var showInUI = true === itemList[i].is_available || true === playerAccount.isItemOwned(itemList[i]);
        itemList[i].showInUI = showInUI, itemList[i].renderToCanvas = renderItemToCanvasFunc, itemList[i].poseEgg = poseEggWithItemFunc, itemList[i].select = selectItemFunc, itemList[i].takeOffItem = takeOffItemFunc, itemList[i].pick = pickItemFunc
    }
};
Customizer.prototype.extendWeaponItems = function (classIdx, slot) {
    var outer = this,
        weaponList = catalog.forClass[classIdx].forWeaponSlot[slot],
        poseEggWithWeaponFunc = function () {
            outer.poseWithWeapon(this)
        };
    this.extendItems(weaponList, function (canvas) {
        itemRenderer.renderToCanvas(this.item_data.meshName, canvas, outer.weaponCam[slot])
    }, poseEggWithWeaponFunc, function () {
        outer.currentPickedItem = playerAccount.getPickedWeaponInSlot(slot)
    }, function () {
        poseEggWithWeaponFunc(this.currentPickedItem)
    }, function () {
        void 0 !== this.exclusive_for_class && null !== this.exclusive_for_class && this.exclusive_for_class !== playerAccount.classIdx && outer.pickClass(this.exclusive_for_class), playerAccount.pickWeapon(slot, this), outer.initWeaponButton(slot)
    })
};
Customizer.prototype.extendHatItems = function () {
    var outer = this;
    this.extendItems(catalog.hats, function (canvas) {
        itemRenderer.renderToCanvas(this.item_data.meshName, canvas, outer.hatCam)
    }, function () {
        outer.poseWithHat(this)
    }, function () {
        outer.currentPickedItem = playerAccount.hatItem
    }, function () {
        playerAccount.hatItem = null, outer.poseWithHat(null)
    }, function () {
        outer.currentPickedItem = this, playerAccount.hatItem = this, outer.initHatButton()
    })
};
Customizer.prototype.extendStampItems = function () {
    var outer = this;
    this.extendItems(catalog.stamps, function (canvas) {
        itemRenderer.renderStampToCanvas(this, canvas)
    }, function () {
        outer.poseWithStamp(this)
    }, function () {
        outer.currentPickedItem = playerAccount.stampItem
    }, function () {
        playerAccount.stampItem = null, outer.poseWithStamp(null)
    }, function () {
        outer.currentPickedItem = this, playerAccount.stampItem = this, outer.initStampButton()
    })
};
Customizer.prototype.setupScene = function () {
    this.scene = new BABYLON.Scene(engine), this.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2, this.scene.fogDensity = .06;
    this.scene.sunLight = {
        direction: new BABYLON.Vector3(0.2, 1, 0.1),
        diffuse: new BABYLON.Color3.White()
    };
    var skyColor = new BABYLON.Color3(.35, .65, .8); //background colour. pre 0.15.7: new BABYLON.Color3(.52, .68, .82) post: .35, .65, .8
    this.scene.fogColor = skyColor;
    this.scene.clearColor = skyColor;
    var topLight = new BABYLON.DirectionalLight("", new BABYLON.Vector3(0, -1, 0), this.scene);
    topLight.intensity = 1;
    var hemLight = new BABYLON.HemisphericLight("", new BABYLON.Vector3(.25, 1, -.5), this.scene);
    hemLight.intensity = .8;
    (hemLight = new BABYLON.HemisphericLight("", new BABYLON.Vector3(0, -1, 0), this.scene)).intensity = .5, hemLight.diffuse = new BABYLON.Color3(.6, .8, 1), (shadowGen = new BABYLON.ShadowGenerator(1024, topLight)).useBlurExponentialShadowMap = true, shadowGen.frustumEdgeFalloff = 1, shadowGen.blurScale = 2, shadowGen.blurBoxOffset = 1, this.camera = new BABYLON.ArcRotateCamera("", .5 * Math.PI, 1.5, this.camRadius, new BABYLON.Vector3(this.camX, this.camY, 0), this.scene), this.scene.activeCameras.push(this.camera), this.camera.maxZ = 100, this.camera.fov = .5, this.camera.minZ = .1;
    var groundMat = new BABYLON.StandardMaterial("groundMat", this.scene);
    groundMat.diffuseColor = new BABYLON.Color3(.35, .5, .6); //pre 0.15.7: new BABYLON.Color3(.4, .5, .6) post: .35, .5, .6
    groundMat.specularColor = BABYLON.Color3.Black();
    var ground = BABYLON.Mesh.CreatePlane("ground", 100, this.scene);
    ground.rotation.x = Math.PI / 2, ground.receiveShadows = true, ground.material = groundMat, this.scene.render();
    for (var i = 0; i < shellColors.length; i++) document.getElementById("color" + i).style.background = shellColors[i];
    stampTexture = new BABYLON.Texture("img/stamps.png?v=" + version, this.scene), this.weaponCam = [{
        alpha: 0,
        radius: 1.3,
        primaryGun: true
    }, {
        alpha: 0,
        radius: 1,
        secondaryGun: true
    }], this.hatCam = {
        alpha: 0,
        radius: 1.3
    }
};
Customizer.prototype.setExtraColorState = function (available) {
    for (var pickColorClosure = function (colorIdx) {
        return function () {
            extern.customizer.pickColor(colorIdx)
        }
    }, i = 7; i < shellColors.length; i++) {
        var colorSwatch = document.getElementById("color" + i);
        true === available ? (colorSwatch.onclick = pickColorClosure(i), colorSwatch.classList.remove("lockedColor")) : (colorSwatch.onclick = extern.openBuyPassDialog, colorSwatch.classList.add("lockedColor"))
    }
};
Customizer.prototype.setupWeaponStats = function () {
    var setupWeaponStatsInList = function (weaponList) {
        for (var i = 0; i < weaponList.length; i++) {
            var weapon = item_classes[weaponList[i].item_data.class];
            for (var key in weaponStats) weaponStats[key].flip ? (weaponStats[key].max = Math.max(weaponStats[key].max, -weapon[key]), weaponStats[key].min = Math.min(weaponStats[key].min, -weapon[key])) : (weaponStats[key].max = Math.max(weaponStats[key].max, weapon[key]), weaponStats[key].min = 0)
        }
    };
    setupWeaponStatsInList(catalog.primaryWeapons), setupWeaponStatsInList(catalog.secondaryWeapons)
};

// [LS] ItemRenderer CONSTRUCTOR
function ItemRenderer() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = 256;
    this.canvas.height = 256;
    this.canvas.style.position = "fixed";
    this.canvas.style.top = "-100em";
    this.canvas.style.left = "1em";
    document.body.appendChild(this.canvas);
    this.engine = new BABYLON.Engine(this.canvas, true, null, false);
    this.scene = new BABYLON.Scene(this.engine);
    this.scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
    this.meshes = {
        Skeletons: {}
    };
    this.scene.sunLight = {
        direction: new BABYLON.Vector3(0.2, 1, 0.1),
        diffuse: new BABYLON.Color3.White()
    };
    loadMaterials(this.scene);
    loadMeshes(this.scene, "models.zip?LEGACYSHELLMAPZIPTIMESTAMP", null, function () { });
    this.stampSprites = new BABYLON.SpriteManager("", "img/stamps.png?v=" + version, 256, 128, this.scene);
    this.camera = new BABYLON.ArcRotateCamera("", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), this.scene);
    this.scene.activeCameras.push(this.camera);
    this.camera.fov = .5;
    this.camera.maxZ = 100;
    this.camera.minZ = .1;
};
ItemRenderer.prototype.renderToCanvas = function (meshName, destCanvas, cam) {
    this.engine.clear();
    this.camera.alpha = 0;
    this.camera.beta = Math.PI90;
    this.camera.radius = cam.radius || 1;
    cam.y;
    try {
        var mesh = this.scene.getMeshByName(meshName).clone();
        cam.primaryGun ? (mesh.rotation.x = -.7, mesh.position.y = -.1, mesh.position.z = -.1) : cam.secondaryGun ? (mesh.position.z = -0.32, mesh.position.y = .05) : (mesh.position.y = -.25, mesh.rotation.y = 2, mesh.rotation.x = .25), mesh.computeWorldMatrix();
        var verts = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        this.scene.updateTransformMatrix();
        for (var min = {
            x: 1e4,
            y: 1e4
        }, max = {
            x: -1e4,
            y: -1e4
        }, i = 0; i < verts.length; i += 3) {
            var sp = BABYLON.Vector3.Project(new BABYLON.Vector3(verts[i], verts[i + 1], verts[i + 2]), mesh.getWorldMatrix(), this.scene.getTransformMatrix(), this.camera.viewport.toGlobal(this.engine));
            min.x = Math.min(min.x, sp.x), max.x = Math.max(max.x, sp.x), min.y = Math.min(min.y, sp.y), max.y = Math.max(max.y, sp.y)
        }
        var cx = (max.x + min.x) / 2 - 128,
            cy = (max.y + min.y) / 2 - 128;
        mesh.position.z -= cx / 512, mesh.position.y += cy / 512, this.scene.render(), mesh.dispose();
        var ctx = destCanvas.getContext("2d");
        ctx.clearRect(0, 0, 256, 256), ctx.drawImage(this.canvas, 0, 0);
    } catch (error) {
        devlog("WARNING: the following mesh wasn't found!", meshName);
    };
};
ItemRenderer.prototype.renderStampToCanvas = function (stampItem, destCanvas) {
    var s = new BABYLON.Sprite("", this.stampSprites),
        x = stampItem.item_data.x,
        y = stampItem.item_data.y;
    s.cellIndex = x + 16 * y, s.size = 1, this.camera.alpha = 0, this.camera.beta = 0, this.camera.radius = 2.5, this.scene.render(), s.dispose();
    var ctx = destCanvas.getContext("2d");
    ctx.clearRect(0, 0, 256, 256), ctx.drawImage(this.canvas, 0, 0)
};

function openItemInCustomizer(itemId) {
    if (!playerAccount.isLoggedIn) return promoteLogin(), false;
    document.getElementById("bigAd").style.display = "none", openCustomizerFromMainMenu();
    var item = catalog.findItemById(itemId);
    return customizer.openToItem(item), true
};

function tryShowTaggedItems() {
    if (null === showTaggedItems) return false;
    var shown = openTaggedItemsInCustomizer(showTaggedItems);
    return true === shown && (showTaggedItems = null), shown
};

function openTaggedItemsInCustomizer(tag) {
    return playerAccount.isLoggedIn ? (openCustomizerFromMainMenu(), customizer.openToTaggedItems(tag), true) : (promoteLogin(), false)
};

function renderItemsInShowItemList(items) {
    for (var i = 0; i < items.length; i++) {
        var itemCanvas = document.getElementById("showItemCanvas_" + i);
        items[i].renderToCanvas(itemCanvas), document.getElementById("showItemName_" + i).innerHTML = items[i].name
    };
};

function createShowItemListHTML(numItems) {
    for (var itemContainer = document.getElementById("showItemContainer").cloneNode(true), itemList = itemContainer.querySelector("#showItemList"), i = 0; i < numItems; i++) {
        var appendIndexToId = function (element) {
            element.id += "_" + i
        },
            itemTemplate = document.getElementById("showItemTemplate").cloneNode(true);
        appendIndexToId(itemTemplate), appendIndexToId(itemTemplate.querySelector("#showItemCanvas")), appendIndexToId(itemTemplate.querySelector("#showItemName")), 1 < numItems && (itemTemplate.style.float = "left"), 0 < i && itemTemplate.classList.add("showItemTemplateLeft"), itemList.appendChild(itemTemplate)
    };
    return itemContainer.class = "", itemContainer
};

function openCustomizerFromMainMenu() {
    hideBannerAd();
    hideMultisizeBannerAd();
    menuOut("mainMenu");
    customizer.open();
};

// [LS] ######## Collider ---------------------------------
//   ___ ___  _    _    ___ ___  ___ ___
//  / __/ _ \| |  | |  |_ _|   \| __| _ \
// | (_| (_) | |__| |__ | || |) | _||   /
//  \___\___/|____|____|___|___/|___|_|_\

LEGACYSHELLCOLLIDER

var Collider;

// [LS] ######## Actor Constructors ---------------------------------
//    _   ___ _____ ___  ___  ___
//   /_\ / __|_   _/ _ \| _ \/ __|
//  / _ \ (__  | || (_) |   /\__ \
// /_/ \_\___| |_| \___/|_|_\|___/


// [LS] PlayerActor CONSTRUCTOR
function PlayerActor(player) {
    this.player = player;
    this.scene = player.scene;
    this.mesh = new BABYLON.TransformNode;
    this.hat = null;
    player.hatItem, player.stampItem; //dont ask
    this.bodyMesh = this.scene.cloneMesh("egg", this.mesh);
    this.bodyMesh.position.y = 0.32;
    this.bodyMesh.player = this.player;
    this.bodyMesh.material = this.scene.getMaterialByName("eggShell");
    this.bodyMesh.material.setTexture("textureSampler", stampTexture);
    this.head = new BABYLON.TransformNode;
    this.head.parent = this.mesh;
    this.head.position.y = .3;
    this.head.position.z = 0;
    this.gunContainer = new BABYLON.TransformNode;
    this.gunContainer.parent = this.head;
    this.gunContainer.rotation.y = -.14;
    this.gunContainer.rotation.x = -.035;
    this.setupStowAnims();
    this.eye = new BABYLON.TransformNode;
    this.eye.position.y = .1;
    this.eye.position.x = 0;
    this.eye.parent = this.head;
    this.hands = this.scene.cloneMesh("hands", this.gunContainer);
    // devlog(this.hands);
    this.hands.skeleton = this.scene.cloneSkeleton("hands_skeleton");
    this.hands.material = this.scene.getMaterialByName("standard");
    this.gripBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("gripHand")];
    this.foreBone = this.hands.skeleton.bones[this.hands.skeleton.getBoneIndexByName("foreHand")];
    this.bodyMesh.overlayColor = BABYLON.Color3.Green();
    this.hands.overlayColor = BABYLON.Color3.Green();
    0 < this.player.shield && (this.bodyMesh.renderOverlay = true, this.hands.renderOverlay = true);
    this.setShellColor(this.player.shellColor);
    shake = 0;
    
    if (shadowGen) {
        shadowGen.getShadowMap().renderList.push(this.bodyMesh);
        if (fancyShadows) {
            shadowGen.getShadowMap().renderList.push(this.hands);
        };
    };

    if (inGame) {
        this.player.id == meId ? this.hands.setRenderingGroupId(1) : (this.setupNameSprite(), this.showNameSprite()), inGame && this.updateTeam();
    } else {
        this.bodyMesh.outlineColor = teamColors.outline[0].clone(), this.bodyMesh.outlineColor.a = 0;
    };
    this.mesh.position.x = this.player.x;
    this.mesh.position.y = this.player.y;
    this.mesh.position.z = this.player.z;
    //this.deathSound = Sounds.shellBurst.clone();
    //this.player.id == meId ? this.hitSound = Sounds.hit.clone() : (this.wearHat(this.player.hatItem), this.applyStamp(this.player.stampItem), this.hitSound = this.bodyMesh.attachSound(Sounds.hit));
    if(this.player.id != meId){
        this.wearHat(this.player.hatItem);
        this.applyStamp(this.player.stampItem);
    }
    /* playOffline && this.hands.setEnabled(false), */
    this.bobbleIntensity = 0;
    this.scope = false;
    this.zoomed = false;
    this.hitSoundDelay = 0;

    this.bodyEmitter = new Emitter(this.player.id == meId ? false: this.bodyMesh); //no parent if myPlayer, so the Emitter is 2d
};
PlayerActor.prototype.wearHat = function (hatItem) {
    this.removeHat(), null !== hatItem && (this.hat = this.scene.cloneMesh(hatItem.item_data.meshName, this.bodyMesh), this.hat.position.y = -.02)
};
PlayerActor.prototype.removeHat = function () {
    void 0 !== this.hat && null !== this.hat && this.hat.dispose()
};
PlayerActor.prototype.applyStamp = function (stampItem) {
    this.removeStamp();
    null !== stampItem && (this.bodyMesh.stampU = stampItem.item_data.x / 16, this.bodyMesh.stampV = 1 - stampItem.item_data.y / 16)
};
PlayerActor.prototype.removeStamp = function () {
    this.bodyMesh.stampU = 0, this.bodyMesh.stampV = 1
};
PlayerActor.prototype.drawTextOnNameTexture = function (text, x, y, size, color, center) {
    var shadowCoords = [{
        x: 0,
        y: -4
    }, {
        x: -4,
        y: 0
    }, {
        x: 4,
        y: 0
    }, {
        x: 0,
        y: 4
    }],
        coords = [{
            x: 0,
            y: -1
        }, {
            x: -1,
            y: 0
        }, {
            x: 1,
            y: 0
        }, {
            x: 0,
            y: 1
        }];
    x += this.player.id % 4 * 512, y = -y + (2048 - 256 * Math.floor(this.player.id / 4)), center && (x += 256 - function (name, size) {
        var context = nameTestCanvas.getContext("2d");
        return context.font = "bold " + size + "px Nunito, sans-serif", context.measureText(name).width
    }(text, size) / 2);
    for (var i = 0; i < 4; i++) nameTexture.drawText(text, x + shadowCoords[i].x, y + shadowCoords[i].y, "bold " + size + "px Nunito, sans-serif", "rgba(0, 0, 0, 0.5)", "transparent");
    for (i = 0; i < 4; i++) nameTexture.drawText(text, x + coords[i].x, y + coords[i].y, "bold " + size + "px Nunito, sans-serif", color, "transparent")
};
PlayerActor.prototype.setupNameSprite = function () {
    var tx = this.player.id % 4 * 512,
        ty = 2048 - 256 * Math.floor(this.player.id / 4);
    nameTexture.clearRect(tx, ty - 256, 512, 256), this.drawTextOnNameTexture(this.player.name, 0, 32, 60, "white", true)
};
PlayerActor.prototype.updateTeam = function () {
    if (this.player.id !== meId) {
        if (0 < this.player.team) {
            if (this.player.team == myTeam) {
                this.bodyMesh.outlineColor = teamColors.outline[this.player.team].clone();
            } else this.bodyMesh.outlineColor.a = 0;

            if (this.nameSprite) {
                this.nameSprite.width = .6;
                this.nameSprite.height = .3;
                this.nameSprite.color = teamColors.outline[this.player.team];
            };
        } else this.bodyMesh.outlineColor.a = 0;
    };
};
PlayerActor.prototype.update = function (delta) {
    var bcos = Math.cos(this.player.bobble) * this.bobbleIntensity,
        bsina = Math.abs(Math.sin(this.player.bobble) * this.bobbleIntensity),
        bsin = Math.sin(2 * this.player.bobble) * this.bobbleIntensity;
    if (0 < this.player.shield) {
        var alpha = .7 * Math.random() + .2;
        this.bodyMesh.overlayAlpha = alpha, this.hands.overlayAlpha = alpha
    }
    if (this.player.id == meId) this.scope && this.player.isAtReady(true) ? (camera.fov = camera.fov + (this.player.weapon.actor.scopeFov - camera.fov) / 3, this.gunContainer.rotation.y *= .667, this.gunContainer.rotation.x *= .667, this.gunContainer.position.x += (-.25 - this.gunContainer.position.x) / 3, this.gunContainer.position.y += (this.player.weapon.actor.scopeY - this.gunContainer.position.y) / 4, this.gunContainer.position.z += (-.05 - this.gunContainer.position.z) / 3, this.player.weapon.hasScope && !this.zoomed && camera.fov < this.player.weapon.actor.scopeFov + .05 && (scope.show(), this.gunContainer.setEnabled(false), this.zoomed = true)) : (camera.fov = camera.fov + (1.25 - camera.fov) / 3, this.gunContainer.rotation.y += (2 * bcos - .14 - this.gunContainer.rotation.y) / 3, this.gunContainer.rotation.x += (.75 * bsin - .035 - this.gunContainer.rotation.x) / 3, this.gunContainer.position.x *= .667, this.gunContainer.position.y *= .667, this.gunContainer.position.z *= .667, this.zoomed && camera.fov > this.player.weapon.actor.scopeFov + .05 && (scope.hide(), this.gunContainer.setEnabled(true), this.zoomed = false));
    else if (this.gunContainer.rotation.y += (2 * bcos - .14 - this.gunContainer.rotation.y) / 3, this.gunContainer.rotation.x += (.75 * bsin - .035 - this.gunContainer.rotation.x) / 3, 0 < this.player.team && this.player.team == myTeam && this.nameSprite) {
        var dist = Math.length3(this.player.x - me.x, this.player.y - me.y, this.player.z - me.z),
            fac = Math.pow(dist, 1.25);
        this.nameSprite.width = fac / 10 + .6, this.nameSprite.height = fac / 20 + .3
    }
    var dx = this.player.x - this.mesh.position.x,
        dy = this.player.y - this.mesh.position.y,
        dz = this.player.z - this.mesh.position.z;
    dist = Math.length3(dx, dy, dz);
    this.player.id == meId ? (this.mesh.position.x += dx / 2, this.mesh.position.y += dy / 2, this.mesh.position.z += dz / 2) : (this.mesh.position.x += dx / 6, this.mesh.position.y += dy / 2, this.mesh.position.z += dz / 6);
    var bobbleTarget;
    Math.radDifference(this.player.yaw, this.mesh.rotation.y), Math.radDifference(this.player.pitch, this.head.rotation.x);
    if (this.mesh.rotation.y = this.player.yaw, this.head.rotation.x = this.player.pitch, this.bodyMesh.rotation.x = this.head.rotation.x / 4, bobbleTarget = this.player.jumping ? 0 : Math.length3(this.player.dx, this.player.dy, this.player.dz), this.bobbleIntensity += (bobbleTarget - this.bobbleIntensity) / 10, this.bodyMesh.rotation.z = 5 * bcos, this.bodyMesh.position.y = 1.5 * bsina + (0.32), 0 < shake)
        if ((shake *= .9) < .001) shake = 0;
        else {
            var x = Math.random() * shake - .5 * shake,
                y = Math.random() * shake - .5 * shake,
                z = Math.random() * shake - .5 * shake;
            this.eye.rotation.x += (x - this.eye.rotation.x) / 10, this.eye.rotation.y += (y - this.eye.rotation.y) / 10, this.eye.rotation.z += (z - this.eye.rotation.z) / 10
        }
    else this.eye.rotation.x *= .9, this.eye.rotation.y *= .9, this.eye.rotation.z *= .9;
    if (this.player.id != meId) {
        var visible = isMeshVisible(this.mesh, .31);
        this.mesh.setVisible(visible);
        visible ? this.showNameSprite() : this.hideNameSprite();
        this.nameSprite && this.positionNameSprite();
    };
    this.hitSoundDelay = Math.max(this.hitSoundDelay - delta, 0)
};
PlayerActor.prototype.positionNameSprite = function () {
  if (this.nameSprite) {
    var mp = this.mesh.position.clone();
    mp.y += 0.5 * this.nameSprite.height + (0.65 * this.player.scale);
    var v = new BABYLON.Vector3(
      camera.globalPosition.x - mp.x,
      camera.globalPosition.y - mp.y,
      camera.globalPosition.z - mp.z
    ).normalize();
    v.scaleInPlace(0.4), v.addInPlace(mp), (this.nameSprite.position = v);
  }
};
PlayerActor.prototype.showNameSprite = function () {
    this.player.playing && !this.nameSprite && (this.nameSprite = new BABYLON.Sprite("", nameSprites), this.nameSprite.invertV = true, this.nameSprite.width = .6, this.nameSprite.height = .3, this.nameSprite.cellIndex = this.player.id, this.nameSprite.color = teamColors.outline[this.player.team])
};
PlayerActor.prototype.hideNameSprite = function () {
    this.nameSprite && (this.nameSprite.dispose(), this.nameSprite = null)
};
PlayerActor.prototype.scopeIn = function () {
    this.scope = true
};
PlayerActor.prototype.scopeOut = function () {
    this.scope = false
};
PlayerActor.prototype.hit = function () {
    if (this.hitSoundDelay <= 0) {
        this.bodyEmitter.play("hit"); //TODO: add playbackRate!
        //this.hitSound.setPosition(new BABYLON.Vector3(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z));
        //this.hitSound.setPlaybackRate(this.playbackRate);
        //this.hitSound.play();
        this.hitSoundDelay = 10;
    };
};
PlayerActor.prototype.removeFromPlay = function () {
    // devlog("removeFromPlay");
    this.scope = false, this.zoomed = false, this.throwingGrenade = false, this.gripBone._frozen = false, this.mesh.setEnabled(false), this.hideNameSprite()
    // if (playOffline) this.mesh.setEnabled(true);
    rebuildPlayerList();
};
PlayerActor.prototype.restoreToPlay = function () {
    // devlog("restoreToPlay");
    this.mesh.setEnabled(true);
    this.gunContainer.setEnabled(true);
    this.player.id != meId && this.showNameSprite();
    this.updateTeam();
    // if (playOffline) this.mesh.setEnabled(true);
    rebuildPlayerList();
};
PlayerActor.prototype.remove = function () {
    this.mesh.disposeOfSounds(), this.mesh.dispose(), this.hideNameSprite()
};
PlayerActor.prototype.fire = function () {
    this.zoomed && this.player.weapon.hasScope && (shake = .25, this.eye.rotation.x = -.1)
};
PlayerActor.prototype.reachForGrenade = function () {
    var that = this;
    this.throwingGrenade = true;
    this.gripBone._frozen = true;
    this.hands.skeleton.enableBlending(.2);
    this.hands.skeleton.beginAnimation("grenade.grab", false, 1, function () {
        that.hands.skeleton && that.hands.skeleton.disableBlending()
    });
};
PlayerActor.prototype.throwGrenade = function () {
    var that = this;
    this.player.id == meId && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden"), this.hands.skeleton.beginAnimation("grenade.throw", false, 1, function () {
        that.hands.skeleton && (that.throwingGrenade = false, that.gripBone._frozen = false)
    })
};
PlayerActor.prototype.setShellColor = function (colorIdx) {
    (colorIdx < 0 || colorIdx >= shellColors.length) && (console.log("Shell color out of bounds: " + colorIdx), colorIdx = 0);
    var color = BABYLON.Color3.FromHexString(shellColors[colorIdx]);
    this.bodyMesh.colorMult = color, this.hands.colorMult = color
};
PlayerActor.prototype.setWeaponSkeleton = function (skeleton) {
    this.skeleton = skeleton, this.weaponGripBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("gripHand")], this.weaponForeBone = this.skeleton.bones[this.skeleton.getBoneIndexByName("foreHand")]
};
PlayerActor.prototype.handsToWeaponSkeleton = function () {
    this.gripBone.position = this.weaponGripBone.position, this.gripBone.setRotationQuaternion(this.weaponGripBone.rotationQuaternion), 1 != this.throwingGrenade && (this.foreBone.position = this.weaponForeBone.position, this.foreBone.setRotationQuaternion(this.weaponForeBone.rotationQuaternion))
};
PlayerActor.prototype.setupStowAnims = function () {
    var gunRotationAnimation = new BABYLON.Animation("", "rotation", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunScaleAnimation = new BABYLON.Animation("", "scaling", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunPositionAnimation = new BABYLON.Animation("", "position", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT),
        gunRotationEase = new BABYLON.CubicEase;
    gunRotationEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunRotationAnimation.setEasingFunction(gunRotationEase);
    var gunScaleEase = new BABYLON.CubicEase;
    gunScaleEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunScaleAnimation.setEasingFunction(gunScaleEase);
    var gunPositionEase = new BABYLON.CubicEase;
    gunPositionEase.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT), gunPositionAnimation.setEasingFunction(gunPositionEase);
    var gunRotationKeys = [{
        frame: 0,
        value: new BABYLON.Vector3(-.035, -.14, 0)
    }, {
        frame: 25,
        value: new BABYLON.Vector3(1, -1.5, 0)
    }, {
        frame: 30,
        value: new BABYLON.Vector3(-1, -1.5, 0)
    }, {
        frame: 55,
        value: new BABYLON.Vector3(-.035, -.14, 0)
    }],
        gunScaleKeys = [{
            frame: 0,
            value: new BABYLON.Vector3(1, 1, 1)
        }, {
            frame: 25,
            value: new BABYLON.Vector3(.25, .25, .25)
        }, {
            frame: 30,
            value: new BABYLON.Vector3(.25, .25, .25)
        }, {
            frame: 55,
            value: new BABYLON.Vector3(1, 1, 1)
        }],
        gunPositionKeys = [{
            frame: 0,
            value: new BABYLON.Vector3(0, 0, 0)
        }, {
            frame: 25,
            value: new BABYLON.Vector3(.1, .1, -.2)
        }, {
            frame: 30,
            value: new BABYLON.Vector3(.1, 0, -.2)
        }, {
            frame: 55,
            value: new BABYLON.Vector3(0, 0, 0)
        }];
    gunRotationAnimation.setKeys(gunRotationKeys), gunScaleAnimation.setKeys(gunScaleKeys), gunPositionAnimation.setKeys(gunPositionKeys), this.gunContainer.animations.push(gunRotationAnimation), this.gunContainer.animations.push(gunScaleAnimation), this.gunContainer.animations.push(gunPositionAnimation)
};

// [LS] GrenadeActor CONSTRUCTOR
function GrenadeActor(grenade, scene) {
    this.grenade = grenade;
    this.scene = grenade.scene;
    this.mesh = this.scene.cloneMesh("grenade");
    this.mesh.setEnabled(false);
    this.explodeSound = "grenade.explode";
    this.pinSound = "grenade.pin";
    this.beepSound = "grenade.beep";
    this.beep = false;
    this.flashColor = null;
    this.soundEmitter = new Emitter(this.mesh);
}
GrenadeActor.prototype.throw = function () {
    this.mesh.setEnabled(true);
    this.mesh.position.x = this.grenade.x;
    this.mesh.position.y = this.grenade.y;
    this.mesh.position.z = this.grenade.z;
    this.grenade.player.id == meId ? this.flashColor = flashColors[0] : this.flashColor = flashColors[this.grenade.player.team];
    this.soundEmitter.play(this.pinSound);
    this.bounce();
};
GrenadeActor.prototype.update = function () {
    this.mesh.position.x = this.grenade.x;
    this.mesh.position.y = this.grenade.y; 
    this.mesh.position.z = this.grenade.z; 
    this.mesh.rotation.x += this.rx;
    this.mesh.rotation.y += this.ry; 
    this.mesh.rotation.z += this.rz;
    1 < Math.sqrt(this.grenade.ttl) % 2 ? (0 == this.beep && (this.soundEmitter.play(this.beepSound), this.beep = true), this.mesh.emissiveColor = this.flashColor) : (this.mesh.emissiveColor = BABYLON.Color3.Black(), this.beep = false)
};
GrenadeActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};
GrenadeActor.prototype.bounce = function () {
    var s = Math.length3(this.grenade.dx, this.grenade.dy, this.grenade.dz);
    this.rx = (2 * Math.random() - 1) * s, this.ry = (2 * Math.random() - 1) * s, this.rz = (2 * Math.random() - 1) * s
};
GrenadeActor.prototype.stop = function () {
    this.rx = 0, this.ry = 0, this.rz = 0
};

// [LS] BulletActor CONSTRUCTOR
function BulletActor(bullet) {
    this.scene = bullet.scene, 
    this.bullet = bullet, 
    this.delayFrames = 0, 
    this.mesh = this.scene.getMeshByName("bullet").createInstance(""), 
    this.mesh.setEnabled(false)
}
BulletActor.prototype.fire = function () {
    this.bullet.player.id == meId ? this.delayFrames = Math.ceil(ping / 17) + 5 : this.delayFrames = 5, this.mesh.position.x = this.bullet.x, this.mesh.position.y = this.bullet.y, this.mesh.position.z = this.bullet.z, this.mesh.lookAt(new BABYLON.Vector3(this.bullet.x + this.bullet.dx, this.bullet.y + this.bullet.dy, this.bullet.z + this.bullet.dz)), this.mesh.rotation.x += .015, this.mesh.rotation.y -= .015, this.mesh.scaling.z = .5
};
BulletActor.prototype.update = function () {
    --this.delayFrames <= 0 && this.mesh.setEnabled(true), this.mesh.position.x = this.bullet.x, this.mesh.position.y = this.bullet.y, this.mesh.position.z = this.bullet.z, this.bullet.player.id != meId && (this.mesh.scaling.z = Math.min(this.mesh.scaling.z + .03, 3))
};
BulletActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] RocketActor CONSTRUCTOR
function RocketActor(rocket) {
    this.rocket = rocket;
    this.scene = rocket.scene;
    this.armed = false;
    this.delayFrames = 0;
    this.mesh = this.scene.getMeshByName("rocket").createInstance("");
    this.soundEmitter = new Emitter(this.mesh);
    this.mesh.setEnabled(false);
    this.explodeSound = "rpegg.explode";
    this.poofSound = "rpegg.poof";
    this.flySound = "rpegg.fly";
}
RocketActor.prototype.fire = function () {
    this.armed = false, this.rocket.player.id == meId ? this.delayFrames = Math.ceil(ping / 17) + 3 : this.delayFrames = 3, this.mesh.position.x = this.rocket.x, this.mesh.position.y = this.rocket.y, this.mesh.position.z = this.rocket.z, this.mesh.lookAt(new BABYLON.Vector3(this.rocket.x + this.rocket.dx, this.rocket.y + this.rocket.dy, this.rocket.z + this.rocket.dz)), this.mesh.rotation.x += .015, this.mesh.rotation.y -= .015
};
RocketActor.prototype.update = function () {
    if (--this.delayFrames <= 0 && this.mesh.setEnabled(true), !this.armed && this.rocket.ttArmed <= 0 && (this.armed = true,this.soundEmitter.play(this.flySound)), this.delayFrames % 4 == 0) {
        var dx = .04 * Math.random() - .02,
            dy = .04 * Math.random() - .02,
            dz = .04 * Math.random() - .02;
        this.rocket.ttArmed <= 0 && (addExplosionSprite(explosionSmokeManager, 10, this.rocket.x, this.rocket.y, this.rocket.z, dx, dy, dz, .4), addExplosionSprite(explosionFireManager, 10, this.rocket.x, this.rocket.y, this.rocket.z, dx, dy, dz, .4))
    }
    this.mesh.position.x = this.rocket.x, this.mesh.position.y = this.rocket.y, this.mesh.position.z = this.rocket.z
};
RocketActor.prototype.remove = function () {
    this.mesh.setEnabled(false)
};

// [LS] GunActor CONSTRUCTOR
function GunActor(gun, meshName) {
  this.gun = gun, this.meshName = meshName, this.scene = gun.scene, this.standardMeshName = gun.subClass.standardMeshName, this.playerActor = gun.player.actor, this.skeleton = this.scene.cloneSkeleton("gun_" + this.standardMeshName + "_skeleton");
};
GunActor.prototype.setup = function (muzFlashZ) {
    this.gunMesh = this.scene.cloneMesh(this.meshName, this.playerActor.gunContainer);

    if (shadowGen && fancyShadows) {
        shadowGen.getShadowMap().renderList.push(this.gunMesh);
    };

    this.gunMesh.skeleton = this.skeleton, this.gunMesh.setEnabled(false), muzFlashZ && (this.muzzleFlash = this.scene.cloneMesh("muzzleFlash", this.playerActor.gunContainer), this.muzzleFlash.setEnabled(false), this.muzzleFlash.parent = this.playerActor.gunContainer, this.muzzleFlash.position.x = .25, this.muzzleFlash.position.z = muzFlashZ), this.gun.player.id == meId && (this.gunMesh.setRenderingGroupId(1), this.muzzleFlash && this.muzzleFlash.setRenderingGroupId(1));
    this.gunEmitter = new Emitter(this.gun.player.id === meId ? false: this.gunMesh); //2d emitter if MYPLAYER
};
GunActor.prototype.getSavePbRate = function(){
    if(!this?.playerActor?.mesh?.position) return false;
    return this.playerActor.playbackRate;
}
GunActor.prototype.addSoundEvent = function (animation, frame, sound) {
    frame += this.skeleton.getAnimationRange(animation).from;
    var that = this;
    var event = new BABYLON.AnimationEvent(frame, function () {
        //if (this?.playerActor?.mesh?.position) sound.setPlaybackRate(this.playerActor.playbackRate);
        that.gunEmitter.play(sound, that.getSavePbRate());
        //sound.play();
    });
    this.skeleton.bones[0].animations[0].addEvent(event)
};
GunActor.prototype.dispose = function () {
    this.gunMesh.dispose()
};
GunActor.prototype.stow = function () {
    var that = this;
    this.scene.beginAnimation(this.playerActor.gunContainer, 0, 25, false, 1, function () {
        that.gunMesh.setEnabled(false), that.gun.equip()
    })
};
GunActor.prototype.equip = function () {
    this.gunMesh.setEnabled(true), this.playerActor.setWeaponSkeleton(this.skeleton), this.scene.beginAnimation(this.playerActor.gunContainer, 30, 55, false, 1)
};
GunActor.prototype.dryFire = function () {
    this.gunEmitter.play(this.dryFireSound, this.getSavePbRate());
    return;

    if (this?.playerActor?.mesh?.position) this.dryFireSound.setPlaybackRate(this.playerActor.playbackRate);

    this.dryFireSound.play();
};
GunActor.prototype.denyFire = function () {
    // this.dryFireSound.setPosition(new BABYLON.Vector3(this.playerActor.mesh.position.x, this.playerActor.mesh.position.y + 1, this.playerActor.mesh.position.z));
    // this.denyFireSound.setPosition(new BABYLON.Vector3(this.playerActor.mesh.position.x, this.playerActor.mesh.position.y + 1, this.playerActor.mesh.position.z));

    this.gunEmitter.play(this.dryFireSound, this.getSavePbRate());
    this.gunEmitter.play(this.denyFireSound, this.getSavePbRate());

    reticle.fireDenied();

    return;

    if (this?.playerActor?.mesh?.position) this.dryFireSound.setPlaybackRate(this.playerActor.playbackRate);
    if (this?.playerActor?.mesh?.position) this.denyFireSound.setPlaybackRate(this.playerActor.playbackRate);

    //reticle.fireDenied();
    this.dryFireSound.play();
    this.denyFireSound.play()
};
GunActor.prototype.fire = function () {
    // this.fireSound.setPosition(new BABYLON.Vector3(this.playerActor.mesh.position.x, this.playerActor.mesh.position.y, this.playerActor.mesh.position.z));
    //if (this?.playerActor?.mesh?.position) this.fireSound.setPlaybackRate(this.playerActor.playbackRate);

    this.gunEmitter.play(this.fireSound, this.getSavePbRate());

    if ( this.muzzleFlash) {
        this.muzzleFlash.rotation.z = 3.141 * Math.random(), this.muzzleFlash.setEnabled(true);
        var that = this;
        setTimeout(function () {
            that.muzzleFlash.setEnabled(false)
        }, 40)
    }
    this.skeleton.beginAnimation("fire")
};
GunActor.prototype.reload = function () {
    this.gun.longReloadTime == this.gun.shortReloadTime ? this.skeleton.beginAnimation("reload") : 0 < this.gun.ammo.rounds ? this.skeleton.beginAnimation("shortReload") : this.skeleton.beginAnimation("longReload")
};
GunActor.prototype.update = function () { };

// [LS] Eggk47Actor CONSTRUCTOR
function Eggk47Actor(gun, meshName) {
    GunActor.call(this, gun, meshName),
    this.scopeFov = .9,
    this.scopeY = .0438,
    this.setup(.6),
    this.fireSound = "eggk47.fire";
    this.dryFireSound = "eggk47.dryFire";
    /*
    var removeMag = this.gunMesh.attachSound(Sounds.eggk47.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.eggk47.insertMag),
        cycle = this.gunMesh.attachSound(Sounds.eggk47.cycle);
        */
    this.addSoundEvent("shortReload", 40, "eggk47.removeMag");
    this.addSoundEvent("shortReload", 130, "eggk47.insertMag");
    this.addSoundEvent("longReload", 40, "eggk47.removeMag");
    this.addSoundEvent("longReload", 130, "eggk47.insertMag");
    this.addSoundEvent("longReload", 155, "eggk47.cycle");
};
(Eggk47Actor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] DozenGaugeActor CONSTRUCTOR
function DozenGaugeActor(gun, meshName) {
    GunActor.call(this, gun, meshName);
    this.scopeFov = 1;
    this.scopeY = .072;
    this.setup(.6);
    this.fireSound = "dozenGauge.fire";
    this.dryFireSound = "eggk47.dryFire";
    /*
    var open = this.gunMesh.attachSound(Sounds.dozenGauge.open);
    var load = this.gunMesh.attachSound(Sounds.dozenGauge.load);
    var close = this.gunMesh.attachSound(Sounds.dozenGauge.close);
    */
    this.addSoundEvent("reload", 0, "dozenGauge.open");
    this.addSoundEvent("reload", 80, "dozenGauge.load");
    this.addSoundEvent("reload", 115, "dozenGauge.close");
};
(DozenGaugeActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] CSG1Actor CONSTRUCTOR
function CSG1Actor(gun, meshName) {
    GunActor.call(this, gun, meshName);
    this.scopeFov = .5;
    this.scopeY = .0345;
    this.setup(.6);
    this.fireSound = "csg1.fire";
    this.dryFireSound = "eggk47.dryFire";
/*
    var removeMag = this.gunMesh.attachSound(Sounds.eggk47.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.eggk47.insertMag),
        pullAction = this.gunMesh.attachSound(Sounds.csg1.pullAction),
        releaseAction = this.gunMesh.attachSound(Sounds.csg1.releaseAction);
        */
    this.addSoundEvent("shortReload", 30, "eggk47.removeMag");
    this.addSoundEvent("shortReload", 120, "eggk47.insertMag");
    this.addSoundEvent("longReload", 30, "csg1.pullAction");
    this.addSoundEvent("longReload", 75, "eggk47.removeMag");
    this.addSoundEvent("longReload", 165, "eggk47.insertMag");
    this.addSoundEvent("longReload", 200, "csg1.pullAction");
};
(CSG1Actor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] Cluck9mmActor CONSTRUCTOR
function Cluck9mmActor(gun, meshName) {
    GunActor.call(this, gun, meshName), 
    this.scopeFov = 1.1;
    this.scopeY = .069;
    this.setup(.48);
    this.fireSound = "cluck9mm.fire";
    this.dryFireSound = "eggk47.dryFire";
    /*
    var removeMag = this.gunMesh.attachSound(Sounds.cluck9mm.removeMag),
        insertMag = this.gunMesh.attachSound(Sounds.cluck9mm.insertMag),
        cycle = this.gunMesh.attachSound(Sounds.eggk47.cycle);
        */
    this.addSoundEvent("shortReload", 15, "cluck9mm.removeMag");
    this.addSoundEvent("shortReload", 100, "cluck9mm.insertMag");
    this.addSoundEvent("longReload", 15, "cluck9mm.removeMag");
    this.addSoundEvent("longReload", 100, "cluck9mm.insertMag");
    this.addSoundEvent("longReload", 155, "eggk47.cycle");
};
(Cluck9mmActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] RPEGGActor CONSTRUCTOR
function RPEGGActor(gun, meshName) {
    GunActor.call(this, gun, meshName), this.scopeFov = .9, this.scopeY = .1 - .0862, this.setup(.51);
    this.fireSound = "rpegg.fire";
    this.dryFireSound = "eggk47.dryFire";
    this.denyFireSound = "rpegg.denyFire";
    //var loadRocket = "rpegg.load";
    this.addSoundEvent("reload", 115, "rpegg.load");
};
(RPEGGActor.prototype = Object.create(GunActor.prototype)).constructor = GunActor;

// [LS] ######## Object Constructors ---------------------------------
//   ___  ___    _ ___ ___ _____ ___
//  / _ \| _ )_ | | __/ __|_   _/ __|
// | (_) | _ \ || | _| (__  | | \__ \
//  \___/|___/\__/|___\___| |_| |___/

LEGACYSHELLPLAYERCONSTRUCTOR

LEGACYSHELLBULLETS

LEGACYSHELLGUNS

// [LS] Scope CONSTRUCTOR
function Scope() {
    this.crosshairs = new BABYLON.AbstractMesh("", gameScene), this.crosshairs.setEnabled(false), this.crosshairs.position.z = 2;
    var p = [new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(1, 0, 0)],
        l = BABYLON.MeshBuilder.CreateLines("", {
            points: p
        }, gameScene);
    l.layerMask = 536870912, l.color = BABYLON.Color3.Black(), l.parent = this.crosshairs, p = [new BABYLON.Vector3(0, -1, 0), new BABYLON.Vector3(0, 1, 0)], (l = BABYLON.MeshBuilder.CreateLines("", {
        points: p
    }, gameScene)).layerMask = 536870912, l.color = BABYLON.Color3.Black(), l.parent = this.crosshairs
};
Scope.prototype.show = function () {
    var h = engine.getRenderHeight();
    this.crosshairs.scaling.x = h / 2, this.crosshairs.scaling.y = h / 2, this.crosshairs.setEnabled(true), document.getElementById("scopeBorder").style.display = "block", camera.viewport.width = h / engine.getRenderWidth(), camera.viewport.x = .5 - .5 * camera.viewport.width
};
Scope.prototype.hide = function () {
    this.crosshairs.setEnabled(false), document.getElementById("scopeBorder").style.display = "none", camera.viewport.width = 1, camera.viewport.x = 0
};

// [LS] HitIndicator CONSTRUCTOR
function HitIndicator() {
    this.mesh = new BABYLON.Mesh("hitIndicator", gameScene), this.mesh.updatable = true, this.mesh.hasVertexAlpha = true, this.positions = [0, 0, 0, 0, .5, 0, .5, .5, 0, .5, 0, 0, .5, -.5, 0, 0, -.5, 0, -.5, -.5, 0, -.5, 0, 0, -.5, .5, 0];
    this.colors = new Array(48).fill(0);
    for (var i = 0; i < 48; i += 4) this.colors[i] = 1, this.colors[i + 1] = .9, this.colors[i + 2] = 0, this.colors[i + 3] = -.5;
    var vertexData = new BABYLON.VertexData;
    vertexData.positions = this.positions, vertexData.indices = [0, 1, 8, 0, 2, 1, 0, 2, 1, 0, 3, 2, 0, 3, 2, 0, 4, 3, 0, 4, 3, 0, 5, 4, 0, 5, 4, 0, 6, 5, 0, 6, 5, 0, 7, 6, 0, 7, 6, 0, 8, 7, 0, 8, 7, 0, 1, 8], vertexData.colors = this.colors, vertexData.applyToMesh(this.mesh, true), this.mesh.layerMask = 536870912, this.mesh.material = gameScene.getMaterialByName("ui"), this.resize()
};
HitIndicator.prototype.resize = function () {
    this.mesh.scaling.x = engine.getRenderWidth(), this.mesh.scaling.y = engine.getRenderHeight()
};
HitIndicator.prototype.update = function (delta) {
    for (var i = 7; i < 48; i += 4) this.colors[i] -= (this.colors[i] + .5) / 10 * delta;
    var mult = Math.pow(.9, delta);
    me && me.playing && (camera.position.x *= mult, camera.position.z *= mult), this.mesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, this.colors, true)
};
HitIndicator.prototype.hit = function (dx, dz) {
    var a = Math.radRange(-Math.atan2(dx, -dz) - me.yaw + .393);
    a = Math.floor(a / Math.PI2 * 8);
    var vec = new BABYLON.Vector2(-this.positions[3 * a + 3], -this.positions[3 * a + 4]).normalize();
    camera.position.x = .03 * vec.x, camera.position.z = .03 * vec.y, this.colors[4 * a + 7] = 2
};

// [LS] Reticle CONSTRUCTOR
function Reticle() {
    this.crosshairs = [];
    for (var i = 0; i < 4; i++) this.crosshairs.push(document.getElementById("crosshair" + i));
    this.readyBrackets = document.getElementById("readyBrackets")
};
Reticle.prototype.show = function () {
    if (document.getElementById("reticleContainer").className = "", me.weapon.subClass.readySpread) {
        this.readyBrackets.className = "notReady";
        var size = .069 * me.weapon.subClass.readySpread * 10 + "em";
        this.readyBrackets.style.width = size, this.readyBrackets.style.height = size
    } else this.readyBrackets.className = "hideme"
};
Reticle.prototype.hide = function () {
    document.getElementById("reticleContainer").className = "hideme"
};
Reticle.prototype.fireDenied = function () {
    this.readyBrackets.className = "";
    var that = this;
    setTimeout(function () {
        that.readyBrackets.className = "notReady"
    }, 10)
};
Reticle.prototype.update = function (delta) {
    if (me.weapon) {
        for (var i = 0; i < 4; i++) {
            var spread = me.shotSpread + me.weapon.subClass.accuracy;
            this.crosshairs[i].style.transform = "rotate(" + 90 * i + "deg) translateY(" + (.069 * spread + .12) + "em)"
        }
        me.weapon.subClass.readySpread && (spread <= 5 * me.weapon.subClass.accuracy ? this.readyBrackets.className = "ready" : this.readyBrackets.className = "notReady")
    }
};
Reticle.prototype.resize = function () { };


// [LS] ######## MANAGERS ---------------------------------
//  __  __   _   _  _   _   ___ ___ ___  ___
// |  \/  | /_\ | \| | /_\ / __| __| _ \/ __|
// | |\/| |/ _ \| .` |/ _ \ (_ | _||   /\__ \
// |_|  |_/_/ \_\_|\_/_/ \_\___|___|_|_\|___/

// [LS] Pool CONSTRUCTOR
LEGACYSHELLPOOL

// [LS] MunitionsManager CONSTRUCTOR
LEGACYSHELLMUNITIONSMANAGER

// [LS] ItemManager CONSTRUCTOR
LEGACYSHELLITEMMANAGER


// [LS] ######## Math Extensions ---------------------------------
//  __  __   _ _____ _  _
// |  \/  | /_\_   _| || |
// | |\/| |/ _ \| | | __ |
// |_|  |_/_/ \_\_| |_||_|

LEGACYSHELLMATHEXTENSIONS

extendMath(Math);

// [LS] ######## Horseshit ---------------------------------
//  _  _  ___  ___  ___ ___ ___ _  _ ___ _____
// | || |/ _ \| _ \/ __| __/ __| || |_ _|_   _|
// | __ | (_) |   /\__ \ _|\__ \ __ || |  | |
// |_||_|\___/|_|_\|___/___|___/_||_|___| |_|

//Q: What is "horseshit"?
//A: Stuff to do with ads and trackers. Most if not all is now disabled - nice.

function ga() {
    //yeah screw the tracker
};

function fetchHouseAds() {
    getRequest(parsedUrl.root + "housePromo.json?" + Date.now(), function (err, res) {
        err ? (houseAds = {
            big: [],
            small: [],
            houseAdPercentChance: 100
        }, houseAdsLoaded = true) : (houseAds = JSON.parse(res), houseAdsLoaded = true, function () {
            for (var adIdxs = [], i = 0; i < houseAds.small.length; i++) houseAds.small[i].active && adIdxs.push(i);
            0 < adIdxs.length && (smallAdIdx = adIdxs[Date.now() % adIdxs.length], document.getElementById("houseAd_300x250").src = "img/promo/" + houseAds.small[smallAdIdx].id + houseAds.small[smallAdIdx].imageExt)
        }())
    })
};

function hideBigAd() {
    clearTimeout(bigAdTimeout), document.getElementById("bigAd").style.display = "none", loadBannerAd()
};

function uglifyLogs () { //oh no! it isnt ever called! ah, so sad...
    window.console = function (origConsole) {
        window.console && origConsole || (origConsole = {});
        var logArray = [];
        return {
            dir: function () {
                origConsole.dir && origConsole.dir.apply(origConsole, arguments)
            },
            log: function () {
                this.addLog(arguments), origConsole.log && origConsole.log.apply(origConsole, arguments)
            },
            warn: function () {
                this.addLog(arguments), origConsole.warn && origConsole.warn.apply(origConsole, arguments)
            },
            error: function () {
                this.addLog(arguments), origConsole.error && origConsole.error.apply(origConsole, arguments)
            },
            info: function () {
                this.addLog(arguments), origConsole.info && origConsole.info.apply(origConsole, arguments)
            },
            addLog: function (args) {
                var msg = args[0];
                "object" == typeof msg && (msg = JSON.stringify(msg)), logArray.push(msg), 100 < logArray.length && logArray.shift()
            },
            logArray: function () {
                return logArray
            },
            clearLog: function () {
                logArray = []
            }
        }
    }(window.console);

    //this is fucking shit. why is this here? what does this achieve? its awful for debugging, it doesnt hide the fucking crashes from the end user. so why is it here????
    // window.onerror = function (msg, url, lineNo, columnNo, error) {
    //     var str = ["Message: " + msg, "URL: " + url, "Line: " + lineNo, "Column: " + columnNo].join("\n");
    //     return str += JSON.stringify(error, ["message", "arguments", "type", "name"]) + "\n", console.log(str), false
    // };
};

function PlayerReward(tag, openUrl, openUrlMsg) { //unused in legacyshell
    this.tag = tag, this.openUrl = openUrl, this.openUrlMsg = openUrlMsg, this.wasUrlOpened = null
};

//this could go into bs but eh.
parsedUrl.query.adTest && (adTest = true);
var lastBannerLoaded, aipBannerDisplayed = false,
    aipMultisizeBannerDisplayed = false;

function loadBannerAd() {
    if ("none" == document.getElementById("overlay").style.display) {
        document.getElementById("placeholder_300x250").style.display = "none";
        // document.getElementById("multisizeBannerAdPlaceholder").style.display = "none";
        if (inGame && betweenRounds) displayBannerAd("bannerAdContainer", "houseAd_300x250"), ga("send", "event", {
            eventCategory: "House banner ad",
            eventAction: "show",
            eventLabel: houseAds.small[smallAdIdx].label
        });
        else if (inGame) {
            // if (true !== playerAccount.hideAds) displayBannerAd("gameAdContainer", tag = "shellshock-io_multisize"), loadMultisizeAd(tag)
        } else {
            // if (true === playerAccount.hideAds && (0 === houseAds.houseAdPercentChance || 0 === houseAds.small.length)) return void (document.getElementById("menuAdContainer").style.display = "none");
            // if (100 * Math.random() <= houseAds.houseAdPercentChance || true === playerAccount.hideAds) return void displayBannerAd("bannerAdContainer", "houseAd_300x250");
            // var tag;
            // displayBannerAd("bannerAdContainer", tag = "shellshock-io_300x250"), aipBannerDisplayed ? aiptag.cmd.display.push(function () {
            //     aipRefreshBannerForTag(tag)
            // }) : (aiptag.cmd.display.push(function () {
            //     aipDisplayBannerForTag(tag)
            // }), aipBannerDisplayed = true)
        }
    };
};

// window.onbeforeunload = function (e) { //glowing stuff
//     if (0 < gameStartTime) {
//         var timePlayed = Date.now() - gameStartTime;
//         if (ga("send", "timing", "game", "play time", timePlayed), fbq("trackCustom", "EndGame", {
//             timePlayed: timePlayed
//         }), me && 0 < kills) {
//             var ratio = Math.floor(kills / Math.max(kills + deaths, 1) * 100);
//         }
//     }
//     if (4 < pingSamples) {
//         ga("send", "timing", "game", "ping", Math.floor(pingTotal / pingSamples), servers[selectedServer].name);
//         ga("send", "event", "game", "stats", "fps", Math.ceil(fpsTotal / fpsSamples));
//         ga("send", "event", "game", "settings", "volume", settings.volume);
//         ga("send", "event", "game", "settings", "mouse sensitivity", settings.mouseSensitivity);
//         ga("send", "event", "game", "settings", "mouse invert", settings.mouseInvert);
//     };
// };

function loadMultisizeAd(tag) { //no
    // console.log("loading multisize ad"), aipMultisizeBannerDisplayed ? aiptag.cmd.display.push(function () {
    //     aipRefreshBannerForTag(tag)
    // }) : (aiptag.cmd.display.push(function () {
    //     aipDisplayBannerForTag(tag)
    // }), aipMultisizeBannerDisplayed = true)
};

//why is this code so fucking sketchy
// i = window;
// s = document;

function displayBannerAd(parentContainerId, id) { //sod off
    // var el = document.getElementById(parentContainerId);
    // el.style.display = "block";
    // for (var i = 0; i < el.children.length; i++) el.children[i].id == id ? (document.getElementById(id).style.display = "block", lastBannerLoaded = id) : document.getElementById(el.children[i].id).style.display = "none"
};

function hideBannerAd() {
    // hideBannerAdInContainer("bannerAdContainer", "placeholder_300x250")
};

function hideMultisizeBannerAd() {
    // hideBannerAdInContainer("gameAdContainer", "multisizeBannerAdPlaceholder"), aiptag.cmd.display.push(function () {
    //     aipDisplayTag.destroy("shellshock-io_multisize")
    // })
};

function hideBannerAdInContainer(parentContainerId, placeholderId) {
    // for (var el = document.getElementById(parentContainerId), i = 0; i < el.children.length; i++) document.getElementById(el.children[i].id).style.display = "none";
    // document.getElementById(placeholderId).style.display = "block"
};

function showBannerAd() {
    // showBannerAdWithPlaceholder("placeholder_300x250")
};

function showBannerAdWithPlaceholder(placeholderId) {
    // document.getElementById(placeholderId).style.display = lastBannerLoaded ? (document.getElementById(lastBannerLoaded).style.display = "block", "none") : "block"
};

function aipDisplayBannerForTag(tag) {
    try {
        aipDisplayTag.display(tag)
    } catch (e) {
        console.log(e)
    }
};

function aipRefreshBannerForTag(tag) {
    // try {
    //     aipDisplayTag.refresh(tag)
    // } catch (e) {
    //     console.log(e)
    // }
};

function playVideoAd() { //no thanks
    // if (true !== playerAccount.hideAds) {
    //     0,
    //         false,
    //         console.log("AIP preroll"),
    //         showDarkOverlay(),
    //         aiptag.cmd.player.push(function () {
    //             try {
    //                 aipPrerollPlayer.startPreRoll()
    //             } catch (e) {
    //                 console.log(e)
    //             }
    //         }),
    //         localStorage.setItem("lastPreRoll", Date.now())
    // }
    // else afterVideoAdComplete()
};

function isTimeToPlayVideoAd() {
    if (true === playerAccount.hideAds) return false;
    var lastPreRoll = getStoredNumber("lastPreRoll", Date.now()),
        timeout = 42e4;
    return adTest && (timeout = 2e3), 1 < timesPlayed && 1 < deaths && Date.now() > lastPreRoll + timeout
}

function setApplixirPopup(show) {
    var applixirPopup = document.getElementById("applixirPopup"),
        applixirParentFrame = document.getElementById("applixir_parentFrame");
    if (true === show) {
        applixirPopup.classList.remove("hideme");
        var frameSrc = "app_nugget/applixir.html?firebaseId=" + playerAccount.firebaseId;
        frameSrc += "&reward=nugget", applixirParentFrame.src = frameSrc
    } else applixirPopup.classList.add("hideme"), applixirParentFrame.src = "about:blank"
};

function showSmallAd() { //no.
    // loadBannerAd(), swiftShaderCheck()
};

// function afterVideoAdComplete() {
//     inGame ? (hideDarkOverlay(), timedGame && (openGameMenu(), showGameSummary(), resetGame())) : isGettingNugget ? buyChickenNuggetProduct() : (hideDarkOverlay(), joinGame()), BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume)
// };

function swiftShaderCheck() {
    if ("Google SwiftShader" != engine.getGlInfo().renderer || localStorage.getItem("swiftShaderNotice")) return false;
    return openAlertDialog("SwiftShader? GROSS!", '<div style="text-align: left">It looks like your graphics card is on Chrome\'s blacklist for some reason. The game will still run, but very slowly. To change this, enter "chrome://flags" in your address bar, search for "Override software rendering list", and enable it.<br><br>CAUTION: The blacklist exists for a reason. This may make your system unstable. Make sure you save anything you\'re working on before trying it!</div>', "OK"), localStorage.setItem("swiftShaderNotice", true), true
};

function detectChromebook() {
    return /\bCrOS\b/.test(navigator.userAgent)
};

function unbloated2() { //no thanks!
    // console.log("Sending gameplay tags to OneSignal...");
    // var gameplayTags = {
    //     username: username,
    //     fps: Math.floor(fpsAverage)
    // };
    // unbloated3(gameplayTags), console.log("tags: " + JSON.stringify(gameplayTags))
};

function unbloated3(tags) { //nope! thanks!
    // OneSignal.push(function () {
    //     OneSignal.sendTags(tags).then(function (tagsSent) {
    //         console.log("Completed sending tags to OneSignal")
    //     })
    // })
};

// [LS] ######## Loading ---------------------------------
//  _    ___   _   ___ ___ _  _  ___
// | |  / _ \ /_\ |   \_ _| \| |/ __|
// | |_| (_) / _ \| |) | || .` | (_ |
// |____\___/_/ \_\___/___|_|\_|\___|


// [LS] Load Sequence: Startup
function onPageLoaded () {
    selectedServer = getStoredNumber("selectedServer", 0);
    lastVer = getStoredString("lastVersionPlayed", version);
    localStorage.setItem("lastVersionPlayed", version);
    localStorage.uuid = localStorage.uuid || Math.randomInt(1,4294967295);

    if (lastVer != version) return (req = window.indexedDB.deleteDatabase("babylonjs")).onerror = function (event) {
        window.location.reload(true)
    }, void (req.onsuccess = function (event) {
        window.location.reload(true)
    });

    // var req;

    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
    var str = "",
        missingFeatures = 0;
    BABYLON.Engine.isSupported() || (str += '<li>WebGL (<a href="'+location.href+'faq.html#webgl" target="_window">More info</a>)', missingFeatures++);
    (!document.exitPointerLock || 0 <= navigator.userAgent.indexOf("10.1.2 Safari")) && (str += '<li>Pointer Lock (<a href="'+location.href+'faq.html#pointerlock" target="_window">More info</a>)', missingFeatures++);
    localStorage || (str += "<li>LocalStorage", missingFeatures++);
    void 0 === new KeyboardEvent("").key && (str += "<li>KeyboardEvent.key", missingFeatures++);


    if (0 < missingFeatures) {
        str = 1 == missingFeatures ? "Your browser is missing a feature that LegacyShell requires:<br><ul>" + str + "</ul>" : "Your browser is missing features that LegacyShell requires:<br><ul>" + str + "</ul>";
        openAlertDialog("Oh, no!", '<div style="text-align: left">' + (str += "Downloading the latest version of your browser of choice will usually correct this. Internet Explorer is not supported.") + "</div>");
    } else {
        chatInEl = document.getElementById("chatIn");
        chatOutEl = document.getElementById("chatOut");
        killEl = document.getElementById("killTicker");
        "undefined" != typeof noAdBlock && (adBlock = false);

        // document.getElementById("privacyOptionsLink").style.display = isFromEU ? "block" : "none";
        gameType = getStoredNumber("gameType", 0);

        var gameTypeSelect = document.getElementById("gameTypeSelect");

        var randomisedEl = document.createElement("option");
        randomisedEl.textContent = "[Random Mode]";
        gameTypeSelect.appendChild(randomisedEl);

        for (i = 0; i < GameTypes.length; i++) {
            var gt = GameTypes[i];
            gt.el = document.createElement("option");
            gt.el.textContent = gt.longName;
            gameTypeSelect.appendChild(gt.el);
        };

        gameTypeSelect.selectedIndex = gameType;

        (function () {
            var container = document.getElementById("bindingsContainer");
            for (var k in settingsKeyNames) {
                var row = document.createElement("div");
                var keyCell = document.createElement("span");
                keyCell.className = "box defined";
                keyCell.innerText = getLocText("ui_settings_undefined");
                keyCell.tabIndex = 1;
                keyCell.id = settingsKeyNames[k];
                keyCell.onmousedown = configKey;
                keyCell.onwheel = configKey;
                settingsKeyCells[settingsKeyNames[k]] = keyCell;
                row.appendChild(keyCell);
                var nameCell = document.createElement("span");
                nameCell.className = "label", nameCell.innerText = getLocText("ui_settings_bind_" + settingsKeyNames[k]), row.appendChild(nameCell), container.appendChild(row)
            };
        }());
        
        loadSettings();

        refreshMapPool();

        var playerList = document.getElementById("playerList");
        var slotTemplate = document.getElementById("playerSlot");
        for (i = 0; i < maxServerSlots; i++) {
            var slot = slotTemplate.cloneNode(true);
            playerList.appendChild(slot)
        };

        for (var containerEl = document.getElementById("leaderboard"), team = 0; team < 3; team++) {
            var teamEl = document.getElementById("teamSummary").cloneNode(true);
            teamEl.style.color = teamColors.text[team], teamEl.style.backgroundColor = teamColors.summaryBackground[team], teamSummaryEls.push(teamEl);
            teamEl.children[0];
            for (var i = 0; i < 20; i++) {
                var rowEl = document.getElementById("teamRow").cloneNode(true);
                rowEl.children[0].innerText = i + 1, rowEl.style.display = "flex", rowEl.style.background = i % 2 == 0 ? "rgba(0, 0, 0, 0.25)" : "transparent", teamEl.appendChild(rowEl)
            };
            containerEl.appendChild(teamEl)
        };

        fetchTwitchStreams();
        fetchHouseAds();
        resize();
        console.log("From EU: " + isFromEU);
        itemRenderer = new ItemRenderer;
        canvas = document.getElementById("canvas");
        engine = new BABYLON.Engine(canvas, true, null, false);
        engineCaps = engine.getCaps();
        BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume);
        0 == settings.volume ? BABYLON.Engine.audioEngine.audioContext.suspend() : BABYLON.Engine.audioEngine.audioContext.resume();
        settings.autoDetail || settings.highRes || lowerResolution();

        parsedUrl.query.openSettings && openSettingsMenu();
        parsedUrl.query.test && (testing = true);
        parsedUrl.query.noSkybox && (noSkybox = true);

        if (parsedUrl.query.testMap) {
            playOffline = true;
            mapTest.x = parsedUrl.query.x;
            mapTest.y = parsedUrl.query.y;
            mapTest.z = parsedUrl.query.z;
            mapTest.pitch = parsedUrl.query.pitch;
            mapTest.yaw = parsedUrl.query.yaw;
            playerLimit = 1;
            ws = {
                send: function () { }
            };
            inGame = true;
            engine.stopRenderLoop();
            void startGame();
            return;
        };

        let authToken = localStorage.getItem("LegacyShellAuthToken");
        let previousUsername = localStorage.getItem("LegacyShellPreviousUsername");
        try {
            if (authToken) {
                showSpinner("Retrieving Account", "I KNOW you're in here somewhere...");
                devlog("awaiting............");
                validateLoginViaAuthToken(previousUsername, authToken).then(result => {
                    // hideSpinner(); //will be hidden on resources loaded anyway
                    devlog(result);
                    if (result.error) {
                        devlog("fail 4");
                        showSpinner("Login Failed", result.error);
                        loginFail(result.error === "Too many requests. Please try again later."); //ratelimited
                    } else if (result.session) {
                        showSpinner("Logged In", "It's coming!");
                        loggedIn(result);
                    };
                }).catch((err) => {
                    devlog("damn", err)
                    // hideSpinner();
                    devlog("fail 3");
                    loginFail(true);
                });
            } else {
                devlog("fail 2");
                loginFail();
            };
        } catch (error) {
            devlog("fail 1");
            loginFail();
        };

        if (parsedUrl.hash) {
            openJoinBox();
            document.getElementById("joinCode").value = parsedUrl.hash;
        };
        var nameBox = document.getElementById("nickname");
        nameBox.value = getStoredString("lastNickname", "");
        nameBox.addEventListener("keyup", function (event) {
            nameBox.value = fixStringWidth(event.target.value);
            "Enter" != event.code && 13 != event.keyCode || 0 < nameBox.value.length && (nameBox.disabled = true, play());
        });
    };
};
window.onload = onPageLoaded;

// [LS] Load Sequence: Joining and prepping the game
function play() { //1st, button pressed on menu
    console.log("play()");
    dismissNotification();
    if (0 < settings.volume) try {
        BABYLON.Engine.audioEngine.audioContext.resume()
    } catch (e) {
        console.log(e)
    };
    if (0 == (nickname = document.getElementById("nickname").value.trim()).length) {
        nickname = randomName();
    };
    document.body.scrollTop = document.documentElement.scrollTop = 0;
    timesPlayed = getStoredNumber("timesPlayed", 0);
    localStorage.setItem("timesPlayed", timesPlayed + 1);

    // var lastPreRoll = getStoredNumber("lastPreRoll", 0);
    // 0 == lastPreRoll && (lastPreRoll = Date.now(), localStorage.setItem("lastPreRoll", lastPreRoll)), adTest || Date.now() > lastPreRoll + 3e5 && timesPlayed % 2 == 1 && false ? (console.log("play() calls PVA"), playVideoAd()) : joinGame()

    joinGame();
};

function joinGame(joinGameIdPassed) { //2nd, request made to server to find game. handles cases where game isnt found
    if (ws && ws.readyState === ws.OPEN) {
        ws.close(Comm.Close.mainMenu); //for when switching
    };

    stopAllSounds();

    plugins.emit('joinGame', { joinGameIdPassed });

    autocomplete.clear();

    var url;
    joinResult = null;
    var server = selectedServer;
    joinType = Comm.Code.joinPublicGame;
    var protocol = "ws://";
    "https:" === location.protocol && (protocol = "wss://");
    console.log("joinGame()", protocol);

    var joinGameId = joinGameIdPassed || document.getElementById("joinCode").value.trim().slice(-7);
    var mapId = 0;

    autoInvite = false;

    if ("none" != document.getElementById("createGame").style.display) {
        joinType = Comm.Code.createPrivateGame;
        url = protocol + servers[server].address;
        var listId = document.getElementById("mapSelect").selectedIndex - 1;
        
        if (listId < 0) {
            mapId = 255; //interpreted as random map by server
            //Math.randomInt(0, currentMapPool.length)
        } else {
            mapId = currentMapPool[listId].id;
            // mapId = listId;
            autoInvite = true;
        };
    } else if ("" != joinGameId) {
        joinType = Comm.Code.joinPrivateGame;
        joinGameId.startsWith("#") && (joinGameId = joinGameId.substr(1));

        server = Number.parseInt(joinGameId.substr(0, 1), 36);
        gameId = Number.parseInt(joinGameId.substr(1, 3), 36);
        gameKey = Number.parseInt(joinGameId.substr(4, 2), 36);

        try {
            devlog(protocol, servers, server);
            url = protocol + servers[server].address;
        } catch (e) {
            return console.log("Game not found - Invalid server: " + url + ", " + server), openAlertDialog("Game Not Found", "Sorry! This game ID is either<br>invalid, or no longer exists.", {
                label: "OK",
                onclick: inGame ? showMainMenu : closeAlertDialog
            }), gameKey = gameId = 0, void (document.getElementById("joinCode").value = "")
        };
        selectedServer = server
    } else url = protocol + servers[server].address;
    showDarkOverlay();
    showSpinner("Connecting", "Please wait!");
    console.log("Connecting to: " + url);
    (ws = new WebSocket(url)).binaryType = "arraybuffer";

    ws.onopen = function (e) {
        console.log("WebSocket opened");
        localStorage.setItem("lastNickname", nickname);

        // devlog(gameType, gameType < 0 ? 255 : gameType);

        //added dynamic output buffer size so this isnt necessary. trust me: the "performance" ISNT WORTH IT
        // var len = 16 + 2 * nickname.length;
        // if (playerAccount.isLoggedIn) {
        //     console.log("session available", len);
        //     len += (1 + (2 * playerAccount.session.length));
        // };

        var output = new Comm.Out(); //len
        output.packInt8(Comm.Code.joinGame);
        output.packInt8(joinType);
        output.packInt8(gameType < 0 ? 255 : gameType);
        output.packInt8(mapId);
        output.packInt16(gameId);
        output.packInt16(gameKey);
        output.packInt8(playerAccount.classIdx);
        output.packInt8(catalog.get8BitItemId(playerAccount.getPrimaryWeapon(), playerAccount.classIdx));
        output.packInt8(catalog.get8BitItemId(playerAccount.getSecondaryWeapon(), playerAccount.classIdx));
        output.packInt8(playerAccount.colorIdx);
        output.packInt8(catalog.get8BitItemId(playerAccount.hatItem, playerAccount.classIdx));
        output.packInt8(catalog.get8BitItemId(playerAccount.stampItem, playerAccount.classIdx));
        output.packString(nickname);
        output.packInt32U(Number(localStorage.uuid) || Math.randomInt(1,4294967295));

        if (playerAccount.isLoggedIn) {
            output.packString(playerAccount.session);
            // devlog(len, output)
            // output.packString(playerAccount.account_id);
            // console.log("account_id: " + playerAccount.account_id);
            // devlog(len, output);
        };
        wsSend(output, "joinGame");
    }, ws.onclose = function (e) {
        if (!freezeFrame)
            if (e.code == Comm.Close.gameNotFound) {
                console.log("Game not found - id: " + gameId + ", key: " + gameKey);
                openAlertDialog("Game Not Found", "Sorry! This game ID is either<br>invalid, or no longer exists.", {
                    label: "OK",
                    onclick: inGame ? showMainMenu : closeAlertDialog
                });
                gameKey = gameId = 0;
                document.getElementById("joinCode").value = "";
            } else if (e.code == Comm.Close.gameFull) {
                console.log("Game full - id: " + gameId + ", key: " + gameKey);
                openAlertDialog("Game Full", "Sorry, this game is currently full!<br>Wait a moment, or try another one!", {
                    label: "OK"
                });
            } else if (e.code == Comm.Close.badName) {
                closeAlertDialog();
                openAlertDialog("Invalid Name", "I'm going to guess you know why.", {
                    label: "Yes"
                });
                var el = document.getElementById("nickname");
                el.value = "";
                el.disabled = false;
                el.focus();
                document.getElementById("playButton").disabled = false;
            } else if (e.code == Comm.Close.mainMenu) {
                console.log("WebSocket closing - returning to Main Menu");
            } else if (e.code == Comm.Close.masterServerBusy) {
                console.log("Master Server busy");
                openAlertDialog("Matchmaker Busy", "Sorry! The match-maker is currently busy serving other players.<br>Please try again in a moment!", {
                    label: "OK"
                });
                gameKey = gameId = 0;
                document.getElementById("joinCode").value = "";
            } else if (e.code == Comm.Close.masterServerOffline) {
                console.log("Master Server offline");
                openAlertDialog("Matchmaker Offline", "Oops! The match-maker is currently inaccessible.<br>Drop us a line and let us know!", {
                    label: "OK"
                });
                gameKey = gameId = 0;
                document.getElementById("joinCode").value = "";
            } else if (inGame && e.code !== Comm.Close.booted) {
                console.log("Connection lost: " + e.code + " " + e.reason);
                openAlertDialog("Connection Lost", "Please try a different server,<br>or try again later!", {
                    label: "OK",
                    onclick: reloadPage
                });
            } else {
                console.log("Cannot connect: " + e.code + " " + e.reason, e);
                devlog(String(e.code), String(Comm.Close.booted), String(e.code) == String(Comm.Close.booted));
                var message = "";

                if (joinResult == Comm.Code.banned || e.code == Comm.Close.booted) {
                    message = "You are not allowed to join this game.<br><br>Maybe you know why?";
                } else {
                    message = 'Please try a different server, reload<br>the page, or try again later!<br><br>Also, visit <a href="http://websocketstest.com" target="_window">websocketstest.com</a> to check for<br>problems with your network and/or system!'
                };

                openAlertDialog("Cannot Connect", message, {
                    label: "OK",
                    onclick: inGame ? showMainMenu : closeAlertDialog
                })
            }
    }, ws.onmessage = function (e) {
        var input = new Comm.In(e.data);
        var joinResult = input.unPackInt8U();
        devlog("joinResult", joinResult, Comm.Code.gameJoined, joinResult == Comm.Code.gameJoined, joinResult === Comm.Code.gameJoined);
        switch (joinResult) {
            case Comm.Code.gameJoined:
                console.log("Comm.Code.gameJoined received");
                document.getElementById("mainMenu").style.display = "none";
                meId = input.unPackInt8U();
                myTeam = input.unPackInt8U();
                gameType = input.unPackInt8U();
                gameId = input.unPackInt16U();
                gameKey = input.unPackInt16U();
                mapIdx = input.unPackInt8U();
                playerLimit = input.unPackInt8U();
                isGameOwner = 1 == input.unPackInt8U();
                console.log("is game owner: " + isGameOwner);
                // devlog("meId, myTeam, gameType, gameId, gameKey, mapIdx, playerLimit, isGameOwner", meId, myTeam, gameType, gameId, gameKey, mapIdx, playerLimit, isGameOwner);
                devlog("mgameType", gameType);
                inGame = true;
                startGame();
                break;
        };
    };
};

var unfocused = false;

function startGame () { //3rd, initialises much of the game's variables, creates scene.
    //no thanks!
    // var oneSignalBell = document.getElementById("onesignal-bell-container");
    // oneSignalBell && (oneSignalBell.style.display = "none");

    gameOptions = JSON.parse(JSON.stringify(GameTypes[gameType].options)); //create copy of object

    document.getElementById("showBuyPassDialogButton").classList.add("hideme");
    document.getElementById("upgradeIndicator").classList.add("ingame");
    players = [], {};
    oldClockSeconds = viewingPlayer = me = respawnTime = null;
    grenadePowerUp = betweenRounds = !(escPressed = true);
    lastTimeStamp = performance.now(), 0;
    ping = 0;
    bestOverallStreak = deaths = kills = fpsAverage = fpsSamples = fpsTotal = pingSamples = pingTotal = highestPing = 0;
    gameStartTime = Date.now(), Date.now() + 1e3;
    engine.clear(BABYLON.Color3.Black());
    engine.stopRenderLoop();
    gameScene = new BABYLON.Scene(engine);
    settings.autoDetail || (gameScene.shadowsEnabled = settings.shadowsEnabled);
    gameScene.autoClear = false;
    gameScene.autoClearDepthAndStencil = false;
    settings.autoDetail && enableAutoDetail();

    gameScene.ambientColor = new BABYLON.Color3(.2, .2, .2);
    gameScene.fogMode = BABYLON.Scene.FOGMODE_EXP;
    gameScene.fogColor = new BABYLON.Color4(.5, .55, .6, 1);
    gameScene.fogDensity = .025;
    gameScene.clearColor = BABYLON.Color3.Black();

    shadowLight = new BABYLON.DirectionalLight("", new BABYLON.Vector3(0, -1, 0), gameScene)
    shadowLight.lightmapMode = BABYLON.Light.LIGHTMAP_SHADOWSONLY;
    shadowLight.intensity = 1.2;
    shadowLight.autoUpdateExtends = false;
    shadowLight.shadowMinZ = .05;
    shadowLight.shadowMaxZ = 40;
    shadowLight.shadowFrustumSize = 15;
    
    // shadowLight.direction = gameScene.sunLight.direction;
    // shadowLight.direction.x = -1 * shadowLight.direction.x;
    // shadowLight.direction.y = -1 * shadowLight.direction.y;
    // shadowLight.direction.z = -1 * shadowLight.direction.z;

    //todo: shadow improver
    shadowGen = new BABYLON.ShadowGenerator(1024 * (fancyShadows ? 7 : 1), shadowLight);
    shadowGen.forceBackFacesOnly = true;

    gameScene.sunLight = new BABYLON.HemisphericLight("sunLight", new BABYLON.Vector3(0, -1, 0), gameScene);
    gameScene.sunLight.intensity = .8;
    camera = new BABYLON.TargetCamera("camera", BABYLON.Vector3.Zero(), gameScene);

    gameScene.activeCameras.push(camera);

    camera.maxZ = 100;
    camera.fov = 1.25;
    camera.minZ = .01;

    (uiCamera = new BABYLON.FreeCamera("uiCamera", new BABYLON.Vector3(0, 0, -1), gameScene)).mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
    uiCamera.layerMask = 536870912;
    uiCamera.autoClear = false;
    gameScene.activeCameras.push(uiCamera);
    nameTexture = new BABYLON.DynamicTexture("", 2048, gameScene, true, 2);
    (nameSprites = new BABYLON.SpriteManager("", "", 24, {
        width: 512,
        height: 256
    }, gameScene)).fogEnabled = false;
    nameSprites.texture = nameTexture;
    window.onfocus = function () {
        lastTimeStamp = performance.now();
    };
    window.onblur = function () { };

    unfocused = false;

    document.onpointerlockchange = function () {
        if (me) {
            if (!unfocused) {
                if (document.pointerLockElement) hideGameMenu();
                else {
                    lastKey = null;
                    me.controlKeys = 0;
                    me.releaseTrigger();

                    if (escPressed) {
                        var output = new Comm.Out(1);
                        output.packInt8(Comm.Code.pause);
                        wsSend(output, "pause");
                        setRespawnTime(5);
                        timeout.set(function () {
                            me.removeFromPlay();
                        }, 3e3);
                    };
                    "none" == document.getElementById("overlay").style.display && showGameMenu()
                };
                escPressed = true;
            };
        };
    };

    //this was an IIF for some reason. noting in case it was important???
    chatOutEl.innerHTML = "";
    if (settings.enableChat == 1) {
        initChatIn();
        chatOutEl.style.display = "block";
        chatInEl.style.display = "block";
    };
    killEl.innerHTML = "";
    chatOutEl.value = "";
    hideMultisizeBannerAd();
    // document.getElementById("gameAdContainer").style.display = "none";
    document.getElementById("killBox").style.display = "none";
    document.getElementById("deathBox").style.display = "none";
    document.getElementById("scopeBorder").style.display = "none";
    document.getElementById("help").style.display = "block";
    document.getElementById("tipContainer").style.display = "none";
    document.getElementById("goButton").className = "ssbutton green";
    document.getElementById("goButtonLabel").innerHTML = " PLAY!&nbsp;";
    document.getElementById("gameClock").style.display = "none";
    document.getElementById("gameClock").style.fontSize = "2em";
    document.getElementById("bestStreak").style.display = "block";
    hideGameSummary();
    setTeamButton();
    console.log("resetGameUI");
    //end IIF

    var helpEl = document.getElementById("helpControls");
    helpEl.innerHTML = "";
    var helpSlots = {
        up: null,
        down: null,
        left: null,
        right: null,
        jump: null,
        fire: null,
        scope: null,
        reload: null,
        weapon: null,
        grenade: null
    };
    for (var k in inputToControlMap) helpSlots[inputToControlMap[k]] = k;
    var count = 0;
    for (var k in helpSlots) helpEl.innerHTML += helpSlots[k], count++, helpEl.innerHTML += 4 <= count ? "<br>" : " ";
    if (!gameOptions.teamsEnabled) {
        document.getElementById("teamButtonContainer").style.display = "none";
        document.getElementById("goButton").style.height = "6.5em";
    } else {
        document.getElementById("teamButtonContainer").style.display = "block";
        document.getElementById("goButton").style.height = "4em";
    };
    document.body.style.overflow = "hidden";

    loadResources(gameScene, onLoadingComplete);
};

function loadResources(scene, onComplete) { //4th, orchestrator function for materials, sounds, meshes, map
    devlog("loadResources");
    Sounds = {};
    loadMaterials(scene);

    loadSounds(function () {
        soundsLoaded = true;

        loadObjectMeshes(scene, function () {
            loadMapMeshes(scene, function () {
                onComplete();
            })
        });
    });
};

function loadMaterials(scene) { //5th, defines materials
    var mat;

    mat = new BABYLON.StandardMaterial("bullet", scene);
    mat.emissiveColor = new BABYLON.Color3(1, 1, 1);

    if (shadowGen) {
        var definesList = ["#define RECEIVESHADOWS"];
        engineCaps.textureFloat && definesList.push("#define SHADOWFULLFLOAT")
    } else definesList = [];
    definesList.push("#define DIRT");
    mat = new BABYLON.ShaderMaterial("map", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "sunColor"],
        defines: definesList
    });
    if (shadowGen) {
        mat.setTexture("shadowSampler", shadowGen.getShadowMapForRendering());
        mat.setMatrix("shadowLightMat", shadowGen.getTransformMatrix());
        mat.setVector3("shadowParams", shadowGen.getDarkness(), shadowGen.getShadowMap().getSize().width, shadowGen.bias);
    };
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
        effect.setColor3("vFogColor", scene.fogColor)
        effect.setFloat3("sunColor", scene.sunLight.diffuse.r, scene.sunLight.diffuse.g, scene.sunLight.diffuse.b);
    };

    mat = new BABYLON.ShaderMaterial("mapNoShadow", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "sunColor"],
        defines: ["#define DIRT"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
        effect.setColor3("vFogColor", scene.fogColor);
        effect.setFloat3("sunColor", scene.sunLight.diffuse.r, scene.sunLight.diffuse.g, scene.sunLight.diffuse.b);
    };

    wetMaterial = new BABYLON.StandardMaterial("wetMaterial", gameScene);
    wetMaterial.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.85);
    wetMaterial.specularColor = new BABYLON.Color3(1, 1, 1);
    wetMaterial.specularPower = 24;

    mat = new BABYLON.ShaderMaterial("standard", scene, "standard", {
        attributes: ["position", "normal", "color", "uv", BABYLON.VertexBuffer.MatricesIndicesKind, BABYLON.VertexBuffer.MatricesWeightsKind],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "colorMult", "sunColor"],
        defines: ["#define COLORMULT"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect();
        var scene = mesh.getScene();

        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
        effect.setColor3("vFogColor", scene.fogColor);
        effect.setColor3("colorMult", mesh.colorMult || BABYLON.Color3.White());
        effect.setFloat3("sunColor", scene.sunLight.diffuse.r, scene.sunLight.diffuse.g, scene.sunLight.diffuse.b);

        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            var matrices = mesh.skeleton.getTransformMatrices(mesh);
            matrices && effect && effect.setMatrices("mBones", matrices)
        }
    };

    mat = new BABYLON.ShaderMaterial("standardInstanced", scene, "standard", {
        attributes: ["position", "normal", "color", "uv", "world0", "world1", "world2", "world3"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "sunColor"],
        defines: ["#define INSTANCES"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect();
        var scene = mesh.getScene();

        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
        effect.setColor3("vFogColor", scene.fogColor);
        effect.setFloat3("sunColor", scene.sunLight.diffuse.r, scene.sunLight.diffuse.g, scene.sunLight.diffuse.b);
    };

    mat = new BABYLON.ShaderMaterial("eggShell", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "hp", "cameraPosition", "outlineColor", "colorMult", "stampOffset", "sunColor"],
        defines: ["#define EGGSHELL"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect(),
            scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
        effect.setColor3("vFogColor", scene.fogColor);
        effect.setFloat("hp", mesh.player.hp / 100);
        effect.setColor3("colorMult", mesh.colorMult || BABYLON.Color3.White());
        effect.setFloat3("cameraPosition", scene.activeCamera.globalPosition.x, scene.activeCamera.globalPosition.y, scene.activeCamera.globalPosition.z);
        effect.setColor4("outlineColor", mesh.outlineColor, mesh.outlineColor.a);
        effect.setFloat2("stampOffset", mesh.stampU, mesh.stampV);
        effect.setFloat3("sunColor", scene.sunLight.diffuse.r, scene.sunLight.diffuse.g, scene.sunLight.diffuse.b);
    };

    mat = new BABYLON.ShaderMaterial("emissive", scene, "standard", {
        attributes: ["position", "normal", "color", "uv"],
        uniforms: ["world", "view", "viewProjection", "vFogInfos", "vFogColor", "emissiveColor", "sunColor"],
        defines: ["#define FLASH"]
    });
    mat.onBind = function (mesh) {
        var effect = mesh.material.getEffect();
        var scene = mesh.getScene();
        effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
        effect.setColor3("vFogColor", scene.fogColor);
        effect.setColor3("emissiveColor", mesh.emissiveColor || BABYLON.Color3.Black());
        effect.setFloat3("sunColor", scene.sunLight.diffuse.r, scene.sunLight.diffuse.g, scene.sunLight.diffuse.b);
    };

    mat = new BABYLON.StandardMaterial("wireframe", scene);
    mat.wireframe = true;

    mat = new BABYLON.StandardMaterial("normalBackface", scene);
    mat.diffuseColor = new BABYLON.Color3(.5, .5, .5);
    mat.ambientColor = new BABYLON.Color3(.5, .5, .5);
    mat.specularColor = new BABYLON.Color3(0, 0, 0);
    mat.backFaceCulling = false;
    mat.twoSidedLighting = true;

    mat = new BABYLON.StandardMaterial("muzzleFlash", scene);
    mat.emissiveColor = BABYLON.Color3.White();

    mat = new BABYLON.StandardMaterial("ui", scene);
    mat.disableLighting = true;
    mat.emissiveColor = BABYLON.Color3.White();
    mat.fogEnabled = false;
};

var soundsLoaded = false;

function loadSounds(onComplete) { //6th, loads sounds (who knew?)
    if (soundsLoaded) {
        onComplete();
        return;
    };
    
    var soundsList =[
    //eggk47
        ["sound/eggk47/fire.mp3", "eggk47.fire"],
        ["sound/eggk47/dry fire.mp3", "eggk47.dryFire"],
        ["sound/eggk47/full cycle.mp3", "eggk47.cycle"],
        ["sound/eggk47/insert mag.mp3", "eggk47.insertMag"],
        ["sound/eggk47/remove mag.mp3", "eggk47.removeMag"],
    //dozenGauge
        ["sound/dozenGauge/fire.mp3", "dozenGauge.fire"],
        ["sound/dozenGauge/open.mp3", "dozenGauge.open"],
        ["sound/dozenGauge/load.mp3", "dozenGauge.load"],
        ["sound/dozenGauge/close.mp3", "dozenGauge.close"],
    //csg1
        ["sound/csg1/fire.mp3", "csg1.fire"],
        ["sound/csg1/pull action.mp3", "csg1.pullAction"],
        ["sound/csg1/release action.mp3", "csg1.releaseAction"],
    //cluck9mm
        ["sound/cluck9mm/fire.mp3", "cluck9mm.fire"],
        ["sound/cluck9mm/remove mag.mp3", "cluck9mm.removeMag"],
        ["sound/cluck9mm/insert mag.mp3", "cluck9mm.insertMag"],
    //rpegg
        ["sound/rpegg/rocketfire.mp3", "rpegg.fire"],
        ["sound/rpegg/rocketfly.mp3", "rpegg.fly"],
        ["sound/rpegg/rockethit.mp3", "rpegg.explode"],
        ["sound/rpegg/rocketload.mp3", "rpegg.load"],
        ["sound/rpegg/rocketpoof.mp3", "rpegg.poof"],
        ["sound/rpegg/rocketdeny.mp3", "rpegg.denyFire"],
    //misc
        ["sound/hammerClick.mp3", "hammerClick"],
        ["sound/ammo.mp3", "ammo"],
        ["sound/shellBurst.mp3", "shellBurst"],
        ["sound/hit.mp3", "hit"],
        ["sound/rooster.mp3", "endRound"],
    //grenade
        ["sound/grenade.mp3", "grenade.explode"],
        ["sound/grenadeBeep.mp3", "grenade.beep"],
        ["sound/grenadePin.mp3", "grenade.pin"],
    //ambiance (puppy :D)
        ["sound/ambiance/rain.mp3", "rain"],
    //healing
        ["sound/health.mp3", "health"],
    ];

    //why did you even load twice? //hush
    // //deaths
    // for (var i = 1; i < 11; i++) {
    //     soundsList.push(["sound/death/scream" + i + ".mp3", "death.scream." + (i-1)]);
    // };

    // loadSoundsFromList(soundsList, onComplete);

    //deaths, with cue
    let deathsSrcs = [];
    for (var i = 1; i < 11; i++) {
        deathsSrcs.push("sound/death/scream" + i + ".mp3");
    };

    loadCue("death.scream", deathsSrcs);

    //deaths, with cue
    let thunderSrcs = [];
    for (var i = 1; i < 4; i++) {
        thunderSrcs.push("sound/ambiance/thunder" + i + ".mp3");
    };

    loadCue("thunder", thunderSrcs);

    loadSoundsFromList(soundsList, onComplete);
};

function loadObjectMeshes (scene, onComplete) { //7th, loads basically all the things in the models/ folder (name from deobf leak)
    // loadMeshes(scene, "models.zip", null, onComplete);

    //old
    loadMeshes(scene, [
        "egg",
        "gun_eggk47",
        "gun_csg1",
        "gun_cluck9mm",
        "gun_dozenGauge",
        "gun_rpegg",
        "munitions",
        "muzzleFlash",
        "items",
        "reticle"
    ], null, onComplete);
};

//8th is defined below from the import

function onLoadingComplete() { //9th (callback of loadResources)
    console.log("onLoadingComplete");
    Collider = new ColliderConstructor(gameScene);
    loadMap(onMapComplete);
};

function loadMap(onComplete) { //10th, (name from deobf leak)
    function complete() {
        hideSpinner();
        onComplete();
    };

    showSpinner("Building Map", "Hold on!");

    createMapCells(function () {
        showSpinner("Building Map", "Turning on the lights...");
        generateLightmapAndSkybox(this, complete);
    });
};

var meshIndex, meshNames, createMapCellsCallback;

function setFog() {
    if (minMap.fog) {
        console.log("FOG:", minMap.fog);
        if (minMap.fog.density > 0) {
            gameScene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            gameScene.fogColor = BABYLON.Color3.FromHexString(minMap.fog.color);
            gameScene.fogDensity = minMap.fog.density;
            gameScene.fogEnabled = true;
        } else {
            gameScene.fogEnabled = false;
            gameScene.fogDensity = 0;
        };
    } else {
        gameScene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
        gameScene.fogColor = new BABYLON.Color4(0.5, 0.55, 0.6, 1);
        gameScene.fogDensity = 0.01;
    };
};

function createMapCells(callback) { //11th
    minMap = playOffline ? JSON.parse(localStorage.getItem("mapBackup")) : (console.log("MAP IDX: " + mapIdx), minMaps[mapIdx]);

    devlog("minMap:", minMap);

    if (minMap.sun) {
        gameScene.sunLight.direction = new BABYLON.Vector3(minMap.sun.direction.x, minMap.sun.direction.y, minMap.sun.direction.z);
        gameScene.sunLight.diffuse = BABYLON.Color3.FromHexString(minMap.sun.color)
    } else {
        gameScene.sunLight.direction = new BABYLON.Vector3(.2, 1, .1);
        gameScene.sunLight.diffuse = new BABYLON.Color3.White();
    };
    setFog();
    if (minMap.ambient) {
        gameScene.ambientColor = BABYLON.Color3.FromHexString(minMap.ambient);
    } else {
        gameScene.ambientColor = new BABYLON.Color3(0.2, 0.2, 0.2);
    };

    SPS = new BABYLON.SolidParticleSystem("SPS", gameScene, {
        updatable: true
    });
    SPS.computeParticleColor = false;
    SPS.computeParticleTexture = false;
    SPS.computeParticleRotation = false;
    SPS.recomputeNormals = false;

    meshIndex = buildMapData(function (str) { alert("The following map meshes were not found:\n\n" + str + "\nTry clearing your cache and reload the page!") });
    meshNames = Object.keys(minMap.data);

    //i hate this, but. le sigh... we cringe on.
    createMapCellsCallback = callback;

    var nextFunction = addMeshToMap.bind(this, 0);
    window.requestAnimationFrame(nextFunction);
};

//12th is defined below from the import

function addMeshToMap(keyIdx) { //13th, adds all the shapes to the map and stuff
    if (keyIdx == meshNames.length) return void createMapCellsCallback();
    var meshName = meshNames[keyIdx];
    var meshData = minMap.data[meshName];
    var meshIdx = meshIndex[meshName];
    var mesh = mapMeshes[meshIdx];
    var pct = Math.floor(keyIdx / meshNames.length * 100);
    //fakes making it look like something is happening quickly, i guess
    var msgs = ["Laying", "Cracking", "Making omelettes", "Random clucking", "Scratching", "Scrambling", "Roosting", "Beating", "Making bad yolks", "Thinking of egg puns", "Whipping", "Frying", "Poaching", "Doing something REALLY interesting", "Doing your homework, 'cause SOMEONE has to", "What was I doing? Oh, yeah; map!", "Making you wait, just for clucks", "Watching chicken videos"];
    var msg = msgs[Math.randomInt(0, msgs.length)];
    showSpinner("Building Map", msg + "... " + pct + "%");
    var fields = meshName.split(".");
    mesh.theme = fields[0];
    mesh.colliderType = fields[2];
    mesh.softness = fields[3];
    if ("SPECIAL" != mesh.theme) {
        var i = 0;
        var meshArr = Object.values(meshData);

        SPS.addShape(mesh, meshArr.length, {
            positionFunction: function (particle, idx, shapeIdx) {
                var rx = meshArr[i].rx || 0,
                    ry = meshArr[i].ry || 0,
                    rz = meshArr[i].rz || 0;
                particle.position.x = meshArr[i].x + .5, particle.position.y = meshArr[i].y + .5, particle.position.z = meshArr[i].z + .5, particle.rotation.x = rx * rotInc, particle.rotation.y = ry * rotInc, particle.rotation.z = rz * rotInc, particle.alive = false, i++
            }
        });
    };

    var nextFunction = addMeshToMap.bind(this, keyIdx + 1);
    window.requestAnimationFrame(nextFunction);
};

function generateLightmapAndSkybox(This, complete) { //14th, creates the lightmap (offloaded onto a worker) and skybox
    requestAnimationFrame(function (onComplete) {
        mapMesh = SPS.buildMesh();
        mapMesh.receiveShadows = true;
        console.log("Casting rays");
        var w = map.width + 1;
        var h = map.height + 1;
        var d = map.depth + 1;
        var lightMap = make3DArray(w, h, d, 1.5);
        var lightDir = gameScene.sunLight.direction.clone();

        lightDir.normalize();
        var lightRay = lightDir.clone();
        lightRay.scaleInPlace(1e3);

        var testStep = lightDir.clone();
        testStep.scaleInPlace(.5);

        iterateXYZ(map.width + 1, map.height + 1, map.depth + 1, null, function (lmx, lmy, lmz) {
            var rays = [],
                ray = new BABYLON.Ray(new BABYLON.Vector3(lmx, lmy, lmz), lightRay);
            rays.push(ray);
            var testPos = new BABYLON.Vector3(lmx, lmy, lmz);
            testPos.addInPlace(testStep), testPos.addInPlace(testStep);
            for (var cellsChecked = {}, hits = 0; !(testPos.x < -1 || testPos.x > map.width || testPos.y < -1 || testPos.y > map.height || testPos.z < -1 || testPos.z > map.depth || hits == rays.length);) {
                var cx = Math.floor(Math.clamp(testPos.x + 0, 0, map.width - 1));
                var cy = Math.floor(Math.clamp(testPos.y + 0, 0, map.height - 1));
                var cz = Math.floor(Math.clamp(testPos.z + 0, 0, map.depth - 1));
                var checkId = cx + 1e3 * cy + 1e4 * cz;

                if (!cellsChecked[checkId]) {
                    cellsChecked[checkId] = true;
                    var cell = map.data[cx][cy][cz];
                    if (cell && cell.idx) {
                        var cellMesh = mapMeshes[cell.idx];
                        if ("SPECIAL" != cellMesh.theme) {
                            for (var ri in cellMesh.rotation.x = cell.rx, cellMesh.rotation.y = cell.ry, cellMesh.rotation.z = cell.rz, cellMesh.position.x = cx + .5, cellMesh.position.y = cy + .5, cellMesh.position.z = cz + .5, cellMesh.computeWorldMatrix(), rays) {
                                var ray = rays[ri];
                                if (!ray.hit) {
                                    var pickInfo = ray.intersectsMesh(cellMesh, true);
                                    pickInfo.hit && (ray.hit = true, hits++);
                                };
                            };
                            cellMesh.position = BABYLON.Vector3.Zero();
                        };
                    };
                };
                testPos.addInPlace(testStep);
            };
            0 < hits && (lightMap[lmx][lmy][lmz] = .2);
        });

        console.log("Applying lightmap");

        var colors = mapMesh.getVerticesData(BABYLON.VertexBuffer.ColorKind);
        var positions = mapMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);

        //to perform tricky calculations (for the lightmap) in the background, i think (idk what a worker is lmaooo)
        function worker() {
            self.onmessage = function (e) {
                e = e.data;
                for (var samples, sum, i = 0; i < e.positions.length / 3; i++) {
                    var ix3 = 3 * i,
                        x = e.positions[ix3],
                        y = e.positions[ix3 + 1],
                        z = e.positions[ix3 + 2];
                    sum = samples = 0, iterateXYZ(Math.min(e.w - 1, x + .6), Math.min(e.h - 1, y + .6), Math.min(e.d - 1, z + .6), {
                        x: Math.max(0, x - .6),
                        y: Math.max(0, y - .6),
                        z: Math.max(0, z - .6)
                    }, sumItUp);
                    var l = Math.min(Math.max(sum / samples, .5), 1);
                    e.colors[4 * i] *= l, e.colors[4 * i + 1] *= l, e.colors[4 * i + 2] *= l, i % 1e3 == 0 && postMessage({
                        progress: Math.floor(i / (e.positions.length / 3) * 100)
                    });
                };

                function sumItUp(x, y, z) {
                    var cx = Math.round(x);
                    var cy = Math.round(y);
                    var cz = Math.round(z);
                    samples++, sum += e.lightMap[cx][cy][cz]
                };

                //(this code is duplicated!)
                function iterateXYZ(width, height, depth, options, callback) {
                    var opt = options || {};
                    opt.step = opt.step || 1, opt.x = opt.x || 0, opt.y = opt.y || 0, opt.z = opt.z || 0;
                    for (var x = opt.x; x < width; x += opt.step)
                        for (var y = opt.y; y < height; y += opt.step)
                            for (var z = opt.z; z < depth; z += opt.step) callback(x, y, z)
                };

                postMessage({ colors: e.colors });
            };
        };

        var code = worker.toString();
        code = code.substring(code.indexOf("{") + 1, code.lastIndexOf("}"));
        var worker, blob = new Blob([code], {
            type: "application/javascript"
        });

        worker = new Worker(URL.createObjectURL(blob));
        worker.postMessage({
            colors: colors,
            positions: positions,
            lightMap: lightMap,
            w: w,
            h: h,
            d: d
        });
        worker.onmessage = function (m) {
            if (m.data.hasOwnProperty("progress")) showSpinner("Building Map", "Turning on the lights... " + m.data.progress + "%");
            else {
                function fetchSync(url) {
                    const xhr = new XMLHttpRequest();
                    xhr.open("GET", url, false);
                    xhr.send(null);
                
                    if (xhr.status === 200) {
                        return xhr.responseText;
                    } else {
                        // throw new Error(`Request failed with status: ${xhr.status}`);
                        return false;
                    };
                };

                var lightmapMin;
                if (playOffline) {
                    lightmapMin = localStorage.getItem("lightmap");
                    if (lightmapMin) lightmapMin = JSON.parse(lightmapMin);
                } else {
                    lightmapMin = fetchSync("maps/" + minMap.name + ".lightmap?" + Date.now());
                };
                if (lightmapMin) {
                    devlog("lightmapMin found");
                    var lightmap2 = mapMesh.getVerticesData(BABYLON.VertexBuffer.ColorKind);
                    for (var i2 = 0, j = 0; i2 < lightmapMin.length; i2 += 3, j += 4) {
                        lightmap2[j] = lightmapMin[i2] / 255;
                        lightmap2[j + 1] = lightmapMin[i2 + 1] / 255;
                        lightmap2[j + 2] = lightmapMin[i2 + 2] / 255;
                    };
                    mapMesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, lightmap2);
                } else {
                    mapMesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, m.data.colors);
                };

                mapMesh.material = gameScene.getMaterialByName("map");
                mapMesh.freezeWorldMatrix();
                skybox = null;
                var skyboxName = minMap.skybox || "default";
                setSkybox(skyboxName);
                onComplete()
            };
        };
    }.bind(This, complete));
};

function setSkybox(skyboxName) {
    if (noSkybox) return;
    if (skybox) {
        if (skybox.skyboxName == skyboxName) {
            console.log("Skybox already set to " + skyboxName);
            return;
        };
        skybox.dispose();
        skybox = null;
    };
    skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {
        size: 100
    }, gameScene);
    skybox.infiniteDistance = true;
    skybox.skyboxName = skyboxName;
    skyboxMaterial = new BABYLON.StandardMaterial("skyBox", gameScene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.fogEnabled = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("img/skyboxes/" + skyboxName + "/skybox", gameScene);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE, skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0), skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0), skybox.material = skyboxMaterial
};

function onMapComplete() { //15th,  (callback of loadMap at end of onLoadingComplete)
    document.getElementById("serverAndMapInfo").innerHTML = "Server: " + servers[selectedServer].name + "<br>Map: " + minMap.name + "<br>Gamemode: " + GameTypes[gameType].longName;
    try {
        var output;

        scope = new Scope;
        hitIndicator = new HitIndicator;
        reticle = new Reticle;
        gameScene.getMeshByName("muzzleFlash").material = gameScene.getMaterialByName("muzzleFlash");
        gameScene.getMeshByName("bullet").material = gameScene.getMaterialByName("bullet");
        gameScene.getMeshByName("rocket").material = gameScene.getMaterialByName("standardInstanced");
        gameScene.getMeshByName("grenade").material = gameScene.getMaterialByName("emissive");

        gameScene.getMeshByName("ammo").material = gameScene.getMaterialByName("standardInstanced");
        gameScene.getMeshByName("grenadeItem").material = gameScene.getMaterialByName("standardInstanced");
        plugins.emit('onMapComplete', { gameScene });

        munitionsManager = new MunitionsManagerConstructor(gameScene);
        itemManager = new ItemManagerConstructor();

        bulletHoleManager = new BABYLON.SpriteManager("bulletHoleManager", "img/bulletHoles.png?v=1", 1e3, 32, gameScene);
        bulletHoleManager.fogEnabled = true;
        bulletHoleManager.idx = 0;
        bulletHoleManager.addHole = function (f, x, y, z) {
            var s = bulletHoleManager.sprites[this.idx] || new BABYLON.Sprite("", this);
            s.position.x = x;
            s.position.y = y;
            s.position.z = z;
            s.angle = 6.282 * Math.random();
            s.cellIndex = f;
            s.width = .03;
            s.height = .03
            this.idx = (this.idx + 1) % 1e3;
        };

        (explosionSmokeManager = createParticleManager("particles.png", 300, 1, 1, gameScene)).fogEnabled = true;
        explosionSmokeManager.noAlphaTest = true;
        (explosionFireManager = createParticleManager("particles.png", 300, 1, 1, gameScene)).fogEnabled = true;
        explosionFireManager.blendMode = BABYLON.Engine.ALPHA_ADD;
        (shellFragManager = createParticleManager("particles.png", 400, 3, 6, gameScene)).fogEnabled = true;
        yolkManager = createParticleManager("particles.png", 100, 2, 2, gameScene);
        yolkManager.fogEnabled = true;

        rainParticleSystem = new BABYLON.ParticleSystem("rain", 2000, gameScene);

        rainParticleSystem.particleTexture = new BABYLON.Texture("/img/rain.png", gameScene);

        rainParticleSystem.minEmitBox = new BABYLON.Vector3(-10, 20, -10);
        rainParticleSystem.maxEmitBox = new BABYLON.Vector3(10, 20, 10);

        rainParticleSystem.minSize = 0.05;
        rainParticleSystem.maxSize = 0.1;
        rainParticleSystem.minLifeTime = 1.0;
        rainParticleSystem.maxLifeTime = 1.5;
        rainParticleSystem.emitRate = 2000;

        rainParticleSystem.direction1 = new BABYLON.Vector3(0, -1, 0);
        rainParticleSystem.direction2 = new BABYLON.Vector3(0, -1, 0);
        rainParticleSystem.minEmitPower = 3;
        rainParticleSystem.maxEmitPower = 5;
        rainParticleSystem.updateSpeed = 0.01;

        rainParticleSystem.minScaleX = 0.25;
        rainParticleSystem.maxScaleY = 0.5; 
        rainParticleSystem.minScaleY = 10;
        rainParticleSystem.maxScaleY = 15;
        rainParticleSystem.gravity = new BABYLON.Vector3(0, -30.81, 0);
        rainParticleSystem.isLocal = false;

        gameScene.registerBeforeRender(function () {
            rainParticleSystem.particles.forEach(function (p) {
                var pointCollidesWithMap = Collider.pointCollidesWithMap(p.position);
                if (pointCollidesWithMap) {
                    p.position.y = -1e7;
                };
            });
        });

        if (playOffline) {
            addPlayer({
                id: meId = 0,
                uniqueId: 0,
                name: "Test",
                classIdx: 0,
                team: 0,
                primaryWeaponItem: playerAccount.getPrimaryWeapon(),
                secondaryWeaponItem: playerAccount.getSecondaryWeapon(),
                shellColor: 0,
                hatItem: null,
                stampItem: null,
                score: 0,
                kills: 0,
                deaths: 0,
                streak: 0,
                totalKills: 0,
                totalDeaths: 0,
                bestGameStreak: 0,
                bestOverallStreak: 0,
                x: mapTest.x + .5,
                y: mapTest.y - .32,
                z: mapTest.z + .5,
                dx: 0,
                dy: 0,
                dz: 0,
                frame: 0,
                pitch: mapTest.pitch,
                yaw: mapTest.yaw,
                shield: 0,
                hp: 0,
                playing: false,
                weaponIdx: 0,
                controlKeys: 0,
                randomSeed: 0,
                upgradeProductId: void 0 !== playerAccount.upgradeProductId && null !== playerAccount.upgradeProductId ? playerAccount.upgradeProductId : 0
            });

            players[meId].hp = 100;
            players[meId].isGameOwner = true;
            isGameOwner = true;
            doFirstPersonCamera();
            startRendering();
            addCanvasListeners();
        } else {
            mapOverview = true;
            ws.onmessage = LegacyShellOnMessage;

            (output = new Comm.Out(1)).packInt8(Comm.Code.clientReady);
            wsSend(output, "clientReady");
            (output = new Comm.Out(1)).packInt8(Comm.Code.ping);
            pingStartTime = Date.now();
            wsSend(output, "ping");
        };
    } catch (e) {
        console.log(e)
    };
};

function startRendering() { //16th, starts rendering and game loop
    hideDarkOverlay();
    document.getElementById("game").style.display = "block";
    document.getElementById("readouts").style.display = "block";
    document.getElementById("homeButton").style.display = "inline-block";
    document.getElementById("friendsButton").style.display = "inline-block";
    resize();
    captureKeys();
    mapOverview && doMapOverviewCamera();

    gameScene.registerBeforeRender(mainGameLoop);

  engine.runRenderLoop(function () { gameScene.render(); });
};

LEGACYSHELLLOADING

// [LS] ######## Ingame ---------------------------------
//  ___ _  _  ___   _   __  __ ___
// |_ _| \| |/ __| /_\ |  \/  | __|
//  | || .` | (_ |/ _ \| |\/| | _|
// |___|_|\_|\___/_/ \_\_|  |_|___|

var tickRemaining = 1;

function mainGameLoop () { //17th, this is the final (in a way) stage of the sequence.
  updateListener(camera.globalPosition, camera.getDirection(BABYLON.Vector3.Forward()), camera.upVector);
    (function () {
        var fps = engine.getFps();
        fpsTotal += fps;
        if (++fpsSamples % 10 == 0) {
            fpsAverage = fpsTotal / fpsSamples;
            var fpsEl = document.getElementById("FPS");
            fpsEl.innerText = Math.floor(fps + .5);
            var barEl = document.getElementById("healthBar");
            var hpEl = document.getElementById("healthHp");
            var r = 5 - viewingPlayer.hp / 20;
            barEl.setAttribute("stroke-dashoffset", 6.2832 * r + "vh");
            hpEl.innerText = Math.floor(viewingPlayer.hp);

            if (timedGame) {
                var clockEl = document.getElementById("gameClock");
                var date = new Date(roundEndTime - Date.now() + 1e3);

                if (0 <= date) {
                    var minutes = date.getMinutes(),
                        seconds = date.getSeconds();
                    if (seconds != oldClockSeconds) {
                        var size = 2;
                        0 == minutes && seconds < 11 && (size = 2 + (11 - seconds) / 4), clockEl.style.fontSize = size + "em", clockEl.innerText = minutes + ":" + (seconds < 10 ? "0" : "") + seconds, oldClockSeconds = seconds
                    };
                } else clockEl.innerText = "0:00";
            };
        };

        rainParticleSystem.emitter = me.actor.mesh.position.clone();

        var timeBetweenFps = 1e3 / fpsAverage;
        var percentageOfTick = timeBetweenFps / TickStep;

        var currentTimeStamp = performance.now();
        10 < pingSamples && (highestPing = Math.max(highestPing, ping));

        function updatePlayers(delta, lerpTick) {
            if (freezeFrame) {
                if (!lerpTick) me.update(1);
                me.actor.update(delta);
            } else {
                for (var i = 0; i < players.length; i++) {
                    var player = players[i];
                    if (player) {
                        if (!lerpTick) {
                            player.chatLineCap = Math.min(player.chatLineCap + 1 / chatCooldown, 3); //3 lines per second
                        };
                        if (player.playing) {
                            if (!lerpTick) player.update(1);
                            player.actor.handsToWeaponSkeleton();
                            if (player.actor) {
                                player.actor.update(delta);
                            };
                        };
                    };
                };
            };
        };

        if (!(lastTimeStamp < currentTimeStamp)) { //fps exceeds ingame tickrate
            let thisDelta = Math.clamp(percentageOfTick, 0, tickRemaining);
            updatePlayers(tickRemaining, true);
            tickRemaining -= thisDelta;
            // devlog("lerp tick percTick", percentageOfTick, "thisDelta", thisDelta, "remainTick", tickRemaining);
        } else { //time to run next game tick
            while (lastTimeStamp < currentTimeStamp) {
                // devlog("actual tick", "remainTick", tickRemaining);
                lastTimeStamp += TickStep;

                updatePlayers(tickRemaining);
                tickRemaining = 1;

                if (me) {
                    me.stateBuffer[me.stateIdx] = {
                        delta: 1,
                        yaw: me.yaw,
                        fire: false,
                        jumping: me.jumping,
                        climbing: me.climbing,
                        x: me.x,
                        y: me.y,
                        z: me.z,
                        dx: me.dx,
                        dy: me.dy,
                        dz: me.dz,
                        controlKeys: me.controlKeys
                    };

                    if (me.stateIdx % FramesBetweenSyncs === 0 && ws.readyState === ws.OPEN && me.hp > 0 && !freezeFrame) {
                        serverSync();
                    };

                    hitIndicator.update(1);
                    reticle.update(1);

                    if (me.weapon && me.weapon.ammo.rounds === 0) {
                        var ammoElement = document.getElementById("ammo");
                        if (me.stateIdx % 20 === 0) {
                            ammoElement.style.color = "#f00";
                        } else if (me.stateIdx % 20 === 10) {
                            ammoElement.style.color = "#fff";
                        };
                    };

                    if (grenadePowerUp && grenadeThrowPower < 1) {
                        grenadeThrowPower = Math.min(grenadeThrowPower + 0.015, 1);
                        document.getElementById("grenadeThrowContainer").style.visibility = "visible";
                        document.getElementById("grenadeThrow").style.height = grenadeThrowPower>0? 100 * grenadeThrowPower + "%" : "0%";
                    };
                };

                if (!freezeFrame) {
                    munitionsManager.update(1);
                    itemManager.update(1);
                    updateParticles(explosionSmokeManager, 1);
                    updateParticles(explosionFireManager, 1);
                    updateParticles(shellFragManager, 1);
                    updateParticles(yolkManager, 1);
                };

                if (mapOverview) {
                    mapOverviewAxis += 0.002;
                    camera.position.x = Math.sin(mapOverviewAxis) * map.height + map.width / 2;
                    camera.position.z = Math.cos(mapOverviewAxis) * map.height + map.depth / 2;
                    camera.setTarget(new BABYLON.Vector3(map.width / 2, map.height / 4, map.depth / 2));
                };
            };
        };
    }());
    if (me) {
        shadowLight.position.x = viewingPlayer.x;
        shadowLight.position.y = viewingPlayer.y + 2;
        shadowLight.position.z = viewingPlayer.z;
    };
};

function getTeamScores() {
    for (var teamScore = [0, 0, 0], i = 0; i < playerLimit; i++) {
        var player = players[i];
        player && (teamScore[player.team] += player.score)
    }
    var leadingTeam = 0;
    return teamScore[1] > teamScore[2] ? leadingTeam = 1 : teamScore[2] > teamScore[1] && (leadingTeam = 2), {
        score: teamScore,
        leader: leadingTeam
    }
};

function resetGame() {
    for (var i = 0; i < playerLimit; i++) {
        var player = players[i];
        if (player) {
            player.removeFromPlay();
            player.score = 0;
            player.kills = 0;
            player.deaths = 0;
            player.streak = 0;
            player.bestGameStreak = 0;
        };
    };
};

function randomName() {
    //69 is literally illegal!!!11
    var num;
    for (; 69 == (num = Math.randomInt(1, 99));); //todo, enable 69 as an option (this is just to spite them)
    return 0 == Math.randomInt(0, 2) ? name1stHalf[Math.randomInt(0, name1stHalf.length)] + name2ndHalf[Math.randomInt(0, name2ndHalf.length)] + num : name2ndHalf[Math.randomInt(0, name2ndHalf.length)] + name1stHalf[Math.randomInt(0, name1stHalf.length)] + num
};

// [LS] Restrictions

LEGACYSHELLSTRINGWIDTH

LEGACYSHELLCENSOR

// [LS] Player Management
function addPlayer(playerData) {
    devlog("addPlayer FUNCTION", playerData.id == meId, playerData.id, meId, playerData.nickname);
    playerData.id == meId && (viewingPlayerId = playerData.id);
    var player = new Player(playerData, gameScene);
    player.id == meId && (viewingPlayer = me = player, me.ws = ws, updateAmmoUi()), player.playing || player.actor.removeFromPlay(), players[playerData.id] = player, rebuildPlayerList()
};

function removePlayer(playerId) {
    var player = players[playerId];
    if (playerId != meId) {
        if (player) {
            player.actor.remove();
            delete players[playerId];
            rebuildPlayerList();
        };
    } else {
        console.log("Tried to remove ME");
    };
};

function mutePlayer(playerId, uniqueId) {
    var player = players[playerId];
    player && player.uniqueId == uniqueId && (player.muted ? (player.muted = false, player.name = player.oldName) : (player.muted = true, player.oldName = player.name, player.name = randomName()), player.actor.setupNameSprite(), rebuildPlayerList()), closeAlertDialog()
};

// [LS] ######## UI ---------------------------------
//  _   _ ___
// | | | |_ _|
// | |_| || |
//  \___/|___|

// [LS] Main Menu
function showMainMenu() {
    stopAllSounds();
    engine && engine.stopRenderLoop();
    document.body.style.overflow = "visible";
    window.scrollY = 0;
    viewingPlayerId = meId = 0;
    if (inGame) {
        // document.getElementById("menuAdContainer").appendChild(document.getElementById("bannerAdContainer")), document.getElementById("inGameAd").style.display = "none;";
        me && (playerAccount.kills += kills, playerAccount.deaths += deaths, playerAccount.streak = Math.max(bestOverallStreak, playerAccount.streak), updatePlayerStatsDisplay()), closeAlertDialog(), interval.clearAll(), timeout.clearAll(), fetchTwitchStreams(), pingServers(), hideGameDom();
        // var oneSignalBell = document.getElementById("onesignal-bell-container");
        //oneSignalBell && (oneSignalBell.style.display = "inline-block"),
        //this statement is so convoluted that i have no idea how this will be affected
        if (playerAccount.isLoggedIn && !playerAccount.isUpgraded() && document.getElementById("showBuyPassDialogButton").classList.remove("hideme"), document.getElementById("upgradeIndicator").classList.remove("ingame"), ws.close(Comm.Close.mainMenu), ws = null, releaseKeys(), 0 < gameStartTime) {
            var timePlayed = Date.now() - gameStartTime;
            // if (ga("send", "timing", "game", "play time", timePlayed), me && 0 < kills) {
            //     var ratio = Math.floor(kills / Math.max(kills + deaths, 1) * 100);
            // }
        };
        gameScene.dispose();
        inGame = false;
        customizer = new Customizer(function () {
            document.getElementById("mainMenu").style.display = "block", showSmallAd()
        }), extern.customizer = customizer;
    } else document.getElementById("mainMenu").style.display = "block";
    gameType = document.getElementById("gameTypeSelect").selectedIndex - 1;
};

function showMainMenuConfirm() {
    openAlertDialog("Main Menu", "Leave game and return<br>to the main menu?", {
        label: "Yes",
        width: "4em",
        onclick: showMainMenu
    }, {
        label: "No",
        width: "4em",
        onclick: showGameMenu
    })
};

// [LS] Game Menu
function openGameMenu() {
    escPressed = false;
    document.pointerLockElement ? document.exitPointerLock() : showGameMenu();
};

function showGameMenu() {
    var helpOpen = "none" != document.getElementById("help").style.display,
        menuEl = document.getElementById("gameMenu");
    helpOpen || (document.getElementById("tipContainer").style.display = "block", document.getElementById("gameplayTip").innerHTML = getRandomGameplayTip()), hideSpinner(), hideDarkOverlay(), menuEl.style.display = "block", showCornerButtons(), removeCanvasListeners(), document.getElementById("grenadeThrowContainer").style.visibility = "hidden", document.getElementById("weaponBox").style.display = "none", document.getElementById("health").style.display = "none", document.getElementById("killTicker").style.display = "none", /*document.getElementById("inGameAd").style.display = "block",*/ reticle.hide(), timeout.set(function () {
        // loadBannerAd()
    }, 1e3)

    if (betweenRounds) showGameSummary();
};

function hideGameMenu() {
    if (me) {
        document.getElementById("gameMenu").style.display = "none";
        hideGameSummary();
        if (!(timedGame && betweenRounds)) {
            document.getElementById("deathBox").style.display = "none";
            document.getElementById("weaponBox").style.display = "block";
            document.getElementById("health").style.display = "block";
            document.getElementById("killTicker").style.display = "block";
            document.getElementById("playerList").style.display = "block";
            chatting && chatInEl.focus();
            doFirstPersonCamera();
            reticle.show();
        };
        hideMultisizeBannerAd();
        // document.getElementById("gameAdContainer").style.display = "none";
        document.getElementById("cornerButtons").style.display = "none";
        addCanvasListeners();
    };
};

// [LS] Other Misc
function getLocText(stringId) {
    return language[stringId][currentLanguage];
};

function reloadPage() {
    window.location.reload()
};

function openJoinBox() {
    document.getElementById("customGame").style.display = "none";
    document.getElementById("joinGame").style.display = "block";
};

function closeServerList() { //most useful function
    closeAlertDialog();
};

function triggerHealAnimation() {
	const healthBar = document.getElementById("healthBar");
	if (healthBar.classList.contains("heal")) {
		healthBar.classList.remove("heal");
	};
	healthBar.classList.add("heal");
	setTimeout(() => healthBar.classList.remove("heal"), 1000);
    playSoundIndependent2D("health");
};

function refreshMapPool () {
    var mapSelect = document.getElementById("mapSelect");
    var oldIndex = mapSelect.selectedIndex;
    var oldMap = currentMapPool[oldIndex - 1];
    gameType = document.getElementById("gameTypeSelect").selectedIndex - 1;

    mapSelect.textContent = '';
    var el = document.createElement("option");
    var maps = getMapsByAvailability(minMaps, "private");

    devlog("maps", gameType, maps);

    el.textContent = "[Random Map]";
    mapSelect.appendChild(el);

    if (GameTypes[gameType] && GameTypes[gameType].mapPool) {
        currentMapPool = getMapPool(maps, GameTypes[gameType].mapPool);
        for (var i in currentMapPool) {
            var map = currentMapPool[i];
            var el = document.createElement("option");
            el.textContent = map.name;
            mapSelect.appendChild(el);
        };
    } else currentMapPool = [];

    if (currentMapPool.includes(oldMap)) {
        mapSelect.selectedIndex = currentMapPool.indexOf(oldMap) + 1;
    } else {
        mapSelect.selectedIndex = 0;
    };
};

function setTeamButton() {
    var teamButton = document.getElementById("teamButton");
    teamButton.className = 1 == myTeam ? (teamButton.innerText = "Join RED Team", "ssbutton red") : (teamButton.innerText = "Join BLUE Team", "ssbutton blue")
};

function rebuildPlayerList() { //by player list we mean the literal html element. pretty sure this is purely just for displaying the player list (the one on the left side)
    var playerIdxs = [];
    for (var i = 0; i < players.length; i++) {
        players[i] && playerIdxs.push(i);
    };

    if (gameOptions.teamsEnabled) {
        var teams = getTeamScores();
        0 < teams.leader && (lastLeadingTeam = teams.leader), teams.score[lastLeadingTeam] += 1e5, playerIdxs.sort(function (a, b) {
            return players[b].score + teams.score[players[b].team] - (players[a].score + teams.score[players[a].team])
        })
    } else {
        playerIdxs.sort(function (a, b) {
            return players[b].score - players[a].score;
        });
    };

    var list = document.getElementById("playerList").children;
    for (i = 0; i < playerIdxs.length; i++) {
        var player = players[playerIdxs[i]];
        list[i].style.display = "block";

        //player name in the list
        list[i].children[0].innerText = player.name;

        let pingIcon = list[i].querySelector("img");

        if (!pingIcon) {
            pingIcon = document.createElement("img");
            pingIcon.style.height = "1em";
            pingIcon.style.marginLeft = "0.5em";
            pingIcon.style.marginRight = "0.075em";

            list[i].appendChild(pingIcon);
        };

        pingIcon.src = `/img/${player?.pingLevel?.icon || "ping1.png"}`;

        let ownerIcon = list[i].querySelector("img.ownerIcon");
        if (player.isGameOwner) {
            if (!ownerIcon) {
                ownerIcon = document.createElement("img");
                ownerIcon.classList.add("ownerIcon");
                ownerIcon.style.height = "1em";
                ownerIcon.style.position = "absolute";
                ownerIcon.style.right = "-1.2em";
                ownerIcon.style.marginLeft = "0.5em";
                list[i].appendChild(ownerIcon);
                list[i].style.position = "relative";
            };
            ownerIcon.src = "/img/gameOwner.png";
        } else if (ownerIcon) {
            ownerIcon.remove();
        };

        list[i].style.display = "flex";
        list[i].style.alignItems = "center";
        list[i].style.justifyContent = "right";
        list[i].style.opacity = player.playing ? "100%" : "40%";

        list[i].addEventListener("click", function (playerId, uniqueId, username) {
            return function () {
                openAlertDialog(players[playerId].name, "", {
                    label: "Close",
                    onclick: closeAlertDialog
                });
                var b, container = document.createElement("div");
                container.style.textAlign = "center";

                //username element
                var usernameElement = document.createElement('div');
                usernameElement.innerHTML = `@${username || "Unknown"}<br>`;
                usernameElement.style.color = '#444';
                usernameElement.style.fontWeight = 'bold';
                container.appendChild(usernameElement);

                document.getElementById("alertMessage").appendChild(container);

                if (playerId != meId) {
                    //the text that says Select an action for this player:
                    container.innerHTML += `<br>${getLocText("ui_game_playeractions_header")}<br>`;

                    //mute button
                    b = document.createElement("button");
                    b.style.display = "inline-block";
                    if (players[playerId].muted) {
                        b.className = "ssbutton blue";
                        b.innerHTML = getLocText("ui_game_playeractions_unmute");
                    } else {
                        b.className = "ssbutton orange";
                        b.innerHTML = getLocText("ui_game_playeractions_mute");
                    };
                    b.style.width = "10em";
                    b.style.height = "2.5em";
                    b.style.margin = "0.5em";
                    b.onclick = function (playerId, uniqueId) {
                        return function () {
                            mutePlayer(playerId, uniqueId)
                        };
                    }(playerId, uniqueId);
                    container.appendChild(b);

                    var hasBootPerms = perm.searchPermission("boot", me);
                    if (hasBootPerms) {
                        (b = document.createElement("button")).className = "ssbutton red";
                        b.style.display = "inline-block";
                        b.innerHTML = getLocText("ui_game_playeractions_boot");
                        b.style.width = "10em";
                        b.style.height = "2.5em";
                        b.style.margin = "0.5em";
                        b.onclick = function (playerId, uniqueId) {
                            return function () {
                                bootPlayer(playerId, uniqueId)
                            }
                        }(playerId, uniqueId);
                        container.appendChild(b);
                    };
                }
            };
        }(player.id, player.uniqueId, player.username), false);
        list[i].style.pointerEvents = "all";
        list[i].style.cursor = "pointer";
        player.upgradeProductId && player.upgradeProductId, list[i].children[1].innerText = player.score, player.id == meId ? (list[i].className = "thisPlayer", list[i].style.background = teamColors.meBackground[player.team]) : (list[i].className = "otherPlayer", list[i].style.background = teamColors.themBackground[player.team], list[i].style.color = teamColors.text[player.team]), player.upgradeProductId && 0 < player.upgradeProductId ? list[i].children[0].classList.add("upgradedPlayer") : list[i].children[0].classList.remove("upgradedPlayer")
    }
    for (; i < playerLimit;) list[i].style.display = "none", i++
};

function updateAmmoUi() {
    if (me) {
        var el = document.getElementById("weaponName");
        el.innerHTML = me.weapon.subClass.weaponName, (el = document.getElementById("ammo")).style.color = "#fff", el.innerHTML = me.weapon.ammo.rounds + "/" + Math.min(me.weapon.ammo.store, me.weapon.ammo.storeMax);
        for (var i = 1; i <= 3; i++) me.grenadeCount >= i ? document.getElementById("grenade" + i).src = "img/grenadeIcon.png?v=1" : document.getElementById("grenade" + i).src = "img/grenadeIconDark.png?v=1"
    };
};

function addKillText(byPlayer, killedPlayer) {
    var msgs = [" SCRAMBLED ", " BEAT ", " POACHED ", " WHIPPED ", " FRIED ", " CRACKED "],
        str = '<span style="color: ' + teamColors.text[byPlayer.team] + '">' + byPlayer.name + "</span>" + msgs[Math.randomInt(0, msgs.length)] + '<span style="color: ' + teamColors.text[killedPlayer.team] + '">' + killedPlayer.name + "</span>";
    4 < (killEl.innerHTML.match(/<br>/g) || []).length && (killEl.innerHTML = killEl.innerHTML.substr(killEl.innerHTML.search("<br>") + 4)), killEl.innerHTML += str + "<br>"
};

function updatePlayerStatsDisplay() {
    var ratio = Math.floor(playerAccount.kills / Math.max(playerAccount.deaths, 1) * 100) / 100;
    document.getElementById("playerStatValues").innerHTML = playerAccount.kills.toLocaleString() + "<br>" + playerAccount.deaths.toLocaleString() + "<br>" + ratio + "<br>" + playerAccount.streak.toLocaleString()
};

function updateCurrentBalance() {
    document.getElementById("currentBalanceContainer").style.display = "inline-block", document.getElementById("currentBalance").innerText = playerAccount.currentBalance
};

function setRespawnTime(sec) {
    respawnTime = Math.max(sec, respawnTime);
    var button = document.getElementById("goButton");
    button.className = "ssbutton grey";
    var label = document.getElementById("goButtonLabel");
    label.innerHTML = respawnTime;
    respawnInterval && interval.clear(respawnInterval);
    respawnInterval = interval.set(function () {
        label.innerHTML = respawnTime;
        if (respawnTime <= 0 && inGame) {
            respawnTime = -1;
            button.className = "ssbutton green";
            label.innerHTML = " PLAY!&nbsp;";
            doMapOverviewCamera();
            interval.clear(respawnInterval);
        } else {
            respawnTime--;
        };
    }, 1000);
};

function showCornerButtons() {
    document.getElementById("cornerButtons").style.display = "block"
};

function hideGameDom() {
    document.getElementById("game").style.display = "none", document.getElementById("readouts").style.display = "none", document.getElementById("homeButton").style.display = "none", document.getElementById("friendsButton").style.display = "none"
};

function closeFeedback() {
    inGame && captureKeys(), document.getElementById("feedback").style.display = "none", document.body.appendChild(document.getElementById("feedback")), closeAlertDialog()
};

function onResourcesLoaded() {
    document.getElementById("mainMenu").style.display = "block";
    document.getElementById("nickname").disabled = false;
    showCornerButtons();
    resize();
    hideSpinner();
    customizer.startRendering();
    (consent = localStorage.getItem("consent")) && (consent = JSON.parse(consent));
    isFromEU && !consent && notify(document.getElementById("consent").innerHTML) //, aiptag.consented = consent && consent.ofAge && consent.targetedAds || !isFromEU, console.log("AIP consent: " + aiptag.consented)
};

// [LS] Resizing
function resize() {
    if (canvas) {
        canvas.style.width = "100%", canvas.style.height = "100%", canvas.className = "";
    };
    if (engine) engine.resize();
    if (inGame) {
        hitIndicator && hitIndicator.resize();
        reticle && reticle.resize();
    };

    // var scale = Math.min(1, window.innerHeight / 725);
    // var scaleStr = "scale(" + scale + ")";
    // var widthStr = 300 * scale + "px";
    // var heightStr = 250 * scale + "px";
    // document.getElementById("shellshock-io_300x250").style.transform = scaleStr;
    // for (var el = document.getElementById("bannerAdContainer"), i = 0; i < el.children.length; i++) {
    //     var chEl = el.children[i];
    //     chEl.style.width = widthStr, chEl.style.height = heightStr
    // }
};
window.onresize = function () { resize() };

// [LS] Menu in, out, idk, lmao

function menuIn(domName, callback) {
    document.getElementById(domName).style.display = "block", callback && callback()
};

function menuOut(domName) {
    document.getElementById(domName).style.display = "none"
};

function menuFlexIn(domName) {
    document.getElementById(domName).style.display = "flex"
};

// [LS] Stuff Related To Nuggets

function openBuyPassDialog() {
    if (playerAccount.isLoggedIn) {
        showDarkOverlay();
        document.getElementById("buyPassDialog").classList.toggle("hideme");
        document.exitPointerLock();
        window.onkeydown = null;
        window.onkeyup = null;
    };
};

function closeBuyPassDialog() {
    document.getElementById("buyPassDialog").classList.toggle("hideme"), hideDarkOverlay()
};

function tryShowNugget() {
    return null !== showNugget && !playerAccount.isUpgraded() && (playerAccount.isLoggedIn ? (document.getElementById("bigAd").style.display = "none", openBuyPassDialog(), void (showNugget = null)) : (promoteLogin(), false))
};

function showBoughtNuggetPopup() {
    setApplixirPopup(false), document.getElementById("gotNuggetPopup").classList.toggle("hideme");
};

function setupUpgradeUI() {
    var buyPassDialog = document.getElementById("showBuyPassDialogButton"),
        upgradeIndicator = document.getElementById("upgradeIndicator");
    playerAccount.isLoggedIn ? playerAccount.isUpgraded() ? (buyPassDialog.classList.add("hideme"), upgradeIndicator.style.display = "block", customizer.setExtraColorState(true)) : (inGame ? upgradeIndicator.classList.remove("ingame") : buyPassDialog.classList.remove("hideme"), upgradeIndicator.style.display = "none", customizer.setExtraColorState(false)) : (buyPassDialog.classList.add("hideme"), upgradeIndicator.style.display = "none", customizer.setExtraColorState(false)), adBlock && document.getElementById("buyNugget").remove()
};

function promoteLogin() {
    var str = 'Login to enable this feature and others, including:<ul style="text-align: left"><li>Stat tracking - kills, deaths, etc.<li>Custom shell colors<li>Hats and accessories<li>Weapon skins</ul>';
    inGame ? openAlertDialog("Feature Unavailable to Guests", str, {
        label: "OK",
        width: "6em",
        onclick: closeAlertDialog
    }) : openAlertDialog("Feature Unavailable to Guests", str, {
        label: "Login",
        width: "6em",
        onclick: openLoginDialog
    }, {
        label: "Close",
        width: "6em",
        onclick: closeAlertDialog
    })
};

// [LS] Alert Dialog (i hate the alert dialog)

function openAlertDialog(header, text, button1, button2, bar) {
    hideSpinner(), showDarkOverlay(), document.getElementById("alert").style.display = "block", document.getElementById("alertHeader").innerHTML = header, document.getElementById("alertMessage").innerHTML = text;
    var e = document.getElementById("alertButton1");
    (button1 ? (e.style.display = "inline-block", e.style.visibility = "visible", e.innerHTML = button1.label || "OK", e.style.width = button1.width || "8em", e.style.height = button1.height || "", e.onclick = button1.onclick || closeAlertDialog) : e.style.display = "none", e = document.getElementById("alertButton2"), button2 ? (e.style.display = "inline-block", e.style.visibility = "visible", e.innerHTML = button2.label || "Cancel", e.style.width = button2.width || "8em", e.style.height = button2.height || "", e.onclick = button2.onclick || closeAlertDialog) : e.style.display = "none", bar) ? function () {
        var el = document.getElementById("alertFooter");
        el.style.display = "block", alertBarInterval = interval.set(function () {
            el.innerText += "-", 10 < el.innerText.length && (el.innerText = "-")
        }, 200)
    }() : (document.getElementById("alertFooter").style.display = "none", interval.clear(alertBarInterval));
    document.exitPointerLock(), window.onkeydown = null, window.onkeyup = null
};

function closeAlertDialog() {
    document.getElementById("alert").style.display = "none", document.getElementById("alertFooter").style.display = "none", document.getElementById("nickname").disabled = false, hideDarkOverlay(), clearInterval(alertBarInterval)
};

// [LS] Spinner (i love the spinner)

function showSpinner(header, footer) {
    document.getElementById("spinner").style.display = "block";
    document.getElementById("spinnerHeader").innerText = header;
    document.getElementById("spinnerFooter").innerText = footer;
};

function hideSpinner() {
    document.getElementById("spinner").style.display = "none";
    document.getElementById("op7logo").style.display = "none";
};

// [LS] Dark Overlay (i think it's just okay)

function showDarkOverlay() {
    closeAlertDialog(), document.getElementById("overlay").style.display = "block", hideBannerAd(), hideMultisizeBannerAd(), document.getElementById("showBuyPassDialogButton").classList.add("hideme")
};

function hideDarkOverlay() {
    document.getElementById("overlay").style.display = "none", showBannerAd(), inGame || !playerAccount.isLoggedIn || playerAccount.isUpgraded() || document.getElementById("showBuyPassDialogButton").classList.remove("hideme")
};

// [LS] Invite Codes (i love invite codes)

function inviteFriends() {
    function padWithZeros(i, amount = 3) {
        return String(i).padStart(amount, '0');
    };

    gameCode = (padWithZeros(selectedServer.toString(36), 1) + padWithZeros(gameId.toString(36), 3) + padWithZeros(gameKey.toString(36), 2));

    gameCode = gameCode.toUpperCase();

    var url = parsedUrl.root + "#" + gameCode;
    openAlertDialog("Don't Go Alone!", "<p>Share this link with your friends so they can join you!</p><h3>" + (document.getElementById("friendCode").innerText = url) + "</h3><p></p>", {
        label: "Copy to clipboard",
        width: "12em",
        onclick: copyFriendCode
    }, {
        label: "Close",
        onclick: closeAlertDialog
    })
};

function copyFriendCode() {
    document.getElementById("friendCode").select();
    try {
        document.execCommand("copy")
    } catch (err) {
        console.log("Unable to copy to clipboard")
    }
    closeAlertDialog()
};

// [LS] Settings menu (i hate the settings menu)

function openSettingsMenu() {
    inGame && 1 == settings.enableChat && initChatIn(), hideBannerAd(), hideMultisizeBannerAd(), menuIn("settingsMenu")
};

function closeSettingsMenu() {
    menuOut("settingsMenu")
};

// [LS] Notifications (i love notifications)

function notify(msg, timeout) {
    var e = document.getElementById("notification");
    msg = msg.replaceAll("<", "(");
    e.style.opacity = 0, e.style.top = "-3.5em", e.style.display = "flex", document.getElementById("notificationMessage").innerHTML = msg;
    var anim = 0,
        animIn = setInterval(function () {
            anim++, e.style.opacity = anim / 8, e.style.top = anim / 2 - 3.5 + "em", 8 == anim && (clearInterval(animIn), timeout && setTimeout(function () {
                dismissNotification()
            }, timeout))
        }, 32)
};

function dismissNotification(callback) {
    var anim = 8,
        e = document.getElementById("notification"),
        animIn = setInterval(function () {
            e.style.opacity = anim / 8, e.style.top = anim / 2 - 3.5 + "em", 0 == --anim && (clearInterval(animIn), e.style.display = "none", callback && callback())
        }, 32)
};

// [LS] Chat UI (i hate the chat ui)
function initChatIn() {
    canvas.focus();
    chatInEl.style.display = "block";
    chatInEl.value = "Press ENTER to chat";
    chatInEl.style.background = "transparent";
    chatInEl.blur();
    chatting = false;
    previousChatsIdx = -1;
};

function addChat(str, fromPlayer, chatType) {
    var code = str;

    devlog("addChat", str, fromPlayer, chatType);

    if (fromPlayer) {
        code = '<span style="color: ' + teamColors.text[fromPlayer.team] + '">' + fromPlayer.name + ": </span>" + code;
    };
    if ((maxChatCount - 1) < (chatOutEl.innerHTML.match(/<br>/g) || []).length) {
        chatOutEl.innerHTML = chatOutEl.innerHTML.substr(chatOutEl.innerHTML.search("<br>") + 4);
    };

    var additionalStyles = "; ";
    if (chatType === Comm.Chat.blocked) additionalStyles += "; color: red";
    else if (chatType === Comm.Chat.cmd) additionalStyles += "; font-style: italic; color: dimgray";
    else if (chatType === Comm.Chat.whisper) additionalStyles += "; color: yellow";
    else if (str.startsWith(">")) additionalStyles += "; color: limegreen";

    code = `<div class="shadedPane" style="margin-top: 0.2em${additionalStyles}">` + code + "</div><br>";
    chatOutEl.innerHTML += code
};

function setChatInput(str) {
    chatInEl.value = str;
    chatInEl.focus();
};

function beginChat() {
    releaseKeys();
    chatInEl.style.background = "rgba(0, 0, 0, 0.5)";
    if (!chatting) chatInEl.value = "";
    chatInEl.focus();
    chatting = !(lastKey = null);
};

const autocomplete = {
    commands: [],
    idx: 0,
    suggestions: [],
    suggestionsAliases: {},
    addOnEnd: {},
    visible: false,
    selected: false,
    dialog: null,
    showingCmdNames: false,
    show: function (text) {
        autocomplete.clear();

        autocomplete.fulltext = text;
        var isCmd = text.startsWith("/");

        autocomplete.withoutLast = autocomplete.fulltext.substring(0, Math.max(autocomplete.fulltext.lastIndexOf(" "), isCmd ? 1 : 0));
        if (isCmd) {
            autocomplete.withoutLast = autocomplete.withoutLast || autocomplete.fulltext;
            text = text.slice(1);
        };

        autocomplete.parts = text.split(" ");
        autocomplete.currentPart = autocomplete.parts[autocomplete.parts.length - 1];

        var availableCmds = perm.getAvailableCmds(me);
        autocomplete.commands = null;
        autocomplete.suggestionsAliases = {};
        autocomplete.addOnEnd = {};
        autocomplete.showingCmdNames = false;

        if (autocomplete.currentPart.startsWith("@")) {
            autocomplete.commands = [
                "@m (me)",
                "@a (all)",
            ];
            if (gameOptions.teamsEnabled) {
                autocomplete.commands = [
                    ...autocomplete.commands,
                    "@t (your team)",
                    "@o (opposing team)",
                ];
            };
            autocomplete.suggestionsAliases = {
                "@m (me)": "@m",
                "@a (all)": "@a",
                "@t (your team)": "@t",
                "@o (opposing team)": "@o",
            };
            players.forEach(player => {
                if (player) {
                    var suggestion = `@${player.username} (${player.name})`;
                    autocomplete.commands.push(suggestion);
                    autocomplete.suggestionsAliases[suggestion] = `@${player.username}`;
                };
            });
        } else if (isCmd) {
            if (autocomplete.parts.length === 1) {
                autocomplete.commands = availableCmds.cats;
            } else if (autocomplete.parts.length === 2) {
                autocomplete.showingCmdNames = true;
                var category = availableCmds.structure[autocomplete.parts[0]];
                autocomplete.commands = category || [];
                category.forEach(cmdName => {
                    var cmd = perm.searchCmdByCategory(autocomplete.parts[0], cmdName);
                    autocomplete.addOnEnd[cmdName] = `${cmd.autocomplete}`;
                });
            };
        };

        if (isCmd && autocomplete.parts.length >= 3) {
            var cmd = perm.searchCmdByCategory(autocomplete.parts[0], autocomplete.parts[1]);
            if (cmd) {
                autocomplete.showInfo(cmd);
            };
        };

        if (autocomplete.commands) {
            autocomplete.suggestions = autocomplete.commands.filter(cmd => cmd.includes(autocomplete.currentPart));
        } else {
            autocomplete.suggestions = [];
        };

        if (autocomplete.suggestions.length === 0) return;

        autocomplete.dialog.classList.remove('hidden');
        autocomplete.dialog.innerHTML = '';

        autocomplete.suggestions.forEach((cmd, index) => {
            const cmdItem = document.createElement('div');
            cmdItem.textContent = cmd;

            cmdItem.onclick = () => {
                chatInEl.value = cmd;
                autocomplete.clear();
            };

            cmdItem.onmouseover = () => {
                autocomplete.set(index);
            };

            autocomplete.dialog.appendChild(cmdItem);
        });

        const rect = chatInEl.getBoundingClientRect();

        autocomplete.dialog.style.marginLeft = (getStringWidth(autocomplete.withoutLast) * 2) + "px";
        autocomplete.dialog.style.bottom = `${(window.innerHeight - rect.top + rect.height) * 0.6395}px`;

        autocomplete.visible = true;
        autocomplete.scroll(0);
    },
    showInfo(cmd) {
        autocomplete.commandDialog.innerHTML = `
            <div class="command-info">
                <h1>${cmd.identifier}</h1>
                ${(cmd.warningText && cmd.warningText != "") ? `<p class="command-warning">${cmd.warningText}</p>` : ''}
                <p class="command-description">${cmd.description}</p>
                <p>Usage: ${cmd.usage}</p>
                <p class="command-example">/${cmd.category} ${cmd.name} ${cmd.example}</p>
            </div>
        `;

        autocomplete.commandDialog.style.display = 'block';
    },
    clear: function () {
        autocomplete.dialog = document.getElementById('autocomplete-dialog');
        autocomplete.commandDialog = document.getElementById('command-info-dialog');

        if (autocomplete.dialog) {
            autocomplete.dialog.classList.add('hidden');
            autocomplete.visible = false;
            autocomplete.commandDialog.style.display = '';
        };
    },
    highlight: function () {
        Array.from(autocomplete.dialog.children).forEach((item, i) => {
            if (i === autocomplete.idx) {
                item.classList.add('highlight');
                if (autocomplete.showingCmdNames) {
                    var cmd = perm.searchCmdByCategory(autocomplete.parts[0], item.textContent);
                    if (cmd) {
                        autocomplete.showInfo(cmd);
                    };
                };
            } else {
                item.classList.remove('highlight');
            };
        });
    },
    scroll: function (amount) {
        autocomplete.set((autocomplete.idx + amount + autocomplete.suggestions.length) % autocomplete.suggestions.length);
    },
    set: function (idx) {
        autocomplete.idx = (idx) % autocomplete.suggestions.length;
        autocomplete.highlight();
        autocomplete.selected = autocomplete.suggestions[autocomplete.idx];
    },
    enter: function () {
        var suggestion = autocomplete.suggestionsAliases[autocomplete.selected] || autocomplete.selected;
        var addOnEnd = autocomplete.addOnEnd[autocomplete.selected] || "";
        chatInEl.value = `${autocomplete.withoutLast}${autocomplete.withoutLast.length <= 1 ? "" : " "}${suggestion} ${addOnEnd}`;
        autocomplete.idx = 0;
        autocomplete.show(chatInEl.value);
    },
};

function onChatKeyDown(e) {
    var key = (e = e || window.event).key;
    chatInEl.value = fixStringWidth(chatInEl.value, maxChatWidth);
    var text = chatInEl.value.trim();

    if (!autocomplete.visible) {
        switch (key) {
            case "ArrowUp":
                if (previousChatsIdx < (previousChats.length - 1)) {
                    if (previousChatsIdx === -1) currentChat = text;
                    previousChatsIdx++;
                    setChatInput(previousChats[previousChatsIdx]);
                };
                break;
            case "ArrowDown":
                if (previousChatsIdx >= 0) {
                    previousChatsIdx--;
                    if (previousChatsIdx === -1) setChatInput(currentChat);
                    else setChatInput(previousChats[previousChatsIdx]);
                };
                break;
            case "Enter":
                if ("" != text) {
                    text = text.replaceAll("<", "(");
                    var output = new Comm.Out(2 + 2 * text.length);
                    output.packInt8(Comm.Code.chat);
                    output.packString(text);
                    previousChats.unshift(text);
                    previousChatsIdx = -1;
                    me.chatLineCap--;
                    if (!(text.startsWith("/"))) {
                        addChat(text, me);
                        wsSend(output, "chat");
                    } else {
                        var shouldSend = perm.inputCmd(me, text);
                        // devlog("should i send this cmd?", shouldSend);
                        if (shouldSend) wsSend(output, "chat");
                    };
                };
            case "Tab":
                initChatIn();
                e.preventDefault();
                e.stopPropagation();
                captureKeys();
                autocomplete.clear();
                break;
        };
    };
};

function onChatKeyUp(e) {
    var key = (e = e || window.event).key;
    var text = chatInEl.value.trim();

    autocomplete.show(chatInEl.value);

    if (autocomplete.visible) {
        switch (key) {
            case "ArrowDown":
                autocomplete.scroll(1);
                e.preventDefault();
                break;
            case "ArrowUp":
                autocomplete.scroll(-1);
                e.preventDefault();
                break;
            case "Tab":
            case "Enter":
                autocomplete.enter();
                break;
            case "Escape":
                autocomplete.clear();
                break;
        };
    };
};

function onChatClick(e) {
    devlog(e);
    beginChat();
};

// [LS] Summary (i love the summary)
function showContinueDialog() {
    hideGameMenu();
    document.getElementById("gameClock").style.display = "none";
    openAlertDialog("OVER-EASY", "Continue to the next round?", {
        label: "<h3> YES!&nbsp;</h3>",
        width: "8em",
        height: "2.5em",
        onclick: continueToSummary
    }, {
        label: "<h3>No</h3>",
        width: "4em",
        height: "2.5em",
        onclick: showMainMenuConfirm
    });
};
function continueToSummary() {
    closeAlertDialog();
    openGameMenu();
    showGameSummary();
    resetGame();
};
function showGameSummary() {
    document.getElementById("gameSummary").style.visibility = "visible";
    document.getElementById("playerList").style.display = "none";

    if (gameOptions.teamsEnabled) {
        document.getElementById("teamFinal").style.display = "flex";
        document.getElementById("ffaFinal").style.display = "none";
    } else {
        document.getElementById("teamFinal").style.display = "none";
        document.getElementById("ffaFinal").style.display = "flex";
    };

    document.getElementById("orangeBoxContent").style.display = "none";
};
function hideGameSummary() {
    document.getElementById("gameSummary").style.visibility = "hidden";
    document.getElementById("playerList").style.display = "block";

    document.getElementById("ffaFinal").style.display = "none";
    document.getElementById("teamFinal").style.display = "none";

    document.getElementById("orangeBoxContent").style.display = "block";
};
function prepareGameSummary() {
    for (var playerIdxs = [ [], [], [] ], i = 0; i < playerLimit; i++) {
        players[i] && playerIdxs[players[i].team].push(i);
    };

    for (var team = 0; team < 3; team++) {
        teamSummaryEls[team].style.display = "none", playerIdxs[team].sort(function (a, b) {
            var diff = players[b].score - players[a].score;
            return 0 == diff && 0 == (diff = players[a].kills - players[b].kills) && (diff = players[a].deaths - players[b].deaths), diff
        });
        var rowsEl = teamSummaryEls[team];
        for (i = 0; i < playerIdxs[team].length; i++) {
            var player = players[playerIdxs[team][i]];
            if (player) {
                var row = rowsEl.children[i];
                row.style.display = "flex";
                if (player.id == meId) {
                    row.style.color = "#ff0"
                } else {
                    row.style.color = teamColors.text[team]
                };
                row.children[0].innerText = i + 1;
                row.children[1].innerText = player.name;
                row.children[2].innerText = player.score;
                row.children[3].innerText = player.kills;
                row.children[4].innerText = player.deaths;
                row.children[5].innerText = player.bestGameStreak;
            };
        };
        for (; i < rowsEl.children.length;) rowsEl.children[i].style.display = "none", i++
    };
    var teamScores = getTeamScores();
    if (gameOptions.teamsEnabled) {
        var losingTeam = 1 == (teamScores.leader || lastLeadingTeam) ? 2 : 1;
        teamSummaryEls[losingTeam].parentNode.appendChild(teamSummaryEls[losingTeam]);
        for (team = 1; team < 3; team++) teamSummaryEls[team].style.display = "flex", document.getElementById("teamScore" + team).innerText = teamScores.score[team];
        document.getElementById("teamFinal").style.display = "flex";
        document.getElementById("ffaFinal").style.display = "none";
    } else {
        teamSummaryEls[0].style.display = "flex";
        document.getElementById("teamScore0").innerText = teamScores.score[0];
        document.getElementById("teamFinal").style.display = "none";
        document.getElementById("ffaFinal").style.display = "flex";
    };
};

// [LS] ######## Rendering ---------------------------------
//  ___ ___ _  _ ___  ___ ___ ___ _  _  ___
// | _ \ __| \| |   \| __| _ \_ _| \| |/ __|
// |   / _|| .` | |) | _||   /| || .` | (_ |
// |_|_\___|_|\_|___/|___|_|_\___|_|\_|\___|

function doMapOverviewCamera() {
    devlog("doMapOverviewCamera");
    camera.parent = null;
    camera.position = new BABYLON.Vector3(0, map.height + 1, 0);
    camera.lockedTarget = null;
    camera.setTarget(new BABYLON.Vector3(map.width / 2, map.height / 4, map.depth / 2));
    mapOverview = true;
};

function doFirstPersonCamera(player) {
    devlog("doFirstPersonCamera", player);
    camera.position = BABYLON.Vector3.Zero();
    camera.rotation = BABYLON.Vector3.Zero();
    camera.rotationQuaternion = BABYLON.Quaternion.Zero();
    camera.parent = player ? player.actor.eye : me.actor.eye, camera.lockedTarget = null, mapOverview = false;
};

function isMeshVisible(mesh, offset) {
    if (freezeFrame) return true;

    var scale = mesh.scaling.x; //could use other values but atm egg scaling is only in effect in all axes

    if (scale > 1) return true; //current function doesnt account for this stuff

    var oy = offset || mesh.getBoundingInfo().boundingBox.center.z;
    var dx = mesh.position.x - camera.globalPosition.x;
    var dy = mesh.position.y + oy - camera.globalPosition.y;
    var dz = mesh.position.z - camera.globalPosition.z;
    var distance = Math.length3(dx, dy, dz);
    var dv = Math.normalize3({
        x: dx,
        y: dy,
        z: dz
    }, .9);
    var x = camera.globalPosition.x;
    var y = camera.globalPosition.y;
    var z = camera.globalPosition.z;
    var collisions = 0;

    for (i = 0; i < distance - .9 && (x += dv.x, y += dv.y, z += dv.z, !(x < 0 || x >= map.width || z < 0 || z >= map.depth || y < 0 || y >= map.height)); i += .9) {
        var cell = map.data[Math.floor(x)][Math.floor(y)][Math.floor(z)];
        if (cell.idx) {
            var m = mapMeshes[cell.idx];
            if ("full" == m.colliderType && !m.softness && 2 == ++collisions) return false
        };
    };
    return true;
};

function enableAutoDetail() {
    var opt = new BABYLON.SceneOptimizerOptions(40, 4e3);
    var shadowOpt = new BABYLON.SceneOptimization(0);
    shadowOpt.apply = disableShadows, opt.optimizations.push(shadowOpt);
    var scalingOpt = new BABYLON.SceneOptimization(1);
    scalingOpt.apply = lowerResolution, opt.optimizations.push(scalingOpt), inGame && (optimizer = BABYLON.SceneOptimizer.OptimizeAsync(gameScene, opt))
};

function disableShadows() {
    return gameScene.shadowsEnabled = false, mapMesh && inGame && (mapMesh.material = gameScene.getMaterialByName("mapNoShadow")), true
};

function enableShadows() {
    gameScene.shadowsEnabled = true;
    mapMesh && inGame && (mapMesh.material = gameScene.getMaterialByName("map"))
};

function lowerResolution() {
    return engine.setHardwareScalingLevel(2), adaptToNewResolution(), true
};

function increaseResolution() {
    engine.setHardwareScalingLevel(1);
    adaptToNewResolution();
};

function adaptToNewResolution() {
    reticle && reticle.resize(), hitIndicator && hitIndicator.resize(), scope && scope.crosshairs.isEnabled() && scope.show()
};

function onFullscreenChange() {
    engine.resize();
};

document.onfullscreenchange = onFullscreenChange;
document.onmsfullscreenchange = onFullscreenChange;
document.onmozfullscreenchange = onFullscreenChange;
document.onwebkitfullscreenchange = onFullscreenChange;

// [LS] ######## Requests ---------------------------------
//  ___ ___ ___  _   _ ___ ___ _____ ___
// | _ \ __/ _ \| | | | __/ __|_   _/ __|
// |   / _| (_) | |_| | _|\__ \ | | \__ \
// |_|_\___\__\_\\___/|___|___/ |_| |___/

function wsSend (output, CommCode, passedWs) {
    passedWs = passedWs || ws;
    if (passedWs && passedWs.send) {
        if (Comm.Code[CommCode] !== Comm.Code.sync && Comm.Code[CommCode] !== Comm.Code.syncData && Comm.Code[CommCode] !== Comm.Code.ping) devlog("WS SEND:", `${CommCode}:`, Comm.Code[CommCode], output);
        passedWs.send(output.buffer);
    };
};

function callApi(apiRequest, successCallback, errorCallback, closeCallback) {
    console.log(apiRequest.cmd + " called");
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify(apiRequest)), console.log("servicesWs opened, and " + apiRequest.cmd + " request sent")
    }, servicesWs.onmessage = function (e) {
        var response = null;
        try {
            response = JSON.parse(e.data)
        } catch (e) {
            return console.log("Invalid data returned from services API"), void errorCallback()
        }
        response.error ? (console.log(apiRequest.cmd + " error: " + JSON.stringify(response.error)), errorCallback(response)) : successCallback(response), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log(apiRequest.cmd + " servicesWs closed: " + e.code + " " + e.reason), closeCallback && closeCallback()
    }, servicesWs.onerror = function (e) {
        errorCallback()
    }
};

function getRequest(url, callback) {
    var req = new XMLHttpRequest;
    return !!req && ("function" != typeof callback && (callback = function () { }), req.onreadystatechange = function () {
        if (4 == req.readyState) return 200 === req.status ? callback(null, req.responseText) : callback(req.status, null)
    }, req.open("GET", url, true), req.send(null), req)
};

function sendFeedback() {
    for (var emailEl = document.getElementById("feedbackEmail"), descriptionEl = document.getElementById("feedbackComments"), glInfo = engine.getGlInfo(), caps = engine.getCaps(), pickedWeaponIds = [], c = 0; c < CharClass.length; c++) pickedWeaponIds.push([playerAccount.pickedWeapons[c][0].id, playerAccount.pickedWeapons[c][1].id]);
    var debugJSON = "";
    debugObject.uuid = uuid;
    try {
        debugJSON = JSON.stringify({
            debugObject: debugObject,
            debugArray: debugArray
        })
    } catch (e) {
        console.log(e)
    } ! function (command, data, success, fail) {
        try {
            var serviceWs = new WebSocket(servicesServer)
        } catch (e) {
            console.log(e), fail && fail(e)
        }
        serviceWs.onopen = function (e) {
            data.cmd = command, serviceWs.send(JSON.stringify(data)), console.log("services opened, and " + command + " request sent")
        }, serviceWs.onmessage = function (e) {
            var response = JSON.parse(e.data);
            response.error ? (console.log(command + " error: " + JSON.stringify(response.error)), fail && fail(response.error)) : (console.log(command + " success"), success && success(response)), serviceWs.close()
        }, serviceWs.onclose = function (e) {
            console.log(command + " service closed: " + e.code + " " + e.reason), success && success(e)
        }, serviceWs.onerror = function (e) {
            console.log(command + " error: " + JSON.stringify(e, ["message", "arguments", "type", "name"])), fail && fail(e)
        }
    }("feedback", {
        feedbackType: document.getElementById("feedbackTypeSelect").selectedIndex,
        gameVersion: version,
        userAgent: window.navigator.userAgent,
        nickname: nickname,
        comments: descriptionEl.value,
        email: emailEl.value,
        // firebaseId: playerAccount.firebaseId || null,
        fromEU: isFromEU,
        gameServer: servers[selectedServer].name || null,
        session: playerAccount.session || null,
        ping: 0 < pingSamples ? Math.floor(pingTotal / pingSamples) : null,
        highestPing: highestPing || null,
        fps: 0 < fpsSamples ? Math.ceil(fpsTotal / fpsSamples) : null,
        gameType: gameType || null,
        privateGame: privateGame || null,
        localKills: kills || 0,
        localDeaths: deaths || 0,
        localStreak: bestOverallStreak || 0,
        url: parsedUrl.root,
        referrer: document.referrer,
        gameCode: gameCode || null,
        screenSize: screen.width + "x" + screen.height,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        innerSize: window.innerWidth + "x" + window.innerHeight,
        glVendor: glInfo.vendor,
        renderer: glInfo.renderer,
        glVersion: glInfo.version,
        maxTextureSize: caps.maxTextureSize,
        fov: camera ? camera.fov : null, //why tf it sends this? hack detection?
        controls: localStorage.getItem("controlConfig"),
        ofAge: consent ? consent.ofAge : null,
        targetedAds: consent ? consent.targetedAds : null,
        volume: settings.volume,
        mouseSensitivity: settings.mouseSensitivity,
        mouseInvert: settings.mouseInvert,
        holdToAim: settings.holdToAim,
        enableChat: settings.enableChat,
        autoDetail: settings.autoDetail,
        shadowsEnabled: settings.shadowsEnabled,
        highRes: settings.highRes,
        selectedClass: playerAccount.classIdx,
        selectedColor: playerAccount.colorIdx,
        hat: !playerAccount.hatItem ? null : playerAccount.hatItem.id,
        stamp: !playerAccount.stampItem ? null : playerAccount.stampItem.id,
        weapons: "[[0,0],[0,0],[0,0]]",
        timesPlayed: null,
        // xsollaToken: globalXsollaToken, //money!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        current_balance: playerAccount.currentBalance,
        // log: console.logArray(), // note from ls devs: this requires bwd's modified console function which is bad!
        debug: debugJSON
    }, function (res) {
        console.log(res), setTimeout(function () {
            notify("Your feedback has been received.<br>Thank you!", 3e3)
            // notify("we also just stole all ur fucking information because we're whores!")
        }, 1e3);
    }, function (err) {
        console.log(err)
    });
    closeFeedback();
    emailEl.value = "";
    descriptionEl.value = "";
};

function requestRespawn() {
    unfocused = false;
    canvas.requestPointerLock();
    var output = new Comm.Out(1);
    output.packInt8(Comm.Code.requestRespawn);
    wsSend(output, "requestRespawn");
    console.log("respawn() requests respawn from server");
    document.getElementById("help").style.display = "none";
};

function checkBalance() {
    console.log("checkBalance called");
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify({
            cmd: "checkBalance",
            session: playerAccount.session
        })), console.log("servicesWs opened, and checkBalance request sent")
    };
    servicesWs.onmessage = function (e) {
        checkBalanceData = JSON.parse(e.data), checkBalanceData.error ? console.log("checkBalance Error: " + JSON.stringify(checkBalanceData.error)) : playerAccount.currentBalance != checkBalanceData.current_balance && (playerAccount.currentBalance = checkBalanceData.current_balance, updateCurrentBalance()), servicesWs.close()
    };
    servicesWs.onclose = function (e) {
        console.log("servicesWs closed: " + e.code + " " + e.reason)
    };
    servicesWs.onerror = function (e) {
        statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
    };
};

function checkUpgrade() {
    try {
        var servicesWs = new WebSocket(servicesServer)
    } catch (e) {
        console.log(e)
    }
    var beforeStatus = playerAccount.isUpgraded();
    servicesWs.onopen = function (e) {
        servicesWs.send(JSON.stringify({
            cmd: "getUpgrade",
            session: playerAccount.session
        })), console.log("servicesWs opened, and getUpgrade request sent")
    }, servicesWs.onmessage = function (e) {
        getUpgradeData = JSON.parse(e.data);
        devlog(getUpgradeData);
        getUpgradeData.error ? console.log("getUpgrade Error: " + JSON.stringify(getUpgradeData.error)) : (playerAccount.setUpgrade(getUpgradeData), setupUpgradeUI(), playerAccount.isUpgraded() && false === beforeStatus && loadBannerAd()), servicesWs.close()
    }, servicesWs.onclose = function (e) {
        console.log("servicesWs closed: " + e.code + " " + e.reason)
    }, servicesWs.onerror = function (e) {
        statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
    }
};

function serverSync() {
    if (me) {
        var output = new Comm.Out();
        output.packInt8U(Comm.Code.sync);
        output.packInt8U(me.stateIdx);
        output.packInt8U(me.shotsQueued);
        var startIdx = Math.mod(me.stateIdx - FramesBetweenSyncs, stateBufferSize)
        for (startIdx, i = 0; i < FramesBetweenSyncs; i++) {
            var idx = Math.mod(startIdx + i, stateBufferSize);
            output.packInt8U(me.stateBuffer[idx].controlKeys);
            output.packRadU(me.stateBuffer[idx].yaw);
            output.packRad(me.stateBuffer[idx].pitch);
        };
        wsSend(output, "sync");
        me.shotsQueued = 0
    }
};

function switchTeam() {
    closeAlertDialog();
    var output = new Comm.Out(1);
    output.packInt8U(Comm.Code.switchTeam);
    wsSend(output, "switchTeam");
};

function bootPlayer(playerId, username) {
    var hasBootPerms = perm.searchPermission("boot", me);
    if (hasBootPerms && players[playerId] && players[playerId].username == username) {
        var output = new Comm.Out(2);
        output.packInt8U(Comm.Code.bootPlayer);
        output.packInt8U(playerId);
        // output.packInt16(players[playerId].username);
        wsSend(output, "bootPlayer");
    }
    closeAlertDialog()
};

function pingServers(autoSelect, callback) {
    var serverSelected = false,
        serversPinged = 0;
    var protocol = "ws://";
    "https:" === location.protocol && (protocol = "wss://");
    console.log("Pinging servers", protocol);
    for (var i = 0; i < servers.length; i++) servers[i].ping = 0,
        function (serverIdx) {
            var startTime, server = servers[serverIdx],
                pinger = new WebSocket(protocol + server.address);
            console.log("Connecting to " + server.name), pinger.binaryType = "arraybuffer";
            var timeout = setTimeout(function () {
                console.log(server.name + " timed out"), server.ping = 1e3, pinged(), pinger.close()
            }, 1e3);
            pinger.onopen = function (e) {
                console.log("Pinging " + server.name);
                var output = new Comm.Out(1);
                output.packInt8(Comm.Code.ping);
                wsSend(output, "ping", pinger);
                startTime = Date.now();
            }, pinger.onmessage = function (e) {
                clearTimeout(timeout);
                var pingTime = Date.now() - startTime;
                server.ping = pingTime, pinger.close(), autoSelect && !serverSelected && (serverSelected = true, selectServer(serverIdx)), pinged(), console.log(server.name + ": " + pingTime)
            }, pinger.onerror = function (e) {
                clearTimeout(timeout), server.ping = 1e3, pinged()
            }
        }(i);

    function pinged() {
        ++serversPinged == servers.length && callback && callback()
    }
};

// function buyChickenNuggetProduct() {
//     isGettingNugget = false;
//     callApi({
//         cmd: "buyProduct",
//         token: servicesToken,
//         sku: "chicken_nugget_pass"
//     }, showBoughtNuggetPopup, function (response) {
//         openAlertDialog("Uh Oh!", "Something broke. Try reloading the game.", null, {
//             label: "OK",
//             width: "4em",
//             onclick: closeAlertDialog
//         })
//     }), servicesToken = null
// };

function fetchTwitchStreams() {
    var streamsEl = document.getElementById("twitchStreams");
    streamsEl.innerHTML = "", console.log(url);
    var url = parsedUrl.root;
    getRequest(url + "twitchStreams.json?" + Date.now(), function (err, res) {
        if (!err) {
            var twitchStreams = JSON.parse(res),
                keys = Object.keys(twitchStreams);
            keys.sort(function (a, b) {
                return twitchStreams[b].viewers - twitchStreams[a].viewers
            }), keys.forEach(function (k) {
                var stream = twitchStreams[k],
                    container = document.createElement("div");
                container.className = "twitchRow clickable", container.onclick = function (name) {
                    return function () {
                        window.open("https://twitch.tv/" + name, "_blank")
                    }
                }(stream.name);
                var avatar = document.createElement("img");
                avatar.className = "twitchAvatar", avatar.src = "img/twitchAvatars/" + stream.avatar;
                var name = document.createElement("div");
                name.className = "twitchName", name.innerText = stream.name;
                var viewers = document.createElement("div");
                viewers.className = "twitchViewers", viewers.innerText = stream.viewers + " viewer", 1 < stream.viewers && (viewers.innerText += "s"), container.appendChild(avatar), container.appendChild(name), container.appendChild(viewers), streamsEl.appendChild(container)
            })
        }
    })
};

// [LS] ######## Particles ---------------------------------
//  ___  _   ___ _____ ___ ___ _    ___ ___
// | _ \/_\ | _ \_   _|_ _/ __| |  | __/ __|
// |  _/ _ \|   / | |  | | (__| |__| _|\__ \
// |_|/_/ \_\_|_\ |_| |___\___|____|___|___/

function createParticleManager(filename, number, firstFrame, lastFrame, scene) {
    for (var manager = new BABYLON.SpriteManager("", "img/" + filename + "?" + version, number, 128, scene), i = 0; i < number; i++) {
        new BABYLON.Sprite("", manager).isVisible = false
    }
    return manager.nextIdx = 0, manager.getSprite = function () {
        var s = this.sprites[this.nextIdx];
        return s.cellIndex = Math.randomInt(firstFrame, lastFrame), s.isVisible = true, s.easing = Ease.linear, s.startSize = -1, s.endSize = -1, s.gravity = 0, s.dx = 0, s.dy = 0, s.dz = 0, s.float = 0, s.anim = 0, s.slow = 0, s.angle = 0, s.rotate = 0, s.stopped = false, s.animColors = null, s.collide = false, s.color.copyFrom(color4White), this.nextIdx = ++this.nextIdx % this.sprites.length, s
    }, manager
};

function addExplosionSprite(manager, animLength, x, y, z, dx, dy, dz, size, gravity) {
    var s = manager.getSprite();
    return s.animLength = animLength, s.easing = Ease.inOutQuad, s.position.x = x, s.position.y = y, s.position.z = z, s.size = size, s.dx = dx, s.dy = dy, s.dz = dz, s.slow = .7, s.angle = Math.random() * Math.PI2, s.rotate = .04 * Math.random() - .02, s.animColors = manager == explosionFireManager ? fireColors : smokeColors, s
};

function addExplosion(x, y, z, damage, radius) {
    for (var i = 0; i < Math.floor(damage / 4); i++) {
        var animLength = 80 * Math.random() + 80,
            size = 1 * Math.random() + .5,
            se = .5 * (.9 - size),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - 1) * se + .1,
            dz = (2 * Math.random() - 1) * se,
            s = addExplosionSprite(explosionSmokeManager, animLength, x, y, z, dx, dy, dz, size);
        s.float = .015 * Math.random() + .001, s.collide = true, (s = addExplosionSprite(explosionFireManager, .075 * animLength, x, y, z, 1.5 * dx, 1.5 * dy, 1.5 * dz, size)).collide = true
    }
    if (me) {
        var d = Math.length3(me.x - x, me.y - y, me.z - z);
        if (d < (radius *= 1.5)) {
            var shakeFactor = Math.max(0, (radius - d) / radius);
            shake = Math.min(7, shake + 6 * shakeFactor)
        };
    };
};

function lerp(colors, p, ref) {
    for (var i = colors.length - 2; 0 <= i; i--)
        if (p >= colors[i].pos) return void BABYLON.Color4.LerpToRef(colors[i].color, colors[i + 1].color, (p - colors[i].pos) * (1 / (colors[i + 1].pos - colors[i].pos)), ref)
};

function shellFragBurst(player, count, theSize, theAnimLength) {
    for (var i = 0; i < count; i++) {
        var animLength = Math.random() * theAnimLength + .5 * theAnimLength * Math.max(1, player.scale);
        var size = (i / (.5 * count) * theSize + .5 * theSize) * player.scale;
        var se = .08 / (size + 1);
        var dx = (2 * Math.random() - 1) * se * player.scale;
        var dy = (2 * Math.random() - .5) * se * player.scale;
        var dz = (2 * Math.random() - 1) * se * player.scale;
        var s = shellFragManager.getSprite();

        s.animLength = animLength;
        s.easing = Ease.inQuad;
        s.position.x = player.actor.mesh.position.x;
        s.position.y = player.actor.mesh.position.y + .3;
        s.position.z = player.actor.mesh.position.z;
        s.startSize = size;
        s.endSize = 0;
        s.gravity = .003;
        s.dx = dx;
        s.dy = dy;
        s.dz = dz;
        s.angle = Math.random() * Math.PI2;
        s.rotate = .2 * Math.random() - .1;
        s.collide = true;
        s.color.r = player.actor.bodyMesh.colorMult.r;
        s.color.g = player.actor.bodyMesh.colorMult.g;
        s.color.b = player.actor.bodyMesh.colorMult.b;
    };
};

function yolkBurst(player) {
    for (var i = 0; i < 10; i++) {
        var animLength = 80 * Math.random() + 80,
            size = (i / 5 * .2 + .2) * player.scale,
            se = .05 / (size + 1),
            dx = (2 * Math.random() - 1) * se,
            dy = (2 * Math.random() - .25) * se * 1.5,
            dz = (2 * Math.random() - 1) * se,
            s = yolkManager.getSprite();
        s.animLength = animLength;
        s.easing = Ease.inQuad;
        s.position.x = player.actor.mesh.position.x;
        s.position.y = player.actor.mesh.position.y + (.3 * player.scale);
        s.position.z = player.actor.mesh.position.z;
        s.startSize = size;
        s.endSize = 0;
        s.gravity = .005;
        s.dx = dx;
        s.dy = dy;
        s.dz = dz;
        s.slow = .9;
        s.angle = Math.random() * Math.PI2;
        s.rotate = .2 * Math.random() - .1;
        s.collide = true;
    };
};

function updateParticles(manager, delta) {
    for (var i = 0; i < manager.sprites.length; i++) {
        var s = manager.sprites[i];
        if (s.isVisible) {
            var anim = s.easing(s.anim);
            if (0 <= s.endSize && (s.size = s.startSize + anim * (s.endSize - s.startSize)), s.animColors && lerp(s.animColors, anim, s.color), !s.stopped) {
                s.position.x += s.dx, s.position.y += s.dy + s.float, s.position.z += s.dz, s.rotate && (s.angle += s.rotate);
                var res = false;
                s.collide && (tv1.set(s.position.x, s.position.y, s.position.z), res = Collider.pointCollidesWithMap(tv1, true)), res ? (s.stopped = true, s.position.x -= s.dx, s.position.y -= s.dy, s.position.z -= s.dz) : s.gravity && (s.dy -= s.gravity), s.slow && (s.dx *= s.slow, s.dy *= s.slow, s.dz *= s.slow)
            }
            s.anim += delta / s.animLength, 1 <= s.anim && (s.isVisible = false)
        }
    }
};

// [LS] ######## Settings ---------------------------------
//  ___ ___ _____ _____ ___ _  _  ___ ___
// / __| __|_   _|_   _|_ _| \| |/ __/ __|
// \__ \ _|  | |   | |  | || .` | (_ \__ \
// |___/___| |_|   |_| |___|_|\_|\___|___/


function loadSettings() {
    settings.volume = getStoredNumber("volume", 1) * 2;
    settings.mouseSensitivity = Math.max(Math.min(11, getStoredNumber("mouseSensitivity", 5)), 0);
    settings.mouseInvert = getStoredNumber("mouseInvert", 1);
    settings.holdToAim = getStoredBool("holdToAim", true);
    settings.enableChat = getStoredBool("enableChat", true); //TODO: chat is enabled by default, this is not original behaviour!
    settings.enable18Chat = getStoredBool("enable18Chat", false);
    settings.autoDetail = getStoredBool("autoDetail", true);
    settings.shadowsEnabled = getStoredBool("shadowsEnabled", true);
    settings.highRes = getStoredBool("highRes", true);

    var storedControlMap = JSON.parse(localStorage.getItem("controlConfig"));
    for (var sk in storedControlMap) Object.keys(inputToControlMap).forEach(function (ik) {
        inputToControlMap[ik] == storedControlMap[sk] && delete inputToControlMap[ik]
    }), inputToControlMap[sk] = storedControlMap[sk];
    for (var p in inputToControlMap) {
        var ps = "" + p;
        inputToControlMap.hasOwnProperty(ps) && ps != ps.toLocaleUpperCase() && (delete inputToControlMap[ps], inputToControlMap[ps.toLocaleUpperCase()] = inputToControlMap[p])
    } ! function () {
        for (var k in inputToControlMap) {
            var el = settingsKeyCells[inputToControlMap[k]];
            el && (el.innerText = ("" + k).toLocaleUpperCase())
        }
        document.getElementById("volume").value = settings.volume;
        document.getElementById("mouseSensitivity").value = settings.mouseSensitivity;
        document.getElementById("mouseInvert").checked = -1 == settings.mouseInvert;
        document.getElementById("holdToAim").checked = settings.holdToAim;
        document.getElementById("enableChat").checked = settings.enableChat;
        document.getElementById("autoDetail").checked = settings.autoDetail;
        document.getElementById("enable18Chat").checked = settings.enable18Chat;
        document.getElementById("shadowsEnabled").checked = settings.shadowsEnabled;
        document.getElementById("highRes").checked = settings.highRes;
        setDetailSettingsVisibility(settings.autoDetail);
    }()
};

function getStoredNumber(name, def) {
    var num = localStorage.getItem(name);
    return num ? Number(num) : def
};

function getStoredBool(name, def) {
    var str = localStorage.getItem(name);
    return str ? "true" == str : def
};

function getStoredString(name, def) {
    var str = localStorage.getItem(name);
    return str || def
};

function selectServer(i) {
    selectedServer = i;
    localStorage.setItem("selectedServer", i);
    document.getElementById("serverName").innerText = "Server: " + servers[selectedServer].name;
};

function setDetailSettingsVisibility(invisible) {
    var vis = invisible ? "hidden" : "visible";
    document.getElementById("extraDetails").style.visibility = vis, !invisible && inGame ? (settings.shadowsEnabled = gameScene.shadowsEnabled, settings.highRes = 1 == engine.getHardwareScalingLevel(), document.getElementById("shadowsEnabled").checked = settings.shadowsEnabled, document.getElementById("highRes").checked = settings.highRes, localStorage.setItem("shadowsEnabled", settings.shadowsEnabled ? "true" : "false"), localStorage.setItem("highRes", settings.highRes ? "true" : "false")) : inGame && (enableShadows(), increaseResolution())
};


// [LS] ######## Inputs ---------------------------------
//  ___ _  _ ___ _   _ _____ ___
// |_ _| \| | _ \ | | |_   _/ __|
//  | || .` |  _/ |_| | | | \__ \
// |___|_|\_|_|  \___/  |_| |___/


// [LS] Canvas Listeners
function addCanvasListeners() {
    console.log("Event listeners added");
    canvas.style.pointerEvents = "all";
    canvas.addEventListener("mousedown", onCanvasMouseDown, false);
    canvas.addEventListener("mouseup", onCanvasMouseUp, false);
    canvas.addEventListener("mousemove", onCanvasMouseMove);
    canvas.addEventListener("wheel", onCanvasMouseWheel);
};

function removeCanvasListeners() {
    console.log("Event listeners removed");
    canvas.style.pointerEvents = "none";
    canvas.removeEventListener("mousedown", onCanvasMouseDown);
    canvas.removeEventListener("mouseup", onCanvasMouseUp);
    canvas.removeEventListener("mousemove", onCanvasMouseMove);
    canvas.removeEventListener("wheel", onCanvasMouseWheel);
};

function onCanvasMouseDown(event) {
    if (unfocused) {
        unfocused = false;
        canvas.requestPointerLock();
    };
    inputDown("MOUSE " + event.button), 1 == event.button && event.preventDefault()
};

function onCanvasMouseUp(event) {
    inputUp("MOUSE " + event.button)
};

function onCanvasMouseMove(event) {
    if (document.pointerLockElement && me && 0 < me.hp) {
        var mult = 5e-4 * settings.mouseSensitivity + .001;
        me.actor.scope && (mult *= .3);
        var mx = event.movementX;
        lastMouseMovement.x && Math.sign(mx) != Math.sign(lastMouseMovement.x) && (mx = 0), lastMouseMovement.x = mx;
        var my = event.movementY;
        lastMouseMovement.y && Math.sign(my) != Math.sign(lastMouseMovement.y) && (my = 0), lastMouseMovement.y = my, me.yaw = Math.radAdd(me.yaw, mx * mult), me.pitch = Math.clamp(me.pitch + my * settings.mouseInvert * mult, -1.5, 1.5)
    }
};

function onCanvasMouseWheel(event) {
    0 < event.wheelDelta ? (inputDown("WHEEL UP"), inputUp("WHEEL UP")) : (inputDown("WHEEL DOWN"), inputUp("WHEEL DOWN"))
};

window.addEventListener("contextmenu", function (e) {
    e.preventDefault()
}, false);

var keysReleased;
function captureKeys() {
    lastKey = null; keysReleased = false;
    document.onkeydown = onKeyDown;
    document.onkeyup = onKeyUp;
};

function releaseKeys() {
    document.onkeyup = null; keysReleased = true;
};

function inputDown(code) {
    me.playing && (document.pointerLockElement || unfocused) && function (control) {
        switch (control) {
            case "up":
            case "down":
            case "left":
            case "right":
                var bit = CONTROL[control];
                me.controlKeys |= bit;
                me.stateBuffer[me.stateIdx].controlKeys = me.controlKeys;
                break;
            case "jump":
                if (0 < me.lastTouchedGround && Date.now() > me.lastTouchedGround + 100 && me.jump()) {
                    // var output = new Comm.Out(1);
                    // output.packInt8(Comm.Code.jump);
                    // wsSend(output, "jump");
                    var bit = CONTROL[control];
                    me.controlKeys |= bit;
                    me.stateBuffer[me.stateIdx].controlKeys = me.controlKeys;
                };
                break;
            case "fire":
                document.pointerLockElement && me && me.pullTrigger();
                break;
            case "grenade":
                document.pointerLockElement && me && !grenadePowerUp && me.canSwapOrReload() && 0 < me.grenadeCount && (grenadePowerUp = true, grenadeThrowPower = -.15);
                break;
            case "scope":
                settings.holdToAim ? me.actor.scopeIn() : me.actor.scope ? me.actor.scopeOut() : me.actor.scopeIn();
                break;
            case "reload":
                me.reload();
                break;
            case "weapon":
                me.swapWeapon(0 == me.weaponIdx ? 1 : 0);
                break;
            case "unfocus":
                unfocused = !unfocused;
                if (unfocused) {
                    document.exitPointerLock();
                } else {
                    canvas.requestPointerLock();
                };
                break;
        }
    }(inputToControlMap[code])
};

function inputUp(code, control) {
    me.playing && (document.pointerLockElement || unfocused) && function (control) {
        switch (control) {
            case "fire":
                me.weapon && me.releaseTrigger();
                break;
            case "scope":
                settings.holdToAim && me.actor.scopeOut();
                break;
            case "grenade":
                document.pointerLockElement && me && grenadePowerUp && (document.getElementById("grenadeThrowContainer").style.visibility = "hidden", grenadePowerUp = false, me.throwGrenade(grenadeThrowPower));
                break;
            case "up":
            case "down":
            case "left":
            case "right":
            case "jump":
                var bit = CONTROL[control];
                me.controlKeys ^= me.controlKeys & bit
        }
    }(control || inputToControlMap[code])
};

function onKeyDown(e) {
    var key = (e = e || window.event).key;
    // devlog(key);
    if (key != lastKey) {
        lastKey = key;
        if ((grenadePowerUp || 0 != me.controlKeys || ("Enter" != key && "/" != key && "@" != key) || !settings.enableChat) && !keysReleased) {
            var k = ("" + key).toLocaleUpperCase();
            if (" " == k && (k = "SPACE", e.preventDefault()), debug) {
                if ("`" == k) return void

                    function () {
                        if (debugWindow) {
                            for (var i = 0; i < playerLimit; i++) {
                                var p = players[i];
                                if (p) {
                                    var player = {
                                        name: p.name,
                                        hp: p.hp,
                                        playing: p.playing,
                                        posX: p.x,
                                        posY: p.y,
                                        posZ: p.z,
                                        actorX: p.actor.mesh.position.x,
                                        actorY: p.actor.mesh.position.y,
                                        actorZ: p.actor.mesh.position.z,
                                        transformEnabled: p.actor.mesh.isEnabled(),
                                        transformVisible: p.actor.mesh.isVisible,
                                        transformFrozen: p.actor.mesh.isWorldMatrixFrozen,
                                        shellEnabled: p.actor.bodyMesh.isEnabled(),
                                        shellVisible: p.actor.bodyMesh.isVisible,
                                        shellFrozen: p.actor.bodyMesh.isWorldMatrixFrozen,
                                        weaponEnabled: p.weapon.actor.gunMesh.isEnabled(),
                                        weaponVisible: p.weapon.actor.gunMesh.isVisible
                                    };
                                    debugWindow.document.write(JSON.stringify(player) + "\n")
                                }
                            }
                            debugWindow.document.write("<hr>")
                        } else (debugWindow = window.open("", "", "name=Debug")).document.write("<pre>")
                    }();
                if ("\\" == k) {
                    freezeFrame = true;
                    for (var i = 0; i < gameScene.particleSystems.length; i++) gameScene.particlesPaused = true;
                    for (i = 0; i < playerLimit; i++) players[i] && players[i].actor && (players[i].actor.mesh.setVisible(true), players[i].actor.showNameSprite(), players[i].actor.positionNameSprite());
                    ws.close()
                }
            }
            inputDown(k)
        } else if (me.chatLineCap > 0) {
            beginChat();
        };
    };
};

function onKeyUp(e) {
    var key = (e = e || window.event).key;
    key == lastKey && (lastKey = null);
    var k = ("" + key).toLocaleUpperCase();
    " " == k && (k = "SPACE", e.preventDefault()), inputUp(k)
};

// [LS] Input Settings

function setControl(el) {
    ! function (el) {
        var els = document.getElementsByClassName("box defined");
        Array.prototype.slice.call(els).forEach(function (otherEl) {
            otherEl != el && otherEl.innerText == el.innerText && (delete inputToControlMap[otherEl.innerText], otherEl.className = "box undefined", otherEl.innerText = getLocText("ui_settings_undefined"))
        })
    }(el), delete inputToControlMap[el.oldText], inputToControlMap[el.innerText] = el.id, controlEl = null, window.onkeydown = null, window.onkeyup = null, localStorage.setItem("controlConfig", JSON.stringify(inputToControlMap))
};

function configKey(e) {
    var el = e.target;
    e = e || window.event, el == controlEl ? (1 == e.button && window.event.preventDefault(), el.className = "box defined", null != e.wheelDelta ? 0 < e.wheelDeltaY ? el.innerText = "WHEEL UP" : e.wheelDeltaY < 0 && (el.innerText = "WHEEL DOWN") : el.innerText = "MOUSE " + e.button, setControl(el)) : (controlEl && (controlEl.className = "box defined", controlEl.innerText = controlEl.oldText), el.oldText = el.innerText, el.className = "box active", el.innerText = getLocText("ui_settings_bindinput"), (controlEl = el).focus(), window.onkeydown = function (e) {
        var key = (e = e || window.event).key;
        if ("Escape" != key && "Tab" != key && "Enter" != key) return " " == key && (key = "space", e.preventDefault()), el.className = "box defined", el.innerText = key.toLocaleUpperCase(), setControl(el), e.stopPropagation(), false;
        el.className = "box defined", el.innerText = el.oldText, controlEl = null
    }, window.onkeyup = function (e) {
        return e.stopPropagation(), false
    })
};


// [LS] ######## PlayerAccount ---------------------------------
//  ___ _      ___   _____ ___    _   ___ ___ ___  _   _ _  _ _____
// | _ \ |    /_\ \ / / __| _ \  /_\ / __/ __/ _ \| | | | \| |_   _|
// |  _/ |__ / _ \ V /| _||   / / _ \ (_| (_| (_) | |_| | .` | | |
// |_| |____/_/ \_\_| |___|_|_\/_/ \_\___\___\___/ \___/|_|\_| |_|

class PlayerAccountConstructor { //converted to class just because all these wannabe classes piss me off
    constructor () {
        this.loggedOut();
    };
    loggedOut () {
        this.session = null, this.kills = 0, this.deaths = 0, this.streak = 0, this.currentBalance = 0, this.classIdx = 0, this.inventory = [], this.pickedWeapons = [], this.stampItem = null, this.hatItem = null, this.colorIdx = 0, this.isLoggedIn = false, this.killMultiplier = 1, this.hideAds = false, this.upgradeExpiryDate = null, this.upgradeIsExpired = false, this.maybeSchoolEmail = false;
        for (var cIdx = 0; cIdx < CharClass.length; cIdx++) {
            var defaultPicks = [catalog.forClass[cIdx].primaryWeapons[0], catalog.forClass[cIdx].secondaryWeapons[0]];
            this.pickedWeapons.push(defaultPicks)
        }
    };
    setClass (classIdx) {
        this.classIdx = classIdx
    };
    pickWeapon (slot, weaponItem) {
        var foundInList = catalog.findItemInListById(weaponItem, catalog.forClass[this.classIdx].forWeaponSlot[slot]);
        false === foundInList && (weaponItem = catalog.forClass[this.classIdx].forWeaponSlot[slot][0]), this.pickedWeapons[this.classIdx][slot] = weaponItem
    };
    getPickedWeaponInSlot (slot) {
        return this.pickedWeapons[this.classIdx][slot]
    };
    getPrimaryWeapon () {
        return this.getPickedWeaponInSlot(Slot.Primary)
    };
    getSecondaryWeapon () {
        return this.getPickedWeaponInSlot(Slot.Secondary)
    };
    isUpgraded () {
        return void 0 !== this.upgradeProductId && null !== this.upgradeProductId && false === this.upgradeIsExpired
    };
    isItemOwned (item) {
        for (var i = 0; i < this.inventory.length; i++)
            if (this.inventory[i] && this.inventory[i].id === item.id) return true;
        return false
    };
    getEquippedItems () {
        var equippedItems = [this.getPrimaryWeapon(), this.getSecondaryWeapon()];
        return null !== this.hatItem && equippedItems.push(this.hatItem), null !== this.stampItem && equippedItems.push(this.stampItem), equippedItems
    };
    isItemEquipped (item) {
        if (null === item) return false;
        var foundItem = catalog.findItemInListById(item.id, this.getEquippedItems());
        return null !== foundItem
    };
    loggedIn (accountData) {
        devlog("this.loggedIn", accountData);
        var hasValue = function (a) {
            return null != a && 0 !== a
        };
        this.username = accountData.username;
        this.account_id = String(accountData.account_id);
        this.adminRoles = accountData.adminRoles;
        this.session = accountData.session;
        this.kills = accountData.kills;
        this.deaths = accountData.deaths;
        this.streak = accountData.streak;
        this.currentBalance = accountData.currentBalance;
        this.ownedItemIds = accountData.ownedItemIds;
        this.upgradeProductId = accountData.upgradeProductId;
        this.killMultiplier = hasValue(accountData.upgradeMultiplier) ? accountData.upgradeMultiplier : 1;
        this.hideAds = !!hasValue(accountData.upgradeAdFree) && accountData.upgradeAdFree;
        this.upgradeExpiryDate = hasValue(accountData.upgradeExpiryDate) ? accountData.upgradeExpiryDate : null;
        this.upgradeIsExpired = hasValue(accountData.upgradeExpiryDate) ? accountData.upgradeIsExpired : null;
        this.maybeSchoolEmail = accountData.maybeSchoolEmail;
        var version = void 0 === accountData.version || null === accountData.version ? 1 : accountData.version;
        localStorage.setItem("LegacyShellAuthToken", accountData.authToken);
        localStorage.setItem("LegacyShellPreviousUsername", accountData.username);

        if (1 <= version) {
            if (void 0 !== accountData.loadout && null !== accountData.loadout) {
                void 0 !== accountData.loadout.classIdx && null !== accountData.loadout.classIdx && this.setClass(accountData.loadout.classIdx);
                for (var outer = this, trySetPickedWeapon = function (weaponId, classIdx, slot) {
                    var weaponItem = catalog.forClass[classIdx].forWeaponSlot[slot][0];
                    hasValue(weaponId) && (weaponItem = catalog.findItemById(weaponId)), outer.pickedWeapons[classIdx][slot] = weaponItem
                }, c = 0; c < CharClass.length; c++) trySetPickedWeapon(accountData.loadout.primaryId[c], c, Slot.Primary), trySetPickedWeapon(accountData.loadout.secondaryId[c], c, Slot.Secondary);
                if (hasValue(accountData.loadout.hatId)) {
                    var hatItem = catalog.findItemById(accountData.loadout.hatId);
                    this.hatItem = hatItem
                }
                if (hasValue(accountData.loadout.stampId)) {
                    var stampItem = catalog.findItemById(accountData.loadout.stampId);
                    this.stampItem = stampItem
                }
                hasValue(accountData.loadout.colorIdx) && (this.colorIdx = accountData.loadout.colorIdx, 7 <= this.colorIdx && false === this.isUpgraded() && (this.colorIdx = 0))
            }
            if (hasValue(accountData.ownedItemIds))
                for (var i = 0; i < accountData.ownedItemIds.length; i++) {
                    var item = catalog.findItemById(accountData.ownedItemIds[i]);
                    this.inventory.push(item)
                }
        }
        this.isLoggedIn = true
    };
    setUpgrade (getUpgradeData) {
        this.upgradeProductId = getUpgradeData.upgradeProductId;
        this.multiplier = getUpgradeData.multiplier;
        this.hideAds = getUpgradeData.hideAds;
        this.upgradeIsExpired = getUpgradeData.isExpired;
        7 <= this.colorIdx && false === this.isUpgraded() && (this.colorIdx = 0);
    };
    syncToServer () {
        try {
            var servicesWs = new WebSocket(servicesServer)
        } catch (e) {
            console.log(e)
        }
        var updateHatId = void 0 !== playerAccount.hatItem && null !== playerAccount.hatItem ? playerAccount.hatItem.id : null,
            updateStampId = void 0 !== playerAccount.stampItem && null !== playerAccount.stampItem ? playerAccount.stampItem.id : null,
            loadout = {
                cmd: "saveEquip",
                session: this.session,
                class_idx: this.classIdx,
                soldier_primary_item_id: this.pickedWeapons[CharClass.Soldier][Slot.Primary].id,
                soldier_secondary_item_id: this.pickedWeapons[CharClass.Soldier][Slot.Secondary].id,
                scrambler_primary_item_id: this.pickedWeapons[CharClass.Scrambler][Slot.Primary].id,
                scrambler_secondary_item_id: this.pickedWeapons[CharClass.Scrambler][Slot.Secondary].id,
                ranger_primary_item_id: this.pickedWeapons[CharClass.Ranger][Slot.Primary].id,
                ranger_secondary_item_id: this.pickedWeapons[CharClass.Ranger][Slot.Secondary].id,
                eggsploder_primary_item_id: this.pickedWeapons[CharClass.Eggsploder][Slot.Primary].id,
                eggsploder_secondary_item_id: this.pickedWeapons[CharClass.Eggsploder][Slot.Secondary].id,
                hat_id: updateHatId,
                stamp_id: updateStampId,
                color: this.colorIdx,
                save: "undefined" == typeof checkStatus || checkStatus()
            },
            json = JSON.stringify(loadout);
        servicesWs.onopen = function (e) {
            servicesWs.send(json), console.log("servicesWs opened, and saveEquip request sent")
        }, servicesWs.onmessage = function (e) {
            var responseData = JSON.parse(e.data);
            responseData.error ? console.log("SyncToServer Error: " + JSON.stringify(responseData.error)) : console.log("SyncToServer completed successfully");
            servicesWs.close();
        }, servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason)
        }, servicesWs.onerror = function (e) {
            console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
        }
    };
};

playerAccount = new PlayerAccountConstructor();

// [LS] ######## Signing In ---------------------------------
//  ___ ___ ___ _  _ ___ _  _  ___   ___ _  _
// / __|_ _/ __| \| |_ _| \| |/ __| |_ _| \| |
// \__ \| | (_ | .` || || .` | (_ |  | || .` |
// |___/___\___|_|\_|___|_|\_|\___| |___|_|\_|


function loggedIn(accountDataResponse) {
    devlog("function loggedIn", accountDataResponse)
    var numPurchases;
    if (accountDataResponse.error) {
        statsEl.innerHTML = "Database error. Please send us a bug report!";
        console.log("accountDataResponse Error: " + JSON.stringify(accountDataResponse.error));
    } else {
        playerAccount.loggedIn(accountDataResponse);
        updatePlayerStatsDisplay();
        updateCurrentBalance();
        waitForSetupAndAuthComplete();
        numPurchases = void 0 === playerAccount.inventory || null === playerAccount.inventory ? 0 : playerAccount.inventory.length;
    };
    console.log("logged in");
    // statsEl.style.display = "none";
    document.getElementById("login").style.display = "none";
    document.getElementById("logout").style.display = "block";
    document.getElementById("user-greeting").style.display = "block";
    document.getElementById("user-greeting").innerText = "Welcome back, @" + playerAccount.username;
    document.getElementById("playerStats").style.display = "flex";
    customizer = new Customizer, extern.customizer = customizer, authAttemptComplete = true
    // if (!playerAccount.isLoggedIn && !loggingIn) {
    //     if (loggingIn = true, user.getIdToken(true).then(function (idToken) {
    //         (statsEl = document.getElementById("statsMessage")).innerHTML = "Retrieving your stats...", statsEl.style.display = "block", console.log("Using services server: " + servicesServer);
    //         try {
    //             var authWs = new WebSocket(servicesServer)
    //         } catch (e) {
    //             console.log(e)
    //         }
    //         showSpinner("Retrieving Account", "I KNOW you're in here somewhere..."), authWs.onopen = function (e) {
    //             var authData = {
    //                 cmd: "auth",
    //                 uid: user.uid,
    //                 token: idToken
    //             };
    //             "undefined" != typeof modifyAuthData && modifyAuthData(authData), authWs.send(JSON.stringify(authData)), console.log("authWs opened, and auth request sent")
    //         }, authWs.onmessage = function (e) {
    // }, authWs.onclose = function (e) {
    //     console.log("authWs closed: " + e.code + " " + e.reason), loggingIn = false
    // }, authWs.onerror = function (e) {
    //     statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("authWS Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"])), loggingIn = false
    // }
    //     }).catch(function (error) {
    //         console.log(error), loggingIn = false
    //     }), document.getElementById("login").style.display = "none", document.getElementById("logout").style.display = "block", user.photoURL) {
    //         var url = user.photoURL,
    //             pd = user.providerData[0];
    //         "facebook.com" == pd.providerId && (url = "https://graph.facebook.com/" + pd.uid + "/picture"), document.getElementById("profilePic").src = url, document.getElementById("profilePic").style.display = "block"
    //     }
    // }
};

function loginFail(dueToOffline) {
    if (!dueToOffline) {
        delete localStorage.LegacyShellAuthToken;
        delete localStorage.LegacyShellPreviousUsername;
    };
    devlog("loginFail");
    document.getElementById("login").style.display = "block";
    customizer = new Customizer;
    extern.customizer = customizer;
    authAttemptComplete = true;
    document.getElementById("logout").style.display = "none";
    document.getElementById("user-greeting").style.display = "none";
    document.getElementById("currentBalanceContainer").style.display = "none";
    document.getElementById("currentBalance").innerText = "0";
    purchasingEnabled = false;
    waitForSetupAndAuthComplete();
    //thanks, no thanks :P
    // console.log("Sending anon tags to OneSignal..."), unbloated3({
    //     has_account: false,
    //     maybe_school: false,
    //     is_chromebook: detectChromebook()
    // })
};

function openLoginDialog() {
    openAlertDialog(
        "Login",
        `<div id="LS-login-container">
            <form id="LS-loginForm">
                <label for="LS-username">Username:</label><br>
                <input type="text" id="LS-username" name="username" required pattern="[A-Za-z0-9_\\-]{3,20}" title="Username must be 3-20 characters long and can only include letters, numbers, underscores, and hyphens."><br>
                <label for="LS-password">Password:</label><br>
                <input type="password" id="LS-password" name="password" required pattern=".{8,}" title="Password must be at least 8 characters long."><br>
            </form>
            <div id="LS-login-error" style="color:red;display:none;">Error text.</div>
            <div style="text-align: center;">
                <p style="font-size: 0.9em;">
                    No account?
                    <button class="ssbutton purple" style="width: 8em; margin-top: 10px; margin-left: 10px;" onclick="extern.openRegisterDialog()">Register</button>
                </p>
                <p style="font-size: 0.8em; color: #555; max-width: 20em; margin: 0 auto; word-wrap: break-word;">
                    Note: These servers are unofficial and do not work with real Shell Shockers account details.
                </p>
            </div>
        </div>`,
        {
            label: "Login",
            width: "8em",
            onclick: clickedLogin
        },
        {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        }
    );
};

function openRegisterDialog() {
    openAlertDialog(
        "Register",
        `<div id="LS-register-container">
            <form id="LS-registerForm">
                <label for="LS-register-username">Username:</label><br>
                <input type="text" id="LS-register-username" name="username" required pattern="[A-Za-z0-9_\\-]{3,20}" title="Username must be 3-20 characters long and can only include letters, numbers, underscores, and hyphens."><br>
                <label for="LS-register-password">Password:</label><br>
                <input type="password" id="LS-register-password" name="password" required pattern=".{8,}" title="Password must be at least 8 characters long."><br>
            </form>
            <div id="LS-register-error" style="color:red;display:none;">Error text.</div>
            <div style="text-align: center;">
                <p style="font-size: 0.9em;">
                    Already have an account?
                    <button class="ssbutton purple" style="width: 8em; margin-top: 10px; margin-left: 10px;" onclick="extern.openLoginDialog()">Login</button>
                </p>
                <p style="font-size: 0.8em; color: #555; max-width: 20em; margin: 0 auto; word-wrap: break-word;">
                    Note: These servers are unofficial. Please use a unique username and password.
                </p>
            </div>
        </div>`,
        {
            label: "Create",
            width: "8em",
            onclick: clickedRegister
        },
        {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        }
    );
};

async function clickedLogin() {
    var username = document.getElementById("LS-username").value;
    var password = document.getElementById("LS-password").value;

    showSpinner("Retrieving Account", "I KNOW you're in here somewhere...");

    if (username.length < 3 || password.length < 2) {
        hideSpinner();
        document.getElementById("LS-login-error").style.display = "block";
        document.getElementById("LS-login-error").textContent = "Invalid username or password.";
    } else {
        try {
            let result = await validateLogin(username, sha256(password));
            hideSpinner();
            devlog(result)
            if (result.error) {
                document.getElementById("LS-login-error").style.display = "block";
                document.getElementById("LS-login-error").textContent = result.error;
            } else if (result.session) {
                loggedIn(result);
                closeAlertDialog();
            };
        } catch (error) {
            hideSpinner();
            console.error("Login failed:", error);
            document.getElementById("LS-login-error").style.display = "block";
            document.getElementById("LS-login-error").textContent = "Request error.";
        };
    }
};

async function clickedRegister() {
    var username = document.getElementById("LS-register-username").value;
    var password = document.getElementById("LS-register-password").value;

    showSpinner("Creating Account", "Get set, ready, GO!");

    try {
        if (username.length < 3 || !/^[A-Za-z0-9?!._-]+$/.test(username)) {
            hideSpinner();
            document.getElementById("LS-register-error").textContent = "Invalid username. Only letters, numbers, ?!._- are allowed.";
            document.getElementById("LS-register-error").style.display = "block";
            return false;
        } else if (!(/^(?=.*[A-Za-z])(?=.*\d).{8,}$/).test(password)) {
            hideSpinner();
            document.getElementById("LS-register-error").style.display = "block";
            document.getElementById("LS-register-error").textContent = "Password is too insecure.\nAt least 8 characters, 1 letter and 1 number are required."
        } else {
            let result = await validateRegister(username, sha256(password));
            hideSpinner();
            devlog(result);

            if (result.error) {
                document.getElementById("LS-register-error").style.display = "block";
                document.getElementById("LS-register-error").textContent = result.error;
            } else if (result.session) {
                loggedIn(result);
                closeAlertDialog();
            };
        };
    } catch (error) {
        hideSpinner();
        console.error("Register failed:", error);
        document.getElementById("LS-register-error").style.display = "block";
        document.getElementById("LS-register-error").textContent = "Request error.";
    };
};

function waitForSetupAndAuthComplete() {
    if (waitIteration >= 200) {
        openAlertDialog("", '<div id="setupAndAuthTimedOut">Uh oh, there was a problem. Try reloading the page.</div>', {
            label: "Close",
            width: "8em",
            onclick: closeAlertDialog
        })
    } else {
        if (null != customizer && true === customizer.isReady && authAttemptComplete && houseAdsLoaded) {
            customizer.setupItems();
            customizer.dressUpEgg();
            setupUpgradeUI();
            pingServers(true, function () {
                var showDate;
                onResourcesLoaded();
                isRunning = true;
                (function () {
                    var searchParams = new URLSearchParams(document.location.search);
                    if (false === searchParams.has("showItem")) return false;
                    var showItemId = parseInt(searchParams.get("showItem"));
                    return false !== (Number.isInteger(showItemId) && null !== catalog.findItemById(showItemId) && false === linkItemShown) && (linkItemShown = openItemInCustomizer(showItemId))
                }()) || tryShowTaggedItems() || tryShowNugget() || true;
            });
        } else {
            waitIteration++;
            setTimeout(waitForSetupAndAuthComplete, 100);
        };
    };
};

// [LS] Login Request Stuff

function validateLogin(username, hashedPassword) {
    return new Promise((resolve, reject) => {
        devlog(username, hashedPassword);
        devlog("validateLogin called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        }

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateLogin",
                username: username,
                password: hashedPassword,
            }));
            console.log("servicesWs opened, and validateLogin request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            }
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

function validateLoginViaAuthToken(username, authToken) {
    return new Promise((resolve, reject) => {
        devlog(username, authToken);
        devlog("validateLogin called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        }

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateLoginViaAuthToken",
                username: username,
                authToken: authToken,
            }));
            console.log("servicesWs opened, and validateLoginViaAuthToken request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            };
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

function validateRegister(username, hashedPassword) {
    return new Promise((resolve, reject) => {
        devlog(username, hashedPassword);
        devlog("validateRegister called");

        let servicesWs;
        try {
            servicesWs = new WebSocket(servicesServer);
        } catch (e) {
            console.log(e);
            reject(e);
            return;
        };

        servicesWs.onopen = function () {
            servicesWs.send(JSON.stringify({
                cmd: "validateRegister",
                username: username,
                password: hashedPassword,
            }));
            console.log("servicesWs opened, and validateRegister request sent");
        };

        servicesWs.onmessage = function (e) {
            let response;
            try {
                response = JSON.parse(e.data);
                console.log(response);
                resolve(response);
            } catch (error) {
                reject("Failed to parse response");
            } finally {
                servicesWs.close();
            }
        };

        servicesWs.onclose = function (e) {
            console.log("servicesWs closed: " + e.code + " " + e.reason);
            if (e.code !== 1000) { // Non-normal closure
                reject(`WebSocket closed unexpectedly: ${e.reason}`);
            }
        };

        servicesWs.onerror = function (e) {
            console.log("servicesWs Error:", e);
            reject("WebSocket error occurred");
        };
    });
};

// [LS] ######## Extern ---------------------------------
//  _____  _______ ___ ___ _  _
// | __\ \/ /_   _| __| _ \ \| |
// | _| >  <  | | | _||   / .` |
// |___/_/\_\ |_| |___|_|_\_|\_|

window.extern = function () {
    return {
        plugins,
        openLoginDialog: openLoginDialog,
        openRegisterDialog: openRegisterDialog,
        Items: Items,
        logout: function (callback) {
            // firebase.auth().signOut().then(function () {
            // }, function (err) {
            //     console.log(err)
            // })
            document.getElementById("login").style.display = "block";
            document.getElementById("logout").style.display = "none";
            document.getElementById("user-greeting").style.display = "none";
            document.getElementById("profilePic").style.display = "none";
            document.getElementById("playerStats").style.display = "none";
            document.getElementById("statsMessage").style.display = "none";
            document.getElementById("currentBalanceContainer").style.display = "none";
            document.getElementById("currentBalance").innerText = "0";
            playerAccount.loggedOut();
            setupUpgradeUI();
            user = null;
            delete localStorage.LegacyShellAuthToken;
            delete localStorage.LegacyShellPreviousUsername;
            customizer.dressUpEgg();
        },
        play: play,
        closeCreateGameDialog: function () {
            document.getElementById("createGameDialog").style.display = "none", hideDarkOverlay()
        },
        openServerList: function () {
            openAlertDialog("Servers", "", {
                label: "Close",
                width: "6em",
                onclick: closeServerList
            });
            for (var serverItem = document.getElementById("serverItem"), list = document.createElement("form"), barColors = ["lime", "yellow", "orange", "red"], i = 0; i < servers.length; i++) {
                var server = serverItem.cloneNode(true);
                server.style.display = "block";
                var border, pingColor, checkEl = server.children[0].children[0],
                    nameEl = server.children[0].children[1],
                    barEl = (server.children[0].children[2], server.children[0].children[3]),
                    offlineEl = server.children[0].children[4],
                    msEl = server.children[0].children[5];
                nameEl.innerText = servers[i].name, checkEl.value = i, servers[i].ping ? (border = Math.min(5.4, Math.max(0, (servers[i].ping - 50) / 65)) + .1, pingColor = Math.min(3, Math.floor(servers[i].ping / 100)), barEl.style.display = "block", offlineEl.style.display = "none", barEl.style.backgroundColor = barColors[pingColor], barEl.style.borderRight = border + "em solid var(--egg-brown)", msEl.innerText = servers[i].ping + "ms") : (barEl.style.display = "none", offlineEl.style.display = "block"), list.appendChild(server)
            }
            document.getElementById("alertMessage").appendChild(list), list.children[selectedServer].children[0].children[0].checked = true, list.addEventListener("change", function (e) {
                selectServer(e.target.value)
            })
        },
        openCustomizerFromMainMenu: openCustomizerFromMainMenu,
        openCustomizerInGame: function () {
            hideGameDom(), engine.stopRenderLoop(), customizer.open(), customizer.startRendering()
        },
        showFeedbackForm: function () {
            inGame && releaseKeys(), ga("send", "event", "feedback opened"), openAlertDialog("Feedback", "", {
                label: "Send",
                width: "6em",
                onclick: sendFeedback
            }, {
                label: "Cancel",
                width: "6em",
                onclick: closeFeedback
            }), document.getElementById("alertButton1").style.visibility = "hidden", document.getElementById("alertMessage").appendChild(document.getElementById("feedback")), document.getElementById("feedback").style.display = "block"
        },
        feedbackChanged: function (e) {
            var fd = document.getElementById("feedbackComments"),
                fe = document.getElementById("feedbackEmail");
            feedbackValidateTimeout && clearTimeout(feedbackValidateTimeout), feedbackValidateTimeout = setTimeout(function () {
                "" != fd.value && "" != fe.value ? document.getElementById("alertButton1").style.visibility = "visible" : document.getElementById("alertButton1").style.visibility = "hidden"
            }, 200)
        },
        selectGameType: function (i) {
            gameType = i - 1;
            localStorage.setItem("gameType", i);
            refreshMapPool();
        },
        openJoinBox: openJoinBox,
        closeJoinBox: function () {
            document.getElementById("customGame").style.display = "block", document.getElementById("joinGame").style.display = "none", document.getElementById("joinCode").value = "", history.replaceState(null, null, location.pathname)
        },
        openCreateBox: function () {
            document.getElementById("customGame").style.display = "none", document.getElementById("createGame").style.display = "block"
        },
        closeCreateBox: function () {
            document.getElementById("customGame").style.display = "block", document.getElementById("createGame").style.display = "none"
        },
        showChangelog: function () {
            openAlertDialog("Version " + version, document.getElementById("changelog").innerHTML, {
                label: "OK"
            });
        },
        showConfig: function () {
            openAlertDialog("LegacyShell Config", document.getElementById("config").innerHTML, {
                label: "OK"
            });
        },
        respawn: function () {
            if (playOffline) return me.playing = true, void canvas.requestPointerLock();
            console.log("Respawn pressed - respawnTime: " + respawnTime);
            if (null == respawnTime || respawnTime < 0) {
                interval.clearAll();
                timeout.clearAll();
                requestRespawn();
            };
        },
        copyFriendCode: copyFriendCode,
        dismissNotification: dismissNotification,
        closeSettingsMenu: closeSettingsMenu,
        setVolume: function (el) {
            settings.volume = el.value,
            localStorage.setItem("volume", settings.volume),

            apolloSetVolume(settings.volume),

            //keeping bab stuff just in case something in this whole thing still runs on bab. ALTHOUGH that should error now, bc we don't even load bab sounds any
            BABYLON.Engine.audioEngine.setGlobalVolume(settings.volume),
            0 == settings.volume ? BABYLON.Engine.audioEngine.audioContext.suspend() : BABYLON.Engine.audioEngine.audioContext.resume()
        },
        setMusicVolue: function (el) {
            settings.musicVolume = el.value, localStorage.setItem("musicVolume", settings.musicVolume), Music.menu && Music.menu.setVolume(el.value), Music.game && Music.game.setVolume(el.value)
        },
        setMouseSensitivity: function (el) {
            settings.mouseSensitivity = el.value, localStorage.setItem("mouseSensitivity", settings.mouseSensitivity)
        },
        setCheckOption: function (el) {
            var val = el.checked;
            switch (el.id) {
                case "mouseInvert":
                    val = el.checked ? -1 : 1;
                    break;
                case "autoDetail":
                    el.checked ? enableAutoDetail() : (optimizer.stop(), optimizer.dispose(), optimizer = null), setDetailSettingsVisibility(el.checked);
                    break;
                case "shadowsEnabled":
                    el.checked ? enableShadows() : disableShadows();
                    break;
                case "highRes":
                    el.checked ? increaseResolution() : lowerResolution();
                    break;
                case "enableChat":
                    el.checked ? (document.getElementById("enableChat").checked = true, settings.enableChat = true, localStorage.setItem("enableChat", true), chatInEl.value = "Press ENTER to chat", inGame && (chatOutEl.style.display = "block", chatInEl.style.display = "block")) : (settings.enableChat = false, localStorage.setItem("enableChat", false), inGame && (chatOutEl.style.display = "none", chatInEl.style.display = "none"))
            }
            settings[el.id] = val;
            localStorage.setItem(el.id, val)
        },
        openPrivacyOptions: function () {
            // closeSettingsMenu(), openAlertDialog("Privacy Options", document.getElementById("privacyOptions").innerHTML, {
            //     label: "OK"
            // });
            // var ofAgeCheck = document.getElementById("ofAgeCheck"),
            //     targetedAdsCheck = document.getElementById("targetedAdsCheck");
            // targetedAdsCheck.checked = consent ? (ofAgeCheck.checked = consent.ofAge, consent.targetedAds) : (consent = {
            //     ofAge: false,
            //     targetedAds: false
            // }, ofAgeCheck.checked = false), consent.ofAge || (targetedAdsCheck.disabled = true, document.getElementById("targetedAdsText").style.opacity = .25)
        },
        switchTeamDialog: function () {
            openAlertDialog("", 1 == me.team ? 'Switch to team<h1 class="redTeam">RED?</h1>Your score will be reset!' : 'Switch to team<h1 class="blueTeam">BLUE?</h1>Your score will be reset!', {
                label: "Yes",
                width: "5em",
                onclick: switchTeam
            }, {
                label: "No",
                width: "5em",
                onclick: closeAlertDialog
            })
        },
        showMainMenuConfirm: showMainMenuConfirm,
        inviteFriends: inviteFriends,
        openSettingsMenu: openSettingsMenu,
        toggleFullscreen: function () {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) (f = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen) && f.call(document);
            else {
                var f, e = document.body;
                (f = e.requestFullscreen || e.webkitRequestFullscreen || e.mozRequestFullScreen || e.msRequestFullscreen) && (f.call(e), ga("send", "event", "fullscreen"))
            }
        },
        hideBigAd: hideBigAd,
        clickedBigAd: function () {
            ga("send", "event", {
                eventCategory: "Big ad",
                eventAction: "click",
                eventLabel: houseAds.big[bigAdIdx].label
            }), houseAds.big[bigAdIdx].linksToNugget && (showNugget = true, hideBigAd(), tryShowNugget())
        },
        doConsent: function () {
            dismissNotification(function () {
                notify(document.getElementById("doConsent").innerHTML)
            })//, ga("send", "event", "privacy", "age gate", "agree"), consent = {
                // ofAge: true,
                // targetedAds: true
            //}, document.getElementById("login").style.display = "block", aiptag.consented = true, localStorage.setItem("consent", JSON.stringify(consent))
        },
        dontConsent: function () {
            dismissNotification(function () {
                notify(document.getElementById("dontConsent").innerHTML)
            })//, ga("send", "event", "privacy", "age gate", "disagree"), consent = {
            //     ofAge: false,
            //     targetedAds: false
            // }, aiptag.consented = false, localStorage.setItem("consent", JSON.stringify(consent))
        },
        setOfAge: function (e) {
            // var targetedAdsCheck = document.getElementById("targetedAdsCheck"),
            //     targetedAdsText = document.getElementById("targetedAdsText");
            // consent.ofAge = e.checked, ga("send", "event", "privacy", "of age", e.checked ? "yes" : "no"), e.checked ? (targetedAdsCheck.disabled = false, targetedAdsText.style.opacity = 1, document.getElementById("login").style.display = "block") : (consent.targetedAds = false, targetedAdsCheck.checked = false, targetedAdsCheck.disabled = true, targetedAdsText.style.opacity = .25, aiptag.consented = false, document.getElementById("login").style.display = "none"), localStorage.setItem("consent", JSON.stringify(consent))
        },
        setTargetedAds: function (e) {
            //consent.targetedAds = e.checked, aiptag.consented = e.checked, ga("send", "event", "privacy", "targetedAds", e.checked ? "yes" : "no"), localStorage.setItem("consent", JSON.stringify(consent))
        },
        configKey: configKey,
        onChatKeyDown,
        onChatKeyUp,
        onChatClick,
        clickedHouseAd: function () {
            ga("send", "event", {
                eventCategory: "House banner ad",
                eventAction: "click",
                eventLabel: houseAds.small[smallAdIdx].label
            }), houseAds.small[smallAdIdx].link && window.open(houseAds.small[smallAdIdx].link, "_window"), houseAds.small[smallAdIdx].linksToTaggedItems && (showTaggedItems = houseAds.small[smallAdIdx].linksToTaggedItems, tryShowTaggedItems()), houseAds.small[smallAdIdx].linksToItemId && openItemInCustomizer(houseAds.small[smallAdIdx].linksToItemId), houseAds.small[smallAdIdx].linksToNugget && (showNugget = true, tryShowNugget())
        },
        buyItem: function (itemId) {
            console.log("buyItem called for item ID: " + itemId);
            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            servicesWs.onopen = function (e) {
                var buyData = {
                    cmd: "buy",
                    session: playerAccount.session,
                    item_id: itemId,
                    save: "undefined" == typeof checkStatus || checkStatus()
                };
                servicesWs.send(JSON.stringify(buyData))
            }, servicesWs.onmessage = function (e) {
                switch (purchaseResult = JSON.parse(e.data), console.log("purchase response: " + purchaseResult.result), purchaseResult.result) {
                    case "SUCCESS":
                        if (void 0 !== purchaseResult.item_id && null !== purchaseResult) {
                            var boughtItem = catalog.findItemById(purchaseResult.item_id);
                            playerAccount.inventory.push(boughtItem);
                            devlog("nice", boughtItem, purchaseResult);
                        };
                        playerAccount.currentBalance = purchaseResult.current_balance;
                        updateCurrentBalance();
                        // customizer.clearItemLocks();
                        try {
                            customizer.boughtItem();
                        } catch (error) {
                            devlog("bruh it happened", error);
                        }
                        customizer.physicalUnlockBack(); //idk. there is same gay error.
                        break;
                    case "INSUFFICIENT_FUNDS":
                        openAlertDialog("Need More Eggs!", "You need more eggs", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ALREADY_OWNED":
                        openAlertDialog("Already Owned", "You already have this. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "PLAYER_NOT_FOUND":
                        openAlertDialog("Uh Oh", "There was a problem. Try logging in again.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ITEM_NOT_FOUND":
                        openAlertDialog("Uh Oh", "There was a problem. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null);
                        break;
                    case "ERROR":
                    default:
                        console.log("buyItem error: " + purchaseResult.error), openAlertDialog("Uh Oh", "There was a problem. Try reloading the game.", {
                            label: "OK",
                            width: "4em",
                            onclick: closeAlertDialog
                        }, null, null)
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            }
        },
        buyEggs: function () {
            // purchasingEnabled ? XPayStationWidget.open() : getXsollaToken(true, null)
        },
        Customizer,
        openRedeemCodeDialog: function () {
            showDarkOverlay(), document.getElementById("redeemCodeDialog").style.display = "inline-block";
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.value = "";
            redeemCodeInput.disabled = false;
            document.getElementById("enterRedeemCode").style.display = "inline-block";
            document.getElementById("redeemCodeResult").style.display = "none";
            document.getElementById("previewCodeResult").style.display = "none";
            document.exitPointerLock(), window.onkeydown = null, window.onkeyup = null
        },
        closeRedeemCodeDialog: function () {
            document.getElementById("redeemCodeDialog").style.display = "none", hideDarkOverlay()
        },
        redeemCode: function () {
            document.getElementById("previewCodeResult").style.display = "none";

            const previewCodeResult = document.getElementById("previewCodeResult");
            if (previewCodeResult) {
                const itemList = previewCodeResult.querySelector("#showItemList");
                if (itemList) {
                    itemList.innerHTML = '';
                };
            };

            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.disbled = true;
            var code = redeemCodeInput.value;
            console.log("redeem code called", code);
            code && 0 != code.length && (servicesWs.onopen = function (e) {
                servicesWs.send(JSON.stringify({
                    cmd: "redeem",
                    session: playerAccount.session,
                    code: code
                }))
            }, servicesWs.onmessage = function (e) {
                // devlog("SIR! SIR! DO NOT REDEEM! SIR!");
                let redeemResult = JSON.parse(e.data);
                devlog(redeemResult);

                if (redeemResult.error) console.log("redeemCode Error: " + JSON.stringify(redeemResult.error));
                else {
                    console.log("redeemCode response: " + redeemResult.result);
                    var redeemCodeResultText = document.getElementById("redeemCodeResultText"),
                        redeemCodeSuccessButton = document.getElementById("redeemCodeCompleteButton");
                    switch (document.getElementById("enterRedeemCode").style.display = "none", document.getElementById("redeemCodeResult").style.display = "inline-block", redeemResult.result) {
                        case "SUCCESS":
                            redeemCodeResultText.innerHTML = "<h1>CODE CRACKED!!</h1>", 0 < redeemResult.eggs_given && void 0 !== redeemResult.eggs_given && null !== redeemResult.eggs_given && 0 < redeemResult.eggs_given && (redeemCodeResultText.innerHTML += '<div style="margin-top: 1em; margin-bottom: 2em; text-align: center;"><img src="img/egg_icon.png" style="width: 2em;" /><h2>+ ' + redeemResult.eggs_given + " </h2></div>", checkBalance());
                            var items = [];
                            if (redeemResult.item_ids)
                                for (var i = 0; i < redeemResult.item_ids.length; i++) {
                                    var redeemedItem = catalog.findItemById(redeemResult.item_ids[i]);
                                    playerAccount.isItemOwned(redeemedItem) || playerAccount.inventory.push(redeemedItem), items.push(redeemedItem)
                                }
                            if (customizer.setupItems(), 0 < items.length) {
                                var itemList = createShowItemListHTML(items.length);
                                redeemCodeResultText.innerHTML += itemList.innerHTML, renderItemsInShowItemList(items)
                            }
                            redeemCodeSuccessButton.style = "ssbutton green";
                            break;
                        case "CODE_PREV_REDEEMED":
                            redeemCodeResultText.innerText = "That code has already been used!", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "CODE_NOT_FOUND":
                            redeemCodeResultText.innerText = "Invalid code", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "ERROR":
                            console.log("error: " + redeemResult.error), redeemCodeResultText.innerText = "Uh oh, there was problem", redeemCodeSuccessButton.style = "ssbutton red";
                            break;
                        default:
                            redeemCodeResultText.innerText = "Uh oh, there was problem. Try logging in again.", redeemCodeSuccessButton.style = "ssbutton red"
                    }
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            })
        },
        //this code is really, really, really shit. im sorry. the original function was already super convoluted.
        previewCode: function () {
            console.log("preview code called");
            try {
                var servicesWs = new WebSocket(servicesServer)
            } catch (e) {
                console.log(e)
            }
            var redeemCodeInput = document.getElementById("redeemCodeInput");
            redeemCodeInput.disbled = true;
            var code = redeemCodeInput.value;
            code && 0 != code.length && (servicesWs.onopen = function (e) {
                servicesWs.send(JSON.stringify({
                    cmd: "preview",
                    session: playerAccount.session,
                    code: code
                }))
            }, servicesWs.onmessage = function (e) {
                // devlog("SIR! SIR! DO NOT REDEEM! SIR!");
                let previewResult = JSON.parse(e.data);
                devlog(previewResult);

                if (previewResult.error) console.log("previewCode Error: " + JSON.stringify(previewResult.error));
                else {
                    console.log("previewCode response: " + previewResult.result);

                    let previewOrRedeem = previewResult.result == "SUCCESS" ? "previewCode" : "redeemCode";

                    var previewCodeResultText = document.getElementById(previewOrRedeem+"ResultText");
                    var previewCodeSuccessButton = document.getElementById(previewOrRedeem+"CompleteButton");
                    document.getElementById("enterRedeemCode").style.display = "none";
                    document.getElementById(previewOrRedeem+"Result").style.display = "inline-block";

                    switch (previewResult.result) {
                        case "SUCCESS":
                            previewCodeResultText.innerHTML = "<h1>Do you want to crack this code?</h1>", 0 < previewResult.eggs_given && void 0 !== previewResult.eggs_given && null !== previewResult.eggs_given && 0 < previewResult.eggs_given && (previewCodeResultText.innerHTML += '<div style="margin-top: 1em; margin-bottom: 2em; text-align: center;"><img src="img/egg_icon.png" style="width: 2em;" /><h2>+ ' + previewResult.eggs_given + " </h2></div>", checkBalance());
                            var usesRemaining = document.getElementById("usesCount");
                            if (usesRemaining) {
                                usesRemaining.textContent = previewResult.uses || 0;
                            };
                            var items = [];
                            if (previewResult.item_ids)
                                for (var i = 0; i < previewResult.item_ids.length; i++) {
                                    var redeemedItem = catalog.findItemById(previewResult.item_ids[i]);
                                    playerAccount.isItemOwned(redeemedItem) || playerAccount.inventory.push(redeemedItem), items.push(redeemedItem)
                                }
                            if (customizer.setupItems(), 0 < items.length) {
                                var itemList = createShowItemListHTML(items.length);
                                previewCodeResultText.innerHTML += itemList.innerHTML, renderItemsInShowItemList(items)
                            }
                            previewCodeSuccessButton.style = "ssbutton green";
                            break;
                        case "CODE_PREV_REDEEMED":
                            previewCodeResultText.innerText = "That code has already been used!", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "CODE_NOT_FOUND":
                            previewCodeResultText.innerText = "Invalid code", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        case "ERROR":
                            console.log("error: " + previewResult.error), previewCodeResultText.innerText = "Uh oh, there was problem", previewCodeSuccessButton.style = "ssbutton red";
                            break;
                        default:
                            previewCodeResultText.innerText = "Uh oh, there was problem. Try logging in again.", previewCodeSuccessButton.style = "ssbutton red"
                    }
                }
                servicesWs.close()
            }, servicesWs.onclose = function (e) {
                console.log("servicesWs closed: " + e.code + " " + e.reason)
            }, servicesWs.onerror = function (e) {
                statsEl.innerHTML = '<p style="text-align: left">WebSocket connection failure. Please check your connection at:<br><a href="http://websocketstest.com" target="_window">websocketstest.com</a><br>as well as your firewall and antivirus settings.</p>', console.log("servicesWs Error: " + JSON.stringify(e, ["message", "arguments", "type", "name"]))
            })
        },
        openItemInCustomizer: openItemInCustomizer,
        openTaggedItemsInCustomizer: openTaggedItemsInCustomizer,
        closeGiveRewardDialog: function () {
            document.getElementById("giveRewardDialog").style.display = "none", hideDarkOverlay()
        },
        openBuyPassDialog: openBuyPassDialog,
        closeBuyPassDialog: closeBuyPassDialog,
        setApplixirPopup: setApplixirPopup,
        showBoughtNuggetPopup: showBoughtNuggetPopup,
        buyPass: function () {
        },
        openChickenNugget: function () {
            const nuggetFrame = document.getElementById("nuggetGame_Frame");
            const buyPassDialog = document.getElementById("buyPassDialog");
            const nuggetInstruction = document.getElementById("nuggetGame_Instruction");
            const nuggetDone = document.getElementById("nuggetGame_Done");
            const gotNuggetOK = document.getElementById("gotNuggetOK");

            nuggetFrame.src = "app_nugget/index.html";
            buyPassDialog.classList.add("hideme");
            nuggetInstruction.classList.remove("hideme");
            nuggetDone.classList.add("hideme");
            gotNuggetOK.classList.add("invisible");

            callApi({
                cmd: "token",
                session: playerAccount.session
            }, handleTokenSuccess, handleTokenError);

            function handleTokenSuccess(response) {
                console.log("token: " + JSON.stringify(response.token));
                isGettingNugget = true;
                servicesToken = response.token;
                setApplixirPopup(true);
                showBoughtNuggetPopup();
            };

            function handleTokenError(response) {
                console.log("error getting token");
                openAlertDialog(
                    "Uh Oh!",
                    response.error || "Something broke. Try reloading the game.",
                    null,
                    {
                        label: "OK",
                        width: "4em",
                        onclick: function () {
                            closeAlertDialog();
                            buyPassDialog.classList.toggle("hideme");
                        }
                    }
                );
            }
        },
        finishChickenNuggetGame: function () {
            document.getElementById("nuggetGame_Instruction").classList.toggle("hideme"), document.getElementById("nuggetGame_Done").classList.toggle("hideme"), document.getElementById("gotNuggetOK").classList.toggle("invisible")
        },
        closeChickenNugget: function () {
            document.getElementById("nuggetGame_Frame").src = "about:blank", checkUpgrade();
            var adElement = document.getElementById("shellshock-io_multisize");
            adElement.style.display = "none";
            // document.getElementById("gameAdContainer").appendChild(adElement);
            document.getElementById("gotNuggetPopup").classList.toggle("hideme"), hideDarkOverlay()
        },
        enterSpectatorMode: function () {
            me && (document.getElementById("spectate").style.display = "block", document.getElementById("gameMenu").style.display = "none", document.getElementById("gameSummary").style.visibility = "hidden", document.getElementById("ffaFinal").style.display = "none", document.getElementById("teamFinal").style.display = "none", timedGame && betweenRounds || (document.getElementById("deathBox").style.display = "none", document.getElementById("health").style.display = "block", document.getElementById("killTicker").style.display = "block", document.getElementById("playerList").style.display = "block", chatting && chatInEl.focus()), hideMultisizeBannerAd(), /*document.getElementById("gameAdContainer").style.display = "none",*/ player = function () {
                for (var i = 0; i < playerLimit; i++)
                    if (i != meId && players[i] && players[i].playing) return players[i]
            }(), player.id != meId && (viewingPlayer.actor.hands.setRenderingGroupId(0), viewingPlayer.weapon.actor.gunMesh.setRenderingGroupId(0), viewingPlayer.actor.hat && viewingPlayer.actor.hat.setEnabled(true)), player.actor.hands.setRenderingGroupId(1), player.weapon.actor.gunMesh.setRenderingGroupId(1), player.actor.hat && player.actor.hat.setEnabled(false), player.actor.hideNameSprite(), viewingPlayerId = (viewingPlayer = player).id, doFirstPersonCamera(player), document.getElementById("spectatingName").innerText = player.name);
            var player
        },
        spectatorSelect: function () { },
        clearSettings: function () {
            // programming genius
            localStorage.removeItem("volume");
            localStorage.removeItem("mouseSensitivity");
            localStorage.removeItem("mouseInvert");
            localStorage.removeItem("holdToAim");
            localStorage.removeItem("enableChat");
            localStorage.removeItem("enable18Chat");
            localStorage.removeItem("autoDetail");
            localStorage.removeItem("shadowsEnabled");
            localStorage.removeItem("highRes");
            localStorage.removeItem("controlConfig");
            loadSettings();
        },
        applixirAdStatusHandler: function (status) {
            switch (console.log("Applixir status: " + status), status) {
                case "ad-started":
                case "fb-started":
                    applixirAdWatched = false;
                    break;
                case "ad-watched":
                case "fb-watched":
                case "network-error":
                case "cors-error":
                case "ads-unavailable":
                    applixirAdWatched = true;
                    break;
                case "sys-closing":
                    true === applixirAdWatched ? buyChickenNuggetProduct() : setApplixirPopup(false), applixirAdWatched = false;
                    break;
                case "ad-blocker":
                    setApplixirPopup(false), openAlertDialog("Ad Blocker Detected", "No ads - No nugget", null, {
                        label: "Fine",
                        width: "4em",
                        onclick: function () {
                            closeAlertDialog()
                        }
                    })
            }
        }
    }
}();

console.log(`
    _                                      __
    /                                    /    )   /           /   /
   /       __    __    __    __          \\       /__    __   /   /
  /      /___) /   ) /   ) /   ' /   /    \\     /   ) /___) /   /
_/____/_(___ _(___/_(___(_(___ _(___/_(____/___/___/_(___ _/___/___
                 /                 /
             (_ /              (_ /
           LegacyShell Starting! (Version ${VERSION})
`);

devlog("DEV LOGS ENABLED!");

// [LS] ######## LegacyShell Plugins (After) ---------------------------------
//     ____  __    __  _____________   _______         ___    ______________________ 
//    / __ \/ /   / / / / ____/  _/ | / / ___/   _    /   |  / ____/_  __/ ____/ __ \
//   / /_/ / /   / / / / / __ / //  |/ /\__ \   (_)  / /| | / /_    / / / __/ / /_/ /
//  / ____/ /___/ /_/ / /_/ // // /|  /___/ /  _    / ___ |/ __/   / / / /___/ _, _/ 
// /_/   /_____/\____/\____/___/_/ |_//____/  (_)  /_/  |_/_/     /_/ /_____/_/ |_|  


LEGACYSHELLPLUGINSAFTER